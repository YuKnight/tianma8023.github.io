<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[处理PopupWindow在Android 7.x中兼容性问题]]></title>
      <url>%2Fpost%2F1634332613%2F</url>
      <content type="text"><![CDATA[问题描述PopupWindow 中的 showAsDropDown(View anchor) 用于在指定锚点View下方显示 PopupWindow，在Android 7.0 (api&lt;=23) 以前是没什么问题的，但是在Android 7.x系统上，会在某些情况下出现兼容问题： 如果指定 PopupWindow 的高度为 MATCH_PARENT，调用 showAsDropDown(View anchor) 时，在 7.0 之前，会在锚点 anchor 下边缘到屏幕底部之间显示 PopupWindow；而在 7.0、7.1 系统上的 PopupWindow 会占据整个屏幕（除状态栏之外）。 如果指定 PopupWindow 的高度为 WRAP_CONTENT, 调用 showAsDropDown(View anchor) 时，便不会出现兼容性的问题。 如果指定 PopupWindow 的高度为自定义的值height，调用 showAsDropDown(View anchor)时， 如果 height &gt; 锚点 anchor 下边缘与屏幕底部的距离， 则还是会出现7.0、7.1上显示异常的问题；否则，不会出现该问题。可以看出，情况1和2是情况3的特例。 解决方案如果出现上述分析中的兼容性问题，可以使用 showAtLocation() 方法替代 showAsDropDown() , 示例代码如下，详情可参见 PopupWindowCompatSample 12345678910111213if (Build.VERSION.SDK_INT &gt;= 23) &#123; // Android 7.x中,PopupWindow高度为match_parent时,会出现兼容性问题,需要处理兼容性 int[] location = new int[2]; // 记录anchor在屏幕中的位置 anchor.getLocationOnScreen(location); int offsetY = location[1] + anchor.getHeight(); if (Build.VERSION.SDK_INT == 24) &#123; // Android 7.1中，PopupWindow高度为 match_parent 时，会占据整个屏幕 // 故而需要在 Android 7.1上再做特殊处理 int screenHeight = ScreenUtils.getScreenHeight(context); // 获取屏幕高度 popupWindow.setHeight(screenHeight - offsetY); // 重新设置 PopupWindow 的高度 &#125; popupWindow.showAtLocation(anchor, Gravity.NO_GRAVITY, 0, offsetY);&#125; else &#123; popupWindow.showAsDropDown(anchor);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[消除Android 5.0 ~ 7.1.1原生系统中感叹号或叉号]]></title>
      <url>%2Fpost%2F2812053051%2F</url>
      <content type="text"><![CDATA[0x01 前言在使用Android5.0以上的原生系统过程中，大家会遇到明明自己网络是OK的，但是会在状态栏的移动信号或 WiFi 图标旁显示感叹号（5.0 ~ 7.0.0）或叉号（7.1.1），并且会提示“已连接，但不能接入互联网”的情况… 0x02 原因从Android 5.0开始，系统连接网络或切换网络时，系统模块 NetworkMonitor 会向一特定网址发送数据请求，根据响应的结果从而判断网络的连通性。在原生Android系统中，这一特定网址是Google的网址，不翻墙访问不了，故而会出现感叹号或叉号。 0x03 解决方案既然知晓了原理，那么解决方案也很明确了： 完全关闭网络检查服务（不可取）： 1adb shell settings put global captive_portal_detection_enabled 0 缺点：&nbsp; 完全屏蔽该系统功能带来明显的问题，当你使用公共 Wi-Fi 这种需要使用 portal 验证的网络时，因为网络检查被关闭，系统在访问 portal 验证页面时无法返回正确的值，最终导致无法完成验证和上网。 替换检查网络的网址（可取）： 通过ADB命令，将验证服务的网址替换为国内正常可以访问的网址 Android 5.x ~ 6.x 解决方案12adb shell &quot;settings put global captive_portal_server www.v2ex.com&quot;adb shell reboot Android 7.0.0 ~ 7.1.0 解决方案12adb shell &quot;settings put global captive_portal_server captive.v2ex.co&quot;adb shell reboot Android 7.1.1 解决方案12adb shell &quot;settings put global captive_portal_https_url https://captive.v2ex.co/generate_204&quot;adb shell reboot 0x04 源码问题解决了，问题产生的根本源头在哪呢，在源码里面 :) Android 5.x ~ 6.x123456789101112private int isCaptivePortal() &#123; if (!mIsCaptivePortalCheckEnabled) return 204; HttpURLConnection urlConnection = null; int httpResponseCode = 599; try &#123; URL url = new URL("http", mServer, "/generate_204"); if (DBG) &#123; log("Checking " + url.toString() + " on " + mNetworkAgentInfo.networkInfo.getExtraInfo()); &#125; &#125; // ...&#125; 原来的 mServer 是 clients3.google.com，我们最终将其换为 www.v2ex.com. Android 7.0 ~ 7.1.0123456private static String getCaptivePortalServerUrl(Context context, boolean isHttps) &#123; String server = Settings.Global.getString(context.getContentResolver(), Settings.Global.CAPTIVE_PORTAL_SERVER); if (server == null) server = DEFAULT_SERVER; return (isHttps ? "https" : "http") + "://" + server + "/generate_204";&#125; Android 7.0 ~ 7.1.0 新增了https的验证请求，所以我们把 server 的值改为支持https的 captive.v2ex.co. Android 7.1.1123private static String getCaptivePortalServerHttpsUrl(Context context) &#123; return getSetting(context, Settings.Global.CAPTIVE_PORTAL_HTTPS_URL, DEFAULT_HTTPS_URL);&#125; DEFAULT_HTTPS_URL 的值由原来的 https://www.google.com/generate_204 替换为 https://captive.v2ex.co/generate_204. 源码链接：5.x ~ 6.x7.0.0 ~ 7.1.07.1.1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[监听Android设备网络变化]]></title>
      <url>%2Fpost%2F7e2408ee%2F</url>
      <content type="text"><![CDATA[0x01 目标在实际开发中，我们不可避免地需要对请求错误进行处理，通常情况下，我们会这样去处理错误请求： 没有网络的情况下，提示用户网络连接不可用，引导用户打开网络或重新刷新等 有网络的情况下，则是客户端或服务端的错误，给用户相应的提示 如果针对第一种情况,我们需要在网络恢复的时候重新刷新数据或进行其他操作,又应该如何实现呢？以下就是我们的目标： 监听Android设备网络状态 在网络状态发生改变时,做出相应操作 在示例中，我们在网络状态发生变化时，显示当前网络变化的类型。 0x02 思路在Android系统在网络变化的情况下，会发出 action 为 ConnectivityManager.CONNECTIVITY_ACTION 的系统广播，我们只需要注册 BroadcastReceiver 去监听该广播即可监听设备的网络变化情况。 那么，注册 BroadcastReceiver 是静态注册呢，还是动态注册呢？ 静态注册：通常来讲，退出应用后，该应用仍然能够接收到相应的广播 动态注册：随着所在Context或应用被销毁后，不会收到相应的广播 注意：针对静态注册，这里是用“通常来讲”来修饰的，也就是说，存在特殊情况，即：存在即使使用静态注册，也不会收到相应的广播的情况： Android3.1之后，系统为了加强了安全性控制，应用程序安装后或是(设置)应用管理中被强制关闭后处于stopped状态，在这种状态下接收不到任何广播，除非广播带有 FLAG_INCLUDE_STOPPED_PACKAGES 标志，而默认所有系统广播都是 FLAG_EXCLUDE_STOPPED_PACKAGES 的，所以就没法通过系统广播自启动了。 这其中就包括 ConnectivityManager.CONNECTIVITY_ACTION 。关于这一块的内容，不是本篇重点，欲了解详情，请移步Android应用为何开机自启动、自启动失败原因 另外，Android 7.0 移除了三个隐式广播(Android 7.0 行为变更)，其中就包括 ConnectivityManager.CONNECTIVITY_ACTION , 这意味着通过静态注册 BroadcastReceiver 来监听该广播的方式在 targetSdkVersion &gt;= 24 版本上不再生效，如何解决这一问题请移步 Android 7.0 网络变化监听。 所以，这里采取动态注册 BroadcastReceiver 的方式。那么，应该在哪里动态注册呢？这里有两种思路： 定义 BroadcastReceiver 监听网络状态，并提供回调接口 NetStateChangeObserver 用以回调网络状态的变化 抽象出 BaseActivity ，提供注册/取消注册 BroadcastReceiver 的方法，并实现 NetStateChangeObserver 需要监听网络状态的 Activity 调用 BaseActivity 提供的方法即可 定义 BroadcastReceiver 监听网络状态，并提供回调接口 NetStateChangeObserver 用以回调网络状态的变化，并在 BroadcastReceiver 中维护 NetStateChangeObserver 列表，当网络发生变化则通知这些 Observer ，实现回调。 在 Application 中注册/取消注册 BroadcastReceiver 抽象 BaseActivity ，提供注册/取消注册 NetStateChangeObserver 观察者的方法， 并实现 NetStateChangeObserver 需要监听网络状态的 Activity 调用 BaseActivity 提供的方法即可 上面的两种思路，比较重要的区别在于，第1中是在 Activity 中注册 BroadcastReceiver , 后者是在 Application 中注册 BroadcastReceiver。前者需要多次注册 BroadcastReceiver 而后者只注册一次，所以在这里选择第2中思路。 0x03 实现添加权限1&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; 定义网络类型12345678910111213141516171819public enum NetworkType &#123; NETWORK_WIFI("WiFi"), NETWORK_4G("4G"), NETWORK_3G("3G"), NETWORK_2G("2G"), NETWORK_UNKNOWN("Unknown"), NETWORK_NO("No network"); private String desc; NetworkType(String desc) &#123; this.desc = desc; &#125; @Override public String toString() &#123; return desc; &#125;&#125; 定义观察者123456789/** * 网络状态变化观察者 */public interface NetStateChangeObserver &#123; void onNetDisconnected(); void onNetConnected(NetworkType networkType);&#125; 实现 BroadcastReceiver123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * 监听网络状态变化的BroadcastReceiver */public class NetStateChangeReceiver extends BroadcastReceiver &#123; private static class InstanceHolder &#123; private static final NetStateChangeReceiver INSTANCE = new NetStateChangeReceiver(); &#125; private List&lt;NetStateChangeObserver&gt; mObservers = new ArrayList&lt;&gt;(); public NetStateChangeReceiver() &#123; &#125; @Override public void onReceive(Context context, Intent intent) &#123; if (ConnectivityManager.CONNECTIVITY_ACTION.equals(intent.getAction())) &#123; NetworkType networkType = NetworkUtils.getNetworkType(context); notifyObservers(networkType); &#125; &#125; /** * 注册网络监听 */ public static void registerReceiver(@NonNull Context context) &#123; IntentFilter intentFilter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION); context.registerReceiver(InstanceHolder.INSTANCE, intentFilter); &#125; /** * 取消网络监听 */ public static void unregisterReceiver(@NonNull Context context) &#123; context.unregisterReceiver(InstanceHolder.INSTANCE); &#125; /** * 注册网络变化Observer */ public static void registerObserver(NetStateChangeObserver observer) &#123; if (observer == null) return; if (!InstanceHolder.INSTANCE.mObservers.contains(observer)) &#123; InstanceHolder.INSTANCE.mObservers.add(observer); &#125; &#125; /** * 取消网络变化Observer的注册 */ public static void unregisterObserver(NetStateChangeObserver observer) &#123; if (observer == null) return; if (InstanceHolder.INSTANCE.mObservers == null) return; InstanceHolder.INSTANCE.mObservers.remove(observer); &#125; /** * 通知所有的Observer网络状态变化 */ private void notifyObservers(NetworkType networkType) &#123; if (networkType == NetworkType.NETWORK_NO) &#123; for(NetStateChangeObserver observer : mObservers) &#123; observer.onNetDisconnected(); &#125; &#125; else &#123; for(NetStateChangeObserver observer : mObservers) &#123; observer.onNetConnected(networkType); &#125; &#125; &#125;&#125; Application 注册 BroadcastReceiver12345678910111213141516public class AppContext extends Application&#123; @Override public void onCreate() &#123; super.onCreate(); // 注册BroadcastReceiver NetStateChangeReceiver.registerReceiver(this); &#125; @Override public void onTerminate() &#123; super.onTerminate(); // 取消BroadcastReceiver注册 NetStateChangeReceiver.unregisterReceiver(this); &#125;&#125; BaseActivity 抽取123456789101112131415161718192021222324252627282930313233public class BaseActivity extends AppCompatActivity implements NetStateChangeObserver &#123; @Override protected void onResume() &#123; super.onResume(); if (needRegisterNetworkChangeObserver()) &#123; NetStateChangeReceiver.registerObserver(this); &#125; &#125; @Override protected void onStop() &#123; super.onStop(); if (needRegisterNetworkChangeObserver()) &#123; NetStateChangeReceiver.unregisterObserver(this); &#125; &#125; /** * 是否需要注册网络变化的Observer,如果不需要监听网络变化,则返回false;否则返回true.默认返回false */ protected boolean needRegisterNetworkChangeObserver() &#123; return false; &#125; @Override public void onNetDisconnected() &#123; &#125; @Override public void onNetConnected(NetworkType networkType) &#123; &#125;&#125; 需要实现网络监听的 Activity 只需要复写 needRegisterNetworkChangeObserver 并返回 true ，并复写相关回调函数即可。 github源码地址:NetDetector]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2Fpost%2F4a17b156%2F</url>
      <content type="text"><![CDATA[Hello World&nbsp;&nbsp;:) Welcome to my blog, have a nice day!&nbsp; ^_^ 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("Hello World."); &#125;&#125; Everthing will be okay in the end. If it’s not okay, it’s not the end. 有志者 事竟成 破釜沉舟 百二秦关终属楚苦心人 天不负 卧薪尝胆 三千越甲可吞吴]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[免费ShadowSocks账号]]></title>
      <url>%2Fpost%2F402cab53%2F</url>
      <content type="text"><![CDATA[0x01 &nbsp;免费提供SS账号的网站在这里我列出几个免费提供SS账户的网站： 免费ShadowSocks账号 世界那么大，我想去看看 SS ISS 这里需要注意的是： 以上这些网站提供的ss账号都会不断更新的，所以如果你使用这些免费的服务的话，可能需要及时更新。当然了，如果你是Programmer，你当然可以写脚本去爬取了对吧 :) 如果这些网站访问不了，可能是换网址了 or 被墙了 or 其他不可抗力的原因… 0x02 &nbsp;搭建自己的梯子之前是自己在网上找的免费的SS账户，这些免费的SS账户虽然可以提供免费的科学上网服务，但是不是特别稳定。再者，如果你对网络安全性比较在意的话，可能你需要考虑自己搭梯子了。所以，我就自己自己搭建了梯子，我采取的方案是VPS+ShadowSocks，VPS需要自己购买，我用的是搬瓦工的VPS，这里给个链接Mass VPS hosting on Enterprise equipment - Bandwagon Host,按月付的话最便宜的是2.99刀，当然了如果年付的话就更便宜了。当然了，还有其他的VPS提供商供大家选择，由于我没有尝试其他的，就不在这里列出来了。具体搭梯子的教程网上有很多，在这里贴几个： 搭建自己的Shadowsocks服务器 在 Ubuntu 服务器上部署 shadowsocks 科学上网之 Shadowsocks 安装及优化加速 ss优化加速 - 需翻墙如果感觉以上链接不太适合你的话，利用搜索引擎，多找找吧 :) 0x03 &nbsp;免费SS账户在这里我把我搭的SS Server的账号提供出来，反正流量比较多，造福下大家咯。当然了，如果它不生效了，恕不通知哈。可能是没再续费了，也可能是换账号了，etc. 服务器地址服务器端口密码加密方式23.106.158.19055501zljw5501aes-256-cfb]]></content>
    </entry>

    
  
  
</search>
