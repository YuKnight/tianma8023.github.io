<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[RecyclerView添加分割线]]></title>
      <url>post%2F1138009507%2F</url>
      <content type="text"><![CDATA[RecyclerView 并没有 divider 属性，但是我们可以通过 RecyclerView 的 addItemDecoration() 来添加分割线，该方法参数为 RecyclerView.ItemDecoration。 介绍当 RecyclerView 添加 ItemDecoration 后，RecyclerView 在绘制每个 item 的时候，会去绘制 decorator，也就是会调用 ItemDecoration 的 onDraw() 和 onDrawOver() 方法。 RecyclerView.ItemDecoration 是抽象类，主要提供三个方法： onDraw(Canvas c, RecyclerView parent, State state)： 在绘制item（drawChild） 前调用 onDrawOver(Canvas c, RecyclerView parent, State state): 在绘制item（drawChild） 后调用 getItemOffsets(Rect outRect, View view, RecyclerView parent, State state)：outRect设置 item 的偏移量，用于绘制 decorator（也就是divider） 关于 getItemOffsets 函数RecyclerView 添加分割线，实际上就是 RecyclerView 的 item 之间添加了用作分割线的View，自然而然后续的 item 就会有偏移量，所以用 getItemOffsets 中的 outRect 来保存 item 的偏移量，从而便于绘制 decorator。 实现实际上在当前版本的 RecyclerView (25.3.1) 中已经有 ItemDecoration 关于分割线的默认实现类 DividerItemDecoration: package android.support.v7.widget; import android.annotation.SuppressLint; import android.content.Context; import android.content.res.TypedArray; import android.graphics.Canvas; import android.graphics.Rect; import android.graphics.drawable.Drawable; import android.support.annotation.NonNull; import android.support.v4.view.ViewCompat; import android.view.View; import android.widget.LinearLayout; public class DividerItemDecoration extends RecyclerView.ItemDecoration { public static final int HORIZONTAL = LinearLayout.HORIZONTAL; public static final int VERTICAL = LinearLayout.VERTICAL; // 如果不设置，则默认的分割线为 android.R.attr.listDivider 指定的 drawable private static final int[] ATTRS = new int[]{ android.R.attr.listDivider }; private Drawable mDivider; /** * Current orientation. Either {@link #HORIZONTAL} or {@link #VERTICAL}. */ private int mOrientation; private final Rect mBounds = new Rect(); /** * Creates a divider {@link RecyclerView.ItemDecoration} that can be used with a * {@link LinearLayoutManager}. * * @param context Current context, it will be used to access resources. * @param orientation Divider orientation. Should be {@link #HORIZONTAL} or {@link #VERTICAL}. */ public DividerItemDecoration(Context context, int orientation) { final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); a.recycle(); setOrientation(orientation); } /** * Sets the orientation for this divider. This should be called if * {@link RecyclerView.LayoutManager} changes orientation. * * @param orientation {@link #HORIZONTAL} or {@link #VERTICAL} */ public void setOrientation(int orientation) { if (orientation != HORIZONTAL &amp;&amp; orientation != VERTICAL) { throw new IllegalArgumentException( "Invalid orientation. It should be either HORIZONTAL or VERTICAL"); } mOrientation = orientation; } /** * Sets the {@link Drawable} for this divider. * * @param drawable Drawable that should be used as a divider. */ public void setDrawable(@NonNull Drawable drawable) { if (drawable == null) { throw new IllegalArgumentException("Drawable cannot be null."); } mDivider = drawable; } @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) { if (parent.getLayoutManager() == null) { return; } if (mOrientation == VERTICAL) { drawVertical(c, parent); } else { drawHorizontal(c, parent); } } // 绘制 RecyclerView 为垂直布局时的分割线，此时分割线为水平分割线 @SuppressLint("NewApi") private void drawVertical(Canvas canvas, RecyclerView parent) { canvas.save(); final int left; final int right; // 需要考虑clipToPadding的boolean值 if (parent.getClipToPadding()) { left = parent.getPaddingLeft(); right = parent.getWidth() - parent.getPaddingRight(); canvas.clipRect(left, parent.getPaddingTop(), right, parent.getHeight() - parent.getPaddingBottom()); } else { left = 0; right = parent.getWidth(); } final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); parent.getDecoratedBoundsWithMargins(child, mBounds); final int bottom = mBounds.bottom + Math.round(ViewCompat.getTranslationY(child)); final int top = bottom - mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(canvas); } canvas.restore(); } // 绘制 RecyclerView 为水平布局时的分割线，此时分割线为垂直分割线 @SuppressLint("NewApi") private void drawHorizontal(Canvas canvas, RecyclerView parent) { canvas.save(); final int top; final int bottom; // 需要考虑clipToPadding的boolean值 if (parent.getClipToPadding()) { top = parent.getPaddingTop(); bottom = parent.getHeight() - parent.getPaddingBottom(); canvas.clipRect(parent.getPaddingLeft(), top, parent.getWidth() - parent.getPaddingRight(), bottom); } else { top = 0; bottom = parent.getHeight(); } final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); parent.getLayoutManager().getDecoratedBoundsWithMargins(child, mBounds); final int right = mBounds.right + Math.round(ViewCompat.getTranslationX(child)); final int left = right - mDivider.getIntrinsicWidth(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(canvas); } canvas.restore(); } @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) { if (mOrientation == VERTICAL) { // 垂直方向的RecyclerView, item 的 bottom 偏移量 = 分割线高度 outRect.set(0, 0, 0, mDivider.getIntrinsicHeight()); } else { // 水平方向的RecyclerView， item 的 right 偏移量 = 分割线宽度 outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0); } } } 在代码中添加： recyclerView.addItemDecoration(new DividerItemDecoration(recyclerView.getContext(), mLayoutManager.getOrientation())); 就有了分割线。 默认的分割线效果是系统自带的 listDivider 的效果，我们也可以在主题配置文件中自定义全局的分割线，或者调用 setDivider 为每个 RecyclerView 设置单独的分割线。 网络流行代码存在的问题目前好多博客中关于 DividerItemDecoration 中 drawVertical() 和 drawHorizontal() 方法与官方的方法其实是有出入的： public void drawVertical(Canvas c, RecyclerView parent) { final int left = parent.getPaddingLeft(); final int right = parent.getWidth() - parent.getPaddingRight(); // 网上的方法最主要的问题是没有考虑 clipToPadding 这个参数，所以说这里缺少相应代码片段 final int childCount = parent.getChildCount(); // 下面这块没什么问题，和官方方案殊途同归 // 官方的getDecoratedBoundsWithMargins实际上也是通过 LayoutParams 来获取分割线边界的 for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int top = child.getBottom() + params.bottomMargin; final int bottom = top + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); } } public void drawHorizontal(Canvas c, RecyclerView parent) { final int top = parent.getPaddingTop(); final int bottom = parent.getHeight() - parent.getPaddingBottom(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int left = child.getRight() + params.rightMargin; final int right = left + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); } } 注释中说的比较明确了，网上好多方法主要的问题在于 没有考虑 clipToPadding 属性值 。 clipToPadding 表示控件的绘制区域是否在 padding 区域外面，其默认值为 true。比如，垂直方向的 RecyclerView，当 clipToPadding=false 时，其初始绘制区域与 padding 值有关，但向上滑动时，RecylerView 的 item 会滑到 padding 区域里面。 下面用示意图来进行解释，RecyclerView 的 paddingTop = 40dp, clipToPadding = false, 下图中白色区域为 paddingTop 区域：初始状态下向上滑动 小结总的来说，目前添加分割线只需要使用 recyclerview-v7 包下的 DividerItemDecoration 类即可，分割线可以通过 setDivider 来个性化指定，也可以通过配置主题中的 android:listDivider 来全局指定。 参考Android RecyclerView 使用完全解析 体验艺术般的控件RecyclerView系列之二：添加分隔线android:clipToPadding和android:clipChildren]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在Android Studio中使用Lambda表达式]]></title>
      <url>post%2F837474051%2F</url>
      <content type="text"><![CDATA[Lambda 表达式是 Java 8 的新特性之一，本文主要介绍如何让 Android 项目集成 Labmda 表达式功能。 已知的集成方式有两种： 使用官方的 Jack 工具链 启用Java 8 功能 使用第三方库 Retrolambda 启用 Java 8功能 在本人使用过程中发现，通过 Jack 集成的方式，存在一些问题（不仅仅是官方声明的问题），所以在这里 推荐使用 Retrolambda 来集成 Lambda 功能。 2017-06-05 更新： 通过在不同的SDK版本上测试发现，Android M (api 23)以下版本中，不论是 Jack 还是 Retrolambda 的集成方式均会偶现 NoClassDefFoundError，并都没有成型的解决方案，所以以下诸君看看便可，不太能付诸实际项目中~ :( 官方Jack集成在模块级别的 build.gradle 中配置： android { ... defaultConfig { ... jackOptions { // 开启 Jack enabled true } } compileOptions { // 使用 Java 8 进行编译 sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } } 当然你首先得有 JDK 8 的开发环境。 第三方Retrolambda集成因为 Android Studio 使用 Gradle 作为构建工具，所以我们需要在集成 gradle-retrolambda Gradle 插件： 下载安装 JDK 8 在项目级别（项目根目录）的 build.gradle 中加入： buildscript { repositories { ... mavenCentral() // 加入 mavenCentral } dependencies { ... classpath 'me.tatarka:gradle-retrolambda:3.6.1' // 将retrolambda加入classpath } } allProjects { repositories { ... mavenCentral() // 加入 mavenCentral } } 在模块级别的 build.gradle 中加入： apply plugin: 'com.android.application' apply plugin: 'me.tatarka.retrolambda' // 引入 retrolambda 插件 android { ... compileOptions { // 使用 Java 8 进行编译 sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } } 在混淆文件中加入 -dontwarn java.lang.invoke.* -dontwarn **$$Lambda$* 之后就可以愉快的使用 Lambda 表达式啦~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FloatingActionButton的滚动隐藏和显示]]></title>
      <url>post%2F4166466910%2F</url>
      <content type="text"><![CDATA[概述FloatingActionButton（FAB）其实就是遵循了 Material Design 设计规范的并拥有特定动作行为的 ImageButton，基本用法参照 ImageButton 即可。 比如说，可以在 RecyclerView 向下滚动的时候隐藏 FAB, 向上滚动的时候显示 FAB: FAB演示动画 那么，如何实现上面 FAB 的滚动隐藏和显示动画呢？ 实现我们需要通过导入 Design Support Library 才能使用 FAB, 所以，需要在 build.gradle 中加入 compile &#39;com.android.support:design:X.X.X&#39; 其中 X 代表 Support Library 的版本。 一般来说，我们需要把 FAB 放在 CoordinatorLayout 布局中， CoordinatorLayout 可以看做为 FrameLayout，其特殊之处在于可以协调子控件的交互，其中就包括FAB的滚动隐藏和显示的动画。 那么，演示动画中的布局为： &lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"> &lt;android.support.v7.widget.RecyclerView android:id="@+id/recycler_view" android:layout_width="match_parent" android:layout_height="match_parent"/> &lt;android.support.design.widget.FloatingActionButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="bottom|end" android:layout_margin="16dp" android:src="@drawable/ic_add_white" app:layout_behavior="com.tianma.recyclerviewsample.fab.FabScrollBehavior" app:elevation="4dp"/> &lt;/android.support.design.widget.CoordinatorLayout> app:elevation 属性表示 FloatingActionButton 悬浮的高度，高度越大，投影范围越大，投影效果越淡；高度越小，投影范围越小，投影效果越明显。 app:layout_behavior 属性表示 FloatingActionButton 所实现的 CoordinatorLayout Behavior, 这个属性指定的 Behavior 用于定义 FloatingActionButton 与在同一个 CoordinatorLayout 布局下的其他控件的交互方式。如果不指定自定义的 Behavior，那么FloatingActionButton 默认的 Behavior 是为 Snackbar 留出空间，详见 演示视频 显然， FAB 默认的 Behavior 不能满足我们的需要，那么就需要自定义 Behavior 来实现 FAB 的滚动显示和隐藏动画： package com.tianma.recyclerviewsample.fab; import android.content.Context; import android.support.design.widget.CoordinatorLayout; import android.support.design.widget.FloatingActionButton; import android.support.v4.view.ViewCompat; import android.util.AttributeSet; import android.view.View; import android.view.animation.LinearInterpolator; public class FabScrollBehavior extends FloatingActionButton.Behavior { // 因为需要在布局xml中引用，所以必须实现该构造方法 public FabScrollBehavior(Context context, AttributeSet attrs) { super(context, attrs); } @Override public boolean onStartNestedScroll(final CoordinatorLayout coordinatorLayout, final FloatingActionButton child, final View directTargetChild, final View target, final int nestedScrollAxes) { // 确保滚动方向为垂直方向 return nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL; } @Override public void onNestedScroll(final CoordinatorLayout coordinatorLayout, final FloatingActionButton child, final View target, final int dxConsumed, final int dyConsumed, final int dxUnconsumed, final int dyUnconsumed) { super.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed); if (dyConsumed > 0) { // 向下滑动 animateOut(child); } else if (dyConsumed &lt; 0) { // 向上滑动 animateIn(child); } } // FAB移出屏幕动画（隐藏动画） private void animateOut(FloatingActionButton fab) { CoordinatorLayout.LayoutParams layoutParams = (CoordinatorLayout.LayoutParams) fab.getLayoutParams(); int bottomMargin = layoutParams.bottomMargin; fab.animate().translationY(fab.getHeight() + bottomMargin).setInterpolator(new LinearInterpolator()).start(); } // FAB移入屏幕动画（显示动画） private void animateIn(FloatingActionButton fab) { fab.animate().translationY(0).setInterpolator(new LinearInterpolator()).start(); } } 上述代码的关键就是找到 “隐藏动画” 和 “显示动画” 触发的时机，然后利用 “属性动画” 来实现对应的动画效果即可。 参考链接：Floating Action Buttons Guides]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[监听RecyclerView是否滑动到底部]]></title>
      <url>post%2F188185634%2F</url>
      <content type="text"><![CDATA[最近想动手实现 RecyclerView 的“自动加载更多”功能，即当 RecyclerView 滑动到底部时，执行加载更多操作。这里的关键在于，需要监听RecyclerView是否滑动到底部。 分析RecyclerView 有 addOnScrollListener(OnScrollListener) 方法，可以为 RecyclerView 添加滚动监听，其中 OnScrollListener 有两个回调函数： onScrollStateChanges(RecyclerView recyclerView, int newState): 在 RecyclerView 的滚动状态发生改变时回调 onScrolled(RecyclerView recyclerView, int dx, int dy): 在 RecyclerView 滚动时回调 在 OnScrollListener 回调中，可以获取RecyclerView的滚动状态，我们只需要通过继承 OnScrollListener 并复写上面的两个回调函数，便可以实现对 RecyclerView 滑动到底部的监听。 实现我们先定义一个回调接口 BottomListener 用以监听控件是否滚动到底部： public interface BottomListener { /** * 滑动到底部时回调 */ void onScrollToBottom(); } 然后，我们继承 RecyclerView.OnScrollListener 和实现 BottomListener ： import android.support.v7.widget.GridLayoutManager; import android.support.v7.widget.LinearLayoutManager; import android.support.v7.widget.RecyclerView; import android.support.v7.widget.StaggeredGridLayoutManager; /** * 实现了RecyclerView滚动到底部监听的OnScrollListener */ public class RecyclerViewScrollListener extends RecyclerView.OnScrollListener implements BottomListener { // 最后几个完全可见项的位置（瀑布式布局会出现这种情况） private int[] lastCompletelyVisiblePositions; // 最后一个完全可见项的位置 private int lastCompletelyVisibleItemPosition; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager(); // 找到最后一个完全可见项的位置 if (layoutManager instanceof StaggeredGridLayoutManager) { StaggeredGridLayoutManager manager = (StaggeredGridLayoutManager) layoutManager; if (lastCompletelyVisiblePositions == null) { lastCompletelyVisiblePositions = new int[manager.getSpanCount()]; } manager.findLastCompletelyVisibleItemPositions(lastCompletelyVisiblePositions); lastCompletelyVisibleItemPosition = getMaxPosition(lastCompletelyVisiblePositions); } else if (layoutManager instanceof GridLayoutManager) { lastCompletelyVisibleItemPosition = ((GridLayoutManager) layoutManager).findLastCompletelyVisibleItemPosition(); } else if (layoutManager instanceof LinearLayoutManager) { lastCompletelyVisibleItemPosition = ((LinearLayoutManager) layoutManager).findLastCompletelyVisibleItemPosition(); } else { throw new RuntimeException("Unsupported LayoutManager."); } } private int getMaxPosition(int[] positions) { int max = positions[0]; for (int i = 1; i &lt; positions.length; i++) { if (positions[i] > max) { max = positions[i]; } } return max; } @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) { RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager(); // 通过比对 最后完全可见项位置 和 总条目数，来判断是否滑动到底部 int visibleItemCount = layoutManager.getChildCount(); int totalItemCount = layoutManager.getItemCount(); if (newState == RecyclerView.SCROLL_STATE_IDLE) { if (visibleItemCount > 0 &amp;&amp; lastCompletelyVisibleItemPosition >= totalItemCount - 1) { onScrollToBottom(); } } } @Override public void onScrollToBottom() { } } 上述大体思路就是： 找到 “最后完全可见项的位置(lastCompletelyVisibleItemPosition)”，通过比较 lastCompletelyVisibleItemPosition 是否是 RecyclerView 最后一项，来判断是否滑动到底部。 在 RecyclerView 上应用加载更多： recyclerView.addOnScrollListener(new RecyclerViewScrollListener() { @Override public void onScrollToBottom() { // 加载更多 doLoadMore(); } }); // ... private void doLoadMore() { // TODO load more } 参考链接：通过重写OnScrollListener来监听RecyclerView是否滑动到底部 特别注意个人认为上面的参考链接中给出的方案是有一定问题的，原博主计算的是 “最后一个可见项的位置（lastVisibleItemPosition）”，而本文中计算的是 “最后一个完全可见项的位置(lastCompletelyVisibleItemPosition)” , 很明显 RecyclerView 列表中最后一个元素可见的时候，RecyclerView 并不一定滑动到最底部了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java反射修改final修饰的属性值]]></title>
      <url>post%2F463108745%2F</url>
      <content type="text"><![CDATA[之前在阅读其他源码的时候，想要修改其中被 final 修饰符修饰的字段的值，可行吗？&nbsp; 解决方案使用Java反射，通过 Field#setAccessible(true) 将 private 修饰的字段变为 accessible；再将 final 修饰符去掉；最后再设置新值即可。当然，如果涉及到 Java 内联优化，则会失效。具体见示例代码： package com.tianma.sample; import java.lang.reflect.Field; import java.lang.reflect.Modifier; public class ChangeStaticFinalFieldSample { static void changeStaticFinal(Field field, Object newValue) throws Exception { field.setAccessible(true); // 如果field为private,则需要使用该方法使其可被访问 Field modifersField = Field.class.getDeclaredField("modifiers"); modifersField.setAccessible(true); // 把指定的field中的final修饰符去掉 modifersField.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL); field.set(null, newValue); // 为指定field设置新值 } public static void main(String[] args) throws Exception { Sample.print(); Field canChangeField = Sample.class.getDeclaredField("CAN_CHANGE"); Field cannotChangeField = Sample.class.getDeclaredField("CANNOT_CHANGE"); changeStaticFinal(canChangeField, 2); changeStaticFinal(cannotChangeField, 3); Sample.print(); } } class Sample { private static final int CAN_CHANGE = new Integer(1); // 未内联优化 private static final int CANNOT_CHANGE = 1; // 内联优化 public static void print() { System.out.println("CAN_CHANGE = " + CAN_CHANGE); System.out.println("CANNOT_CHANGE = " + CANNOT_CHANGE); System.out.println("------------------------"); } } 打印结果为： CAN_CHANGE = 1 CANNOT_CHANGE = 1 ------------------------ CAN_CHANGE = 2 CANNOT_CHANGE = 1 ------------------------ 通过以上输出结果可以看出， CAN_CHANGE 和 CANNOT_CHANGE 字段同属于 final 修饰符修饰的常量字段，但是由于 CANNOT_CHANGE 常量在 Java 编译过程中使用了内联优化，其值在编译阶段就被编译为常量值 1，故而使用内联优化的 final 字段更改其值是无效的； 而 CAN_CHANGE 字段未被内联优化，故而能通过 Java 反射对其值进行修改。 参考Change private static final field using Java reflection]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[处理PopupWindow在Android 7.x中兼容性问题]]></title>
      <url>post%2F1634332613%2F</url>
      <content type="text"><![CDATA[问题描述PopupWindow 中的 showAsDropDown(View anchor) 用于在指定锚点View下方显示 PopupWindow，在Android 7.0 (api&lt;=23) 以前是没什么问题的，但是在Android 7.x系统上，会在某些情况下出现兼容问题： 如果指定 PopupWindow 的高度为 MATCH_PARENT，调用 showAsDropDown(View anchor) 时，在 7.0 之前，会在锚点 anchor 下边缘到屏幕底部之间显示 PopupWindow；而在 7.0、7.1 系统上的 PopupWindow 会占据整个屏幕（除状态栏之外）。 如果指定 PopupWindow 的高度为 WRAP_CONTENT, 调用 showAsDropDown(View anchor) 时，便不会出现兼容性的问题。 如果指定 PopupWindow 的高度为自定义的值height，调用 showAsDropDown(View anchor)时， 如果 height &gt; 锚点 anchor 下边缘与屏幕底部的距离， 则还是会出现7.0、7.1上显示异常的问题；否则，不会出现该问题。可以看出，情况1和2是情况3的特例。 解决方案如果出现上述分析中的兼容性问题，可以使用 showAtLocation() 方法替代 showAsDropDown() , 示例代码如下，详情可参见 PopupWindowCompatSample if (Build.VERSION.SDK_INT >= 23) { // Android 7.x中,PopupWindow高度为match_parent时,会出现兼容性问题,需要处理兼容性 int[] location = new int[2]; // 记录anchor在屏幕中的位置 anchor.getLocationOnScreen(location); int offsetY = location[1] + anchor.getHeight(); if (Build.VERSION.SDK_INT == 24) { // Android 7.1中，PopupWindow高度为 match_parent 时，会占据整个屏幕 // 故而需要在 Android 7.1上再做特殊处理 int screenHeight = ScreenUtils.getScreenHeight(context); // 获取屏幕高度 popupWindow.setHeight(screenHeight - offsetY); // 重新设置 PopupWindow 的高度 } popupWindow.showAtLocation(anchor, Gravity.NO_GRAVITY, 0, offsetY); } else { popupWindow.showAsDropDown(anchor); }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[消除Android 5.0 ~ 7.1.1原生系统中感叹号或叉号]]></title>
      <url>post%2F2812053051%2F</url>
      <content type="text"><![CDATA[前言在使用Android5.0以上的原生系统过程中，大家会遇到明明自己网络是OK的，但是会在状态栏的移动信号或 WiFi 图标旁显示感叹号（5.0 ~ 7.0.0）或叉号（7.1.1），并且会提示“已连接，但不能接入互联网”的情况… 原因从Android 5.0开始，系统连接网络或切换网络时，系统模块 NetworkMonitor 会向一特定网址发送数据请求，根据响应的结果从而判断网络的连通性。在原生Android系统中，这一特定网址是Google的网址，不翻墙访问不了，故而会出现感叹号或叉号。 解决方案既然知晓了原理，那么解决方案也很明确了： 完全关闭网络检查服务（不可取）： adb shell settings put global captive_portal_detection_enabled 0 缺点：&nbsp; 完全屏蔽该系统功能带来明显的问题，当你使用公共 Wi-Fi 这种需要使用 portal 验证的网络时，因为网络检查被关闭，系统在访问 portal 验证页面时无法返回正确的值，最终导致无法完成验证和上网。 替换检查网络的网址（可取）： 通过ADB命令，将验证服务的网址替换为国内正常可以访问的网址 Android 5.x ~ 6.x 解决方案adb shell &quot;settings put global captive_portal_server www.v2ex.com&quot; adb shell reboot Android 7.0.0 ~ 7.1.0 解决方案adb shell &quot;settings put global captive_portal_server captive.v2ex.co&quot; adb shell reboot Android 7.1.1 解决方案adb shell &quot;settings put global captive_portal_https_url https://captive.v2ex.co/generate_204&quot; adb shell reboot 源码问题解决了，问题产生的根本源头在哪呢，在源码里面 :) Android 5.x ~ 6.x private int isCaptivePortal() { if (!mIsCaptivePortalCheckEnabled) return 204; HttpURLConnection urlConnection = null; int httpResponseCode = 599; try { URL url = new URL("http", mServer, "/generate_204"); if (DBG) { log("Checking " + url.toString() + " on " + mNetworkAgentInfo.networkInfo.getExtraInfo()); } } // ... } 原来的 mServer 是 clients3.google.com，我们最终将其换为 www.v2ex.com. Android 7.0 ~ 7.1.0private static String getCaptivePortalServerUrl(Context context, boolean isHttps) { String server = Settings.Global.getString(context.getContentResolver(), Settings.Global.CAPTIVE_PORTAL_SERVER); if (server == null) server = DEFAULT_SERVER; return (isHttps ? "https" : "http") + "://" + server + "/generate_204"; } Android 7.0 ~ 7.1.0 新增了https的验证请求，所以我们把 server 的值改为支持https的 captive.v2ex.co. Android 7.1.1private static String getCaptivePortalServerHttpsUrl(Context context) { return getSetting(context, Settings.Global.CAPTIVE_PORTAL_HTTPS_URL, DEFAULT_HTTPS_URL); } DEFAULT_HTTPS_URL 的值由原来的 https://www.google.com/generate_204 替换为 https://captive.v2ex.co/generate_204. 源码链接：5.x ~ 6.x7.0.0 ~ 7.1.07.1.1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[监听Android设备网络变化]]></title>
      <url>post%2F7e2408ee%2F</url>
      <content type="text"><![CDATA[目标在实际开发中，我们不可避免地需要对请求错误进行处理，通常情况下，我们会这样去处理错误请求： 没有网络的情况下，提示用户网络连接不可用，引导用户打开网络或重新刷新等 有网络的情况下，则是客户端或服务端的错误，给用户相应的提示 如果针对第一种情况,我们需要在网络恢复的时候重新刷新数据或进行其他操作,又应该如何实现呢？以下就是我们的目标： 监听Android设备网络状态 在网络状态发生改变时,做出相应操作 在示例中，我们在网络状态发生变化时，显示当前网络变化的类型。 思路在Android系统在网络变化的情况下，会发出 action 为 ConnectivityManager.CONNECTIVITY_ACTION 的系统广播，我们只需要注册 BroadcastReceiver 去监听该广播即可监听设备的网络变化情况。 那么，注册 BroadcastReceiver 是静态注册呢，还是动态注册呢？ 静态注册：通常来讲，退出应用后，该应用仍然能够接收到相应的广播 动态注册：随着所在Context或应用被销毁后，不会收到相应的广播 注意：针对静态注册，这里是用“通常来讲”来修饰的，也就是说，存在特殊情况，即：存在即使使用静态注册，也不会收到相应的广播的情况： Android3.1之后，系统为了加强了安全性控制，应用程序安装后或是(设置)应用管理中被强制关闭后处于stopped状态，在这种状态下接收不到任何广播，除非广播带有 FLAG_INCLUDE_STOPPED_PACKAGES 标志，而默认所有系统广播都是 FLAG_EXCLUDE_STOPPED_PACKAGES 的，所以就没法通过系统广播自启动了。 这其中就包括 ConnectivityManager.CONNECTIVITY_ACTION 。关于这一块的内容，不是本篇重点，欲了解详情，请移步Android应用为何开机自启动、自启动失败原因 另外，Android 7.0 移除了三个隐式广播(Android 7.0 行为变更)，其中就包括 ConnectivityManager.CONNECTIVITY_ACTION , 这意味着通过静态注册 BroadcastReceiver 来监听该广播的方式在 targetSdkVersion &gt;= 24 版本上不再生效，如何解决这一问题请移步 Android 7.0 网络变化监听。 所以，这里采取动态注册 BroadcastReceiver 的方式。那么，应该在哪里动态注册呢？这里有两种思路： 思路1： 定义 BroadcastReceiver 监听网络状态，并提供回调接口 NetStateChangeObserver 用以回调网络状态的变化 抽象出 BaseActivity ，提供注册/取消注册 BroadcastReceiver 的方法，并实现 NetStateChangeObserver 需要监听网络状态的 Activity 调用 BaseActivity 提供的方法即可 思路2： 定义 BroadcastReceiver 监听网络状态，并提供回调接口 NetStateChangeObserver 用以回调网络状态的变化，并在 BroadcastReceiver 中维护 NetStateChangeObserver 列表，当网络发生变化则通知这些 Observer ，实现回调。 在 Application 中注册/取消注册 BroadcastReceiver 抽象 BaseActivity ，提供注册/取消注册 NetStateChangeObserver 观察者的方法， 并实现 NetStateChangeObserver 需要监听网络状态的 Activity 调用 BaseActivity 提供的方法即可 上面的两种思路，比较重要的区别在于，第1中是在 Activity 中注册 BroadcastReceiver , 后者是在 Application 中注册 BroadcastReceiver。前者需要多次注册 BroadcastReceiver 而后者只注册一次，所以在这里选择第2中思路。 实现添加权限&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /> 定义网络类型public enum NetworkType { NETWORK_WIFI("WiFi"), NETWORK_4G("4G"), NETWORK_3G("3G"), NETWORK_2G("2G"), NETWORK_UNKNOWN("Unknown"), NETWORK_NO("No network"); private String desc; NetworkType(String desc) { this.desc = desc; } @Override public String toString() { return desc; } } 定义观察者/** * 网络状态变化观察者 */ public interface NetStateChangeObserver { void onNetDisconnected(); void onNetConnected(NetworkType networkType); } 实现 BroadcastReceiver/** * 监听网络状态变化的BroadcastReceiver */ public class NetStateChangeReceiver extends BroadcastReceiver { private static class InstanceHolder { private static final NetStateChangeReceiver INSTANCE = new NetStateChangeReceiver(); } private List&lt;NetStateChangeObserver> mObservers = new ArrayList&lt;>(); public NetStateChangeReceiver() { } @Override public void onReceive(Context context, Intent intent) { if (ConnectivityManager.CONNECTIVITY_ACTION.equals(intent.getAction())) { NetworkType networkType = NetworkUtils.getNetworkType(context); notifyObservers(networkType); } } /** * 注册网络监听 */ public static void registerReceiver(@NonNull Context context) { IntentFilter intentFilter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION); context.registerReceiver(InstanceHolder.INSTANCE, intentFilter); } /** * 取消网络监听 */ public static void unregisterReceiver(@NonNull Context context) { context.unregisterReceiver(InstanceHolder.INSTANCE); } /** * 注册网络变化Observer */ public static void registerObserver(NetStateChangeObserver observer) { if (observer == null) return; if (!InstanceHolder.INSTANCE.mObservers.contains(observer)) { InstanceHolder.INSTANCE.mObservers.add(observer); } } /** * 取消网络变化Observer的注册 */ public static void unregisterObserver(NetStateChangeObserver observer) { if (observer == null) return; if (InstanceHolder.INSTANCE.mObservers == null) return; InstanceHolder.INSTANCE.mObservers.remove(observer); } /** * 通知所有的Observer网络状态变化 */ private void notifyObservers(NetworkType networkType) { if (networkType == NetworkType.NETWORK_NO) { for(NetStateChangeObserver observer : mObservers) { observer.onNetDisconnected(); } } else { for(NetStateChangeObserver observer : mObservers) { observer.onNetConnected(networkType); } } } } Application 注册 BroadcastReceiverpublic class AppContext extends Application{ @Override public void onCreate() { super.onCreate(); // 注册BroadcastReceiver NetStateChangeReceiver.registerReceiver(this); } @Override public void onTerminate() { super.onTerminate(); // 取消BroadcastReceiver注册 NetStateChangeReceiver.unregisterReceiver(this); } } BaseActivity 抽取public class BaseActivity extends AppCompatActivity implements NetStateChangeObserver { @Override protected void onResume() { super.onResume(); if (needRegisterNetworkChangeObserver()) { NetStateChangeReceiver.registerObserver(this); } } @Override protected void onStop() { super.onStop(); if (needRegisterNetworkChangeObserver()) { NetStateChangeReceiver.unregisterObserver(this); } } /** * 是否需要注册网络变化的Observer,如果不需要监听网络变化,则返回false;否则返回true.默认返回false */ protected boolean needRegisterNetworkChangeObserver() { return false; } @Override public void onNetDisconnected() { } @Override public void onNetConnected(NetworkType networkType) { } } 需要实现网络监听的 Activity 只需要复写 needRegisterNetworkChangeObserver 并返回 true ，并复写相关回调函数即可。 github源码地址:NetDetector]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>post%2F4a17b156%2F</url>
      <content type="text"><![CDATA[Hello World&nbsp;&nbsp;:) Welcome to my blog, have a nice day!&nbsp; ^_^ public class HelloWorld { public static void main(String[] args) { System.out.println("Hello World."); } } Everthing will be okay in the end. If it’s not okay, it’s not the end. 有志者 事竟成 破釜沉舟 百二秦关终属楚苦心人 天不负 卧薪尝胆 三千越甲可吞吴]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[免费ShadowSocks账号]]></title>
      <url>post%2F402cab53%2F</url>
      <content type="text"><![CDATA[免费提供SS账号的网站在这里我列出几个免费提供SS账户的网站： 免费ShadowSocks账号 世界那么大，我想去看看 SS ISS 这里需要注意的是： 以上这些网站提供的ss账号都会不断更新的，所以如果你使用这些免费的服务的话，可能需要及时更新。当然了，如果你是Programmer，你当然可以写脚本去爬取了对吧 :) 如果这些网站访问不了，可能是换网址了 or 被墙了 or 其他不可抗力的原因… 搭建自己的梯子之前是自己在网上找的免费的SS账户，这些免费的SS账户虽然可以提供免费的科学上网服务，但是不是特别稳定。再者，如果你对网络安全性比较在意的话，可能你需要考虑自己搭梯子了。所以，我就自己自己搭建了梯子，我采取的方案是VPS+ShadowSocks，VPS需要自己购买，我用的是搬瓦工的VPS，这里给个链接Mass VPS hosting on Enterprise equipment - Bandwagon Host,按月付的话最便宜的是2.99刀，当然了如果年付的话就更便宜了。当然了，还有其他的VPS提供商供大家选择，由于我没有尝试其他的，就不在这里列出来了。具体搭梯子的教程网上有很多，在这里贴几个： 搭建自己的Shadowsocks服务器 在 Ubuntu 服务器上部署 shadowsocks 科学上网之 Shadowsocks 安装及优化加速 ss优化加速 - 需翻墙如果感觉以上链接不太适合你的话，利用搜索引擎，多找找吧 :) 免费SS账户在这里我把我搭的SS Server的账号提供出来，反正流量比较多，造福下大家咯。当然了，如果它不生效了，恕不通知哈。可能是没再续费了，也可能是换账号了，etc. 服务器地址服务器端口密码加密方式23.106.158.19055501zljw5501aes-256-cfb]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序-快速排序及其优化]]></title>
      <url>post%2F2917269393%2F</url>
      <content type="text"><![CDATA[概念快速排序是交换类排序，采用分治思想，其基本原理是：通过一趟排序，将待排序数组分割成独立的两部分，其中一部分的关键字均比另一部分小；然后再分别对这两部分序列递归进行快速排序，从而使整个序列有序。 具体算法步骤： 在待排序的记录序列中选取一个记录作为枢轴(pivot)； 通过一趟排序，将所有小于枢轴的记录都移到枢轴的左边，将所有大于枢轴的记录都移到枢轴的右边，其实就是将当前待排序序列分为两部分，左边部分的记录均小于右边部分的记录，这样的操作叫做partition(分割)，分割操作结束后，枢轴所处的位置就是最终排序后它所处的位置； 对枢轴左右两边的子序列重复步骤1和2，直至所有子记录序列只剩下一个记录为止。 以上步骤中，关键点是 1. 枢轴(pivot)的选取方式； 2. 对分割操作(partition)的细节处理。 未优化的快速排序 枢轴的选取：将待排序序列的第1个记录作为枢轴； 分割操作 ： 分割操作中使用到了交换； Java实现 // 定义接口 interface Sorter { /** * 将数组按升序排序 */ int[] sort(int[] arr); /** * 交换数组arr中的第i个位置和第j个位置的关键字 */ default void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } // 未优化的快速排序 class QuickSorter implements Sorter { @Override public int[] sort(int[] arr) { quickSort(arr, 0, arr.length - 1); return arr; } /** * 对数组arr[low...high]的子序列作快速排序，使之有序 */ protected void quickSort(int[] arr, int low, int high) { int pivotLoc; // 记录枢轴(pivot)所在位置 if (low &lt; high) { pivotLoc = partition(arr, low, high); // 将arr[low...high]一分为二,并返回枢轴位置 quickSort(arr, low, pivotLoc - 1);// 递归遍历arr[low...pivotLoc-1] quickSort(arr, pivotLoc + 1, high); // 递归遍历arr[pivotLoc+1...high] } } /** * 在arr[low...high]选定pivot=arr[low]作为枢轴（中间位置），将arr[low...high]分成两部分， * 前半部分的子序列的记录均小于pivot，后半部分的记录均大于pivot;最后返回pivot的位置 */ protected int partition(int[] arr, int low, int high) { int pivot; pivot = arr[low]; // 将arr[low]作为枢轴 while (low &lt; high) { // 从数组的两端向中间扫描 // A while (low &lt; high &amp;&amp; arr[high] >= pivot) { // B high--; } swap(arr, low, high); // 将比枢轴pivot小的元素交换到低位 // C while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) { //D low++; } swap(arr, low, high); // 将比枢轴pivot大的元素交换到高位 // E } return low; // 返回一趟下来后枢轴pivot所在的位置 } } 演示为了方便演示，我对上面代码中的分割操作partition方法的代码进行了标注（分别标注为 A,B,C,D,E）。对于待排序序列 {5, 1, 9, 3, 7, 4, 8, 6, 2}，我们来演示其第一趟排序过程： low = 0, high = 8, pivot = arr[low] = 5; A处，low = 0, high = 8, low&lt;high，进行A循环； B处，high的值不断递减，直至arr[high] = 2 小于pivot，跳出B循环：pivot ↓ 5 1 9 3 7 4 8 6 2 ↑ ↑ low high C处，执行low和high的元素交换： pivot ↓ 2 1 9 3 7 4 8 6 5 ↑ ↑ low high D处，low的值不断递增，直至arr[low] = 9 大于 pivot，跳出D循环: pivot ↓ 2 1 9 3 7 4 8 6 5 ↑ ↑ low high E处，执行low和high的元素交换： pivot ↓ 2 1 5 3 7 4 8 6 9 ↑ ↑ low high A处，low =2, high = 8, low &lt; high，继续循环A； B处，high的值不断递减，直至arr[high] = 4 小于pivot，跳出B循环： pivot ↓ 2 1 5 3 7 4 8 6 9 ↑ ↑ low high C处，执行low和high的元素交换： pivot ↓ 2 1 4 3 7 5 8 6 9 ↑ ↑ low high D处，low的值不断递增，直至arr[low] = 7 大于 pivot，跳出D循环： pivot ↓ 2 1 4 3 7 5 8 6 9 ↑ ↑ low high E处，执行low和high的元素交换： pivot ↓ 2 1 4 3 5 7 8 6 9 ↑ ↑ low high A处，low = 4， high = 5， low &lt; high， 继续循环A： B处，high不断递减，直至high=4 等于 low，不满足 low &lt; high，跳出B循环： pivot ↓ 2 1 4 3 5 7 8 6 9 ↑ low high 因为low和high已经重合，所以在接下来的C、D、E操作中序列均未发生变化 A处，low=4, high = 4, 不满足 low &lt; high, 跳出A循环，最后返回low=4，即为pivot所在位置； 所以第1趟排序下来之后，序列会变成 {2, 1, 4, 3, 5, 7, 8, 6, 9}；然后再对子序列{2, 1, 4, 3} 和 {7, 8, 6, 9} 做同样的操作即可完成整个排序。 对于partition方法中的low和high，可以这样理解：在low左边的记录都都小于等于枢轴pivot，在high右边的记录都大于等于枢轴pivot，那么当low和high重合时，则表示已经分割完毕，重合的位置（即low的值）就是枢轴pivot的位置。 快速排序的优化(1) 枢轴的选取方式的优化：枢轴的选取方式有：(1) 固定位置选取；(2) 随机位置选取； (3) 三值取中法 等 固定位置选取：选取当前序列的第一个元素或者最后一个元素作为枢轴，上面的算法的枢轴选取方式即为固定位置选取。该方法不是一个好的选取方案，因为当整个序列有序时，每次分割(partition)操作只会将待排序序列减1，此时为最坏情况，算法复杂度沦为O(n^2)。然而，在待排序的序列中局部有序是相当常见的，所以固定位置选取枢轴不是一种好的选择。 随机位置选取：随机选取当前待排序序列的任意记录作为枢轴。由于采取随机，所以时间性能要强于固定位置选取。 三值取中法： 待排序序列的前(第一个位置)、中(中间位置)、后(最后一个位置)三个记录中的中间值(按大小排序)作为枢轴，比如: 9 1 7 5 2 8 6 3 4 ↑ ↑ ↑ low mid high 前 中 后 由于 9 &gt; 4 &gt; 2； 因此将4作为此次分割(partition)操作的枢轴。三值取中操作后，整个序列变为： 4 1 7 5 2 8 6 3 9 ↑ ↑ ↑ low mid high 前 中 后 三值取中本质上就是随机位置选取，但是由于随机位置选取过程中需要用到随机种子来产生随机数，而三值取中不需要，所以三值取中要优于随机位置选取。 所以优化枢轴的选取方式时，我们选择三值取中的方式。 (2) 优化小数组时的排序方案：当局部排序数组长度较小时，采用插入排序，而非快速排序，因为长度分割到够小后，继续分割的效率要低于直接插入排序。 (3) 略去不必要的交换略去不必要的交换，将交换操作改为替换操作。因为交换操作需要进行3次赋值操作，而替换操作只需要进行1次赋值操作。 Java实现 // 优化的快速排序 class OptimizedQuickSorter extends QuickSorter { /** * 插入排序最大数组长度值 */ private static final int MAX_LENGTH_INSERT_SORT = 7; /** * 对数组arr[low...high]的子序列作快速排序，使之有序 */ @Override protected void quickSort(int[] arr, int low, int high) { int pivotLoc; // 记录枢轴(pivot)所在位置 if ((high - low + 1) > MAX_LENGTH_INSERT_SORT) { // 待排序数组长度大于临界值，则进行快速排序 pivotLoc = partition(arr, low, high); // 将arr[low...high]一分为二,并返回枢轴位置 quickSort(arr, low, pivotLoc - 1);// 递归遍历arr[low...pivotLoc-1] quickSort(arr, pivotLoc + 1, high); // 递归遍历arr[pivotLoc+1...high] } else { // 2. 优化小数组时的排序方案，将快速排序改为插入排序 insertSort(arr, low, high); // 对arr[low...high]子序列进行插入排序 } } /** * 在arr[low...high]中利用三值取中选取枢轴(pivot)，将arr[low...high]分成两部分， * 前半部分的子序列的记录均小于pivot，后半部分的记录均大于pivot;最后返回pivot的位置 */ @Override protected int partition(int[] arr, int low, int high) { int pivot; pivot = medianOfThree(arr, low, high); // 1. 优化排序基准，使用三值取中获取中值 while (low &lt; high) { // 从数组的两端向中间扫描 // A while (low &lt; high &amp;&amp; arr[high] >= pivot) { // B high--; } // swap(arr, low, high); // 将比枢轴pivot小的元素交换到低位 arr[low] = arr[high]; // 3. 优化不必要的交换，使用替换而不是交换 // C while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) { // D low++; } // swap(arr, low, high); // 将比枢轴pivot大的元素交换到高位 arr[high] = arr[low]; // 3. 优化不必要的交换，使用替换而不是交换 // E } arr[low] = pivot; // F return low; // 返回一趟下来后枢轴pivot所在的位置 } /** * 通过三值取中(从arr[low...high]子序列中)获取枢轴pivot的值，让arr[low]变成中值;并返回计算的枢轴(pivot) */ private int medianOfThree(int[] arr, int low, int high) { int mid = low + ((high - low) >> 1); // mid = low + (high-low)/2, 中间元素下标 // 使用三值取中得到枢轴 if (arr[low] > arr[high]) { // 目的：让arr[low] &lt;= arr[high] swap(arr, low, high); } if (arr[mid] > arr[high]) { // 目的：让arr[mid] &lt;= arr[high] swap(arr, mid, high); } if (arr[mid] > arr[low]) { // 目的： 让arr[low] >= arr[mid] swap(arr, low, mid); } // 经过上述变化，最终 arr[mid]&lt;=arr[low]&lt;=arr[high]，则arr[low]为中间值 return arr[low]; } /** * 对子序列arr[low...high]进行插入排序 */ private void insertSort(int[] arr, int low, int high) { int i, j; int tmp; for (i = low + 1; i &lt;= high; i++) { // 从下标low+1开始遍历,因为下标为low的已经排好序 if (arr[i] &lt; arr[i - 1]) { // 如果当前下标对应的记录小于前一位记录,则需要插入,否则不需要插入，直接将记录数增加1 tmp = arr[i]; // 记录下标i对应的元素 for (j = i - 1; j >= low &amp;&amp; arr[j] > tmp; j--) { arr[j + 1] = arr[j]; // 记录后移 } arr[j + 1] = tmp; // 插入正确位置 } } } } 演示为了方便演示，我对上面代码中的分割操作partition方法的代码仍然进行了标注（分别标注为 A,B,C,D,E,F）。对于待排序序列 {5, 1, 9, 3, 7, 4, 8, 6, 2}，我们来演示其第一趟排序过程： low = 0， high = 8， high-low+1=9 &gt; MAX_LENGTH_INSERT_SORT， 所以需要进行快速排序，接下来进行分割(partition)操作； 此时待排序序列：5 1 9 3 7 4 8 6 2 ↑ ↑ low high 三值取中前：5 1 9 3 7 4 8 6 2 ↑ ↑ ↑ low mid high 三值取中后：pivot ↓ 5 1 9 3 2 4 8 6 7 ↑ ↑ ↑ low mid high pivot = 5； A处，low = 0, high = 8, low &lt; high, 进行A循环； B处，high的值不断递减，直至arr[high] = 4 小于pivot，跳出B循环：5 1 9 3 2 4 8 6 7 ↑ ↑ low high C处，arr[low] = arr[high]，将低位的值替换成高位的值：4 1 9 3 2 4 8 6 7 ↑ ↑ low high D处，low的值不断递增，直至arr[low] = 9 大于 pivot，跳出D循环:4 1 9 3 2 4 8 6 7 ↑ ↑ low high E处，arr[high] = arr[low]， 将高位的值替换成低位的值：4 1 9 3 2 9 8 6 7 ↑ ↑ low high A处，low = 2, high = 5, low &lt; high, 进行A循环； B处，high的值不断递减，直至arr[high] = 2 小于pivot，跳出B循环：4 1 9 3 2 9 8 6 7 ↑ ↑ low high C处，arr[low] = arr[high]，将低位的值替换成高位的值：4 1 2 3 2 9 8 6 7 ↑ ↑ low high D处，low的值不断递增，直至low = 4, high = 4, low == high，不满足 low&lt;high，跳出D循环:4 1 2 3 2 9 8 6 7 ↑ low high 因为low和high已经重合，所以在接下来的E操作中序列未发生变化； A处，low=4, high = 4, 不满足 low &lt; high, 跳出A循环； F处， arr[low] = pivot:4 1 2 3 5 9 8 6 7 ↑ low high 最后返回low = 4，即为pivot所在的位置。 所以这趟排序下来之后，序列会变成 {4 1 2 3 5 9 8 6 7}；然后再对子序列{4, 1, 2, 3} 和 {9, 8, 6, 7} 做同样的操作即可完成整个排序。 复杂度时间复杂度：时间复杂度为O(nlogn)，在对快速排序进行各种细节性的优化后，快速排序的性能大大提高，在一般条件下超越了其它排序方法，故得此名。 空间复杂度：就空间复杂度来说，主要是递归造成的栈空间的使用，最好情况，递归的深度为log2n，其空间复杂度也就为O(logn)，最坏情况，需要进行n‐1递归调用，其空间复杂度为O(n)，平均情况，空间复杂度也为O(logn)。 参考链接：常见排序算法 - 快速排序 (Quick Sort)三种快速排序以及快速排序的优化]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序-归并排序]]></title>
      <url>post%2F3453824605%2F</url>
      <content type="text"><![CDATA[概念归并排序就是利用归并的思想实现的排序算法。归并排序的原理：假设初始序列含有n个记录，该序列可以看成n个有序的子序列，其中每个子序列的长度为1，然后两两归并，得到⌈n/2⌉（⌈x⌉表示不小于x的最小整数）个长度为2或者1的子序列，然后再两两归并，……，如此重复直到得到1个长度为n的有序序列为止。 递归式归并演示比如我们待排序的数组是 {9, 1, 5, 8, 3, 7, 4, 6, 2}，那么递归式的归并排序为流程为： [9, 1, 5, 8, 3, 7, 4, 6, 2] ↓ ↓ [9, 1, 5, 8, 3] [7, 4, 6, 2] ↓ ↓ ↓ ↓ [9, 1, 5] [8, 3] [7, 4] [6, 2] ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ [9, 1] [5] [8] [3] [7] [4] [6] [2] ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ [9] [1] [5] [8] [3] [7] [4] [6] [2] // 上面为拆分，下面为归并(合并) ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ [1, 9] [5] [8] [3] [7] [4] [6] [2] ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ [1, 5, 9] [3, 8] [4, 7] [2, 6] ↓ ↓ ↓ ↓ [1, 3, 5, 9, 8] [2, 4, 6, 7] ↓ ↓ [1, 2, 3, 4, 5, 6, 7, 8, 9] Java实现 // 定义接口 interface Sorter { /** * 将数组按升序排序 */ int[] sort(int[] arr); /** * 交换数组arr中的第i个位置和第j个位置的关键字 */ default void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } // 递归式归并排序 class MergeSorter implements Sorter { @Override public int[] sort(int[] arr) { int[] result = new int[arr.length]; mergeSort(arr, result, 0, arr.length - 1); return result; } /** * 将乱序的src[start...end]归并排序为有序的des[start...end] * * @param src * 归并前乱序数组 * @param des * 归并后的有序数组 * @param start * 归并的起始位置 * @param end * 归并的终止位置 */ private void mergeSort(int[] src, int[] des, int start, int end) { if (start == end) { des[start] = src[start]; return; } int[] tmp = new int[src.length]; // 将src[start...end]分为src[start...mid]和src[mid+1...end]两部分 int mid = (start + end) / 2; mergeSort(src, tmp, start, mid); // 递归，将src[start...mid]归并为有序的tmp[start...mid] mergeSort(src, tmp, mid + 1, end); // 递归，将src[mid+1...end]归并为有序的tmp[mid+1...end] // 将有序的tmp[start...mid]和tmp[mid+1...end]合并为des[start...end] merge(tmp, des, start, mid, end); } /** * 将有序的src[start, mid]和有序的src[mid+1, end]合并为有序的des[start,end]; * src可能为乱序数组,但是src[start, mid]和src[mid+1, end]是有序的。 * * @param src * 乱序的原数组 * @param des * 有序的目标数组 * @param start * 数组第一部分起始位置 * @param mid * 数组第一部分结束位置（两部分的分界点） * @param end * 数组第二部分结束位置 */ protected void merge(int[] src, int[] des, int start, int mid, int end) { int i; // src数组第一部分下标 int j; // src数组第二部分下标 int k; // des数组下标 // 将较小的数依次移动到目标数组中 for (i = start, k = start, j = mid + 1; i &lt;= mid &amp;&amp; j &lt;= end;) { if (src[i] &lt; src[j]) { des[k] = src[i++]; } else { des[k] = src[j++]; } k++; } // 将剩余的src[i...mid]复制到des数组中 for (; i &lt;= mid; i++) { des[k] = src[i]; k++; } // 将剩余的src[j...end]复制到des数组中 for (; j &lt;= end; j++) { des[k] = src[j]; k++; } } } 复杂度时间复杂度：因为归并的递归操作其实就是二叉树的结构，故而，最好情况 = 最坏情况 = 平均情况 = O(nlogn) 空间复杂度：因为递归式归并需要(1)与原始记录相同大小的空间来存放归并的结果以及(2)深度为logn的栈空间，所以空间复杂度为O(n+logn) 非递归式归并演示又比如我们待排序的数组是 {9, 1, 5, 8, 3, 7, 4, 6, 2}，那么非递归式的归并排序为流程为： [9] [1] [5] [8] [3] [7] [4] [6] [2] ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ [1, 9] [5, 8] [3, 7] [4, 6] [2] ↓ ↓ ↓ ↓ ↓ [1, 5, 8, 9] [3, 4, 6, 7] [2] ↓ ↓ ↓ [1, 3, 4, 5, 6, 7, 8, 9] [2] ↓ ↓ [1, 2, 3, 4, 5, 6, 7, 8, 9] Java实现 // 非递归式归并排序 class NonRecursiveMergeSorter extends MergeSorter { @Override public int[] sort(int[] arr) { mergeSort(arr); return arr; } private void mergeSort(int[] arr) { int len = arr.length; int result[] = new int[len]; int k = 1; while (k &lt; len) { mergePass(arr, result, k); // arr归并至result,此时间隔为k k = 2 * k; // 子序列长度加倍 mergePass(result, arr, k); // result归并至arr,此时间隔翻倍 k = 2 * k; // 子序列长度加倍 } } /** * 将数组src中相邻长度为interval的子序列两两归并到des数组中 * * @param src * 源数组 * @param des * 目标数组 * @param interval * 两两合并的子序列长度 */ private void mergePass(int[] src, int[] des, int interval) { int i = 0; int len = src.length; while (i + 2 * interval - 1 &lt; len) { // 两两合并 merge(src, des, i, i + interval - 1, i + 2 * interval - 1); i = i + 2 * interval; } if (i + interval - 1 &lt; len - 1) { // i+interval-1小于len-1，说明最后还剩余两个子序列，只不过最后的一个子序列长度不够interval // 那么将剩下的两个子序列进行合并 merge(src, des, i, i + interval - 1, len - 1); } else { // 否则，最后只剩下单个子序列，则直接将该子序列加入到des尾部 for (; i &lt; len; i++) { des[i] = src[i]; } } } } 复杂度时间复杂度：同递归式归并，最好情况 = 最坏情况 = 平均情况 = O(nlogn) 空间复杂度：非递归式归并不需要保存方法栈信息，所以空间复杂度为O(n) 所以非递归的递归算法性能要高于递归式归并算法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序-堆排序]]></title>
      <url>post%2F716497058%2F</url>
      <content type="text"><![CDATA[概念堆： 堆是具有下列性质的完全二叉树：每个节点的值都大于或等于其左右孩子（如果存在的话）的值，称为最大堆；或者每个节点的值都小于或等于其左右孩子（如果存在的话）的值，称为最小堆。 完全二叉树： complete binary tree最大堆：max heap 最小堆：min heap图片来源: 常见排序算法 - 堆排序 (Heap Sort) 堆排序：利用堆（这里使用最大堆）进行排序的方法。其基本思想是：将待排序的序列构造成一个最大堆，此时待排序序列的最大值就是堆顶的根节点，将其移走（其实就是将其与待排序序列的最后一个元素进行交换，此时待排序序列最后一个元素就是最大值），然后将剩余的序列重新构造成一个堆，如此反复，直到待排序序列只有一个元素为止，则排序完成。 性质已知arr[0…n-1]是长度为n的最大堆数组，下标从0开始，那么对于下标为i的节点I，有：(1). 如果I的左孩子存在的话，那么I的左孩子节点的下标为 left(i) = 2*i+1；(2). 如果I的右孩子存在的话，那么I的右孩子节点的下标为 right(i) = 2*i+2;(3). 如果I双亲节点存在的话，那么I的双亲节点的下标为 parent(i) = (i-1)/2; (向下取整) 基本操作 构建最大堆 buildMaxHeap(int[] arr)：将待排序序列arr构建成最大堆； 调整最大堆 adjustHeap(int arr[], int begin, int end): 已知arr[begin]的左子树和右子树都满足最大堆，那么调节节点arr[begin]，将以arr[begin]为根节点的二叉树调整为最大堆。 对于堆排序，最重要的就是构建最大堆和调整最大堆，其实构造初始堆事实上也是调整堆的过程，只不过构造初始堆是对所有的非叶节点都进行调整。 Java实现// 定义接口 interface Sorter { /** * 将数组按升序排序 */ int[] sort(int[] arr); /** * 交换数组arr中的第i个位置和第j个位置的关键字 */ default void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } // 堆排序 class HeapSorter implements Sorter { @Override public int[] sort(int[] arr) { heapSort(arr); return arr; } private void heapSort(int[] arr) { buildMaxHeap(arr); // 构建最大堆 // 将最大堆堆顶元素与数组末尾元素交换，并将前n-1序列重新构造成最大堆,重复n-1次 for (int i = arr.length - 1; i >= 1; i--) { swap(arr, 0, i); // 将堆顶元素和当前未经排序的子序列的最后一个元素进行交换 adjustHeap(arr, 0, i - 1); // 将arr[0...i-1](前i个元素)重新调整为最大堆 } } /** * 将指定数组arr构建成最大堆 */ private void buildMaxHeap(int[] arr) { int len = arr.length; // 从最后一个非叶子节点往前遍历，将当前序列构成最大堆 for (int i = len / 2 - 1; i >= 0; i--) { adjustHeap(arr, i, len - 1); } } /** * 假定arr[begin]的左子树和右子树均满足最大堆，那么调节节点arr[begin]，将以arr[begin]为根节点的二叉树调整为最大堆。 */ private void adjustHeap(int[] arr, int begin, int end) { int tmp = arr[begin]; int j; for (j = 2 * begin + 1; j &lt;= end; j = 2 * j + 1) { // j=2*begin+1表示j对应二叉树节点的左孩子 if (j + 1 &lt;= end &amp;&amp; arr[j] &lt; arr[j + 1]) { // 如果当前节点的右孩子存在且左孩子的值小于右孩子 j++; // j为左右孩子较大记录的下标 } if (tmp >= arr[j]) // tmp的值已经大于arr[j]，则调整完毕，跳出循环 break; arr[begin] = arr[j]; // 当前根节点并未均大于左右节点(如果有的话)，重新给当前根节点赋值 begin = j; // begin指向新的可能需要进行最大堆调整的子树的根节点 } arr[begin] = tmp; } } 堆排序其实也是一种选择排序，是一种树形选择排序。在简单选择排序中，从arr[0…n-1]中选择最小（或最大）记录，需要比较n-1次，然后再从剩下arr[1…n-1]的n-1个元素中选择最小（或最大）记录，需要比较n-2次。然而事实上这n-2次比较中，有许多已经在前一趟n-1次的比较中做过了；而树形选择排序恰好利用树形的特点保存了部分前面的比较结果，因此可以减少比较次数，提高算法效率。 复杂度时间复杂度：对于n个关键字序列，每个节点需比较log2(n)次，因此其时间复杂度为O(nlogn)。由于堆排序对原始记录的排序状态并不敏感，所以它的最好、最坏、平均时间复杂度均为O(nlogn)由于初始构建堆所需要的比较次数较多，所以堆排序不适合待排序序列个数少的情况。 空间复杂度：最好情况=平均情况=最坏情况=O(1) 参考链接推排序常见排序算法 - 堆排序 (Heap Sort)堆排序(Heap Sort)算法学习]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序-希尔排序]]></title>
      <url>post%2F3263168730%2F</url>
      <content type="text"><![CDATA[概念希尔排序是插入类排序算法，它的本质就是分组插入排序，它采取分割策略：将相距某个“增量”的记录组成一个子序列，保证在每个子序列内部分别进行插入排序后得到的结果是基本有序。 该方法的基本思想是：先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。 因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比插入排序有大幅度提高。 Java实现// 定义接口 interface Sorter { /** * 将数组按升序排序 */ int[] sort(int[] arr); /** * 交换数组arr中的第i个位置和第j个位置的关键字 */ default void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } //希尔排序 public class ShellSorter implements Sorter { @Override public int[] sort(int[] arr) { shellSort(arr); return arr; } // Shell排序的关键就是增量序列的选取： // 增量序列原则： 增量序列的最后一个增量必须等于1 private void shellSort(int[] arr) { int len = arr.length; int increment = len; for (; increment != 1;) {// 循环直至increment=1 increment = increment / 3 + 1; // 计算增量序列(将整个序列分成increment组,在组内进行插入排序) for (int i = increment; i &lt; len; i++) { if (arr[i] &lt; arr[i - increment]) { int tmp = arr[i]; // 暂存arr[i]的值 int j; for (j = i - increment; j >= 0 &amp;&amp; tmp &lt; arr[j]; j -= increment) { // 组内记录后移,查找插入位置 arr[j + increment] = arr[j]; } // 找到插入位置 arr[j + increment] = tmp; } } } } } 演示比如我们待排序的数组是 {9, 1, 5, 8, 3, 7, 4, 6, 2}初始时increment=arr.length=9，increment != 1，执行第1次循环：increment = 9/3+1 = 4，将整个序列分成4组，组内进行插入排序： 第 1 组： 9 3 2 -----------&gt; 2 3 9 第 2 组： 1 7 -----------&gt; 1 7 第 3 组： 5 4 -----------&gt; 4 5 第 4 组： 8 6 -----------&gt; 6 8 此时序列为 2 1 4 6 3 7 5 8 9 increment=4，increment != 1，执行第2次循环：increment = 4/3+1 = 2，将整个序列分成2组，组内进行插入排序： 第 1 组： 2 4 3 5 9 -----------&gt; 2 3 4 5 9 第 2 组： 1 6 7 8 -----------&gt; 1 6 7 8 此时序列为 2 1 3 6 4 7 5 8 9 increment=2，increment != 1，执行第3次循环：increment = 2/3+1 = 1，将整个序列分成1组，组内进行插入排序（演变为直接插入排序）： 第 1 组 ： 2 1 3 6 4 7 5 8 9 -----------&gt; 1 2 3 4 5 6 7 8 9 increment=1，结束循环，排序完毕。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序-插入排序]]></title>
      <url>post%2F1309789713%2F</url>
      <content type="text"><![CDATA[概念插入排序是插入类的排序算法，基本原理：将一个记录插入到已经排好序的有序表中，从而得到一个新的记录数增加1的有序表。 具体算法：整个序列分为两部分，左边部分为已排序的子序列，右边部分为未排序的子序列，取出第1个未排序元素存放在临时变量tmp中，在已经排序的元素序列中从后往前遍历，逐一比较，如果遍历到的元素大于tmp，则将该元素替换下一个位置的元素，直至遍历到的元素小于或等于tmp为止。相当于将未排序的第一个元素插入到已排序的数组中，故以插入排序为名。 演示比如我们待排序的数组是 {0, 5, 3, 4, 6, 2}第1趟排序，5大于0，无需插入： 0 5 3 4 6 2第2趟排序，3小于5，需要插入： 0 3 5 4 6 2第3趟排序，4小于5，需要插入： 0 3 4 5 6 2第4趟排序，6大于5，无需插入： 0 3 4 5 6 2第5趟排序，2小于6，需要插入： 0 2 3 4 5 6 Java实现// 定义接口 interface Sorter { /** * 将数组按升序排序 */ int[] sort(int[] arr); /** * 交换数组arr中的第i个位置和第j个位置的关键字 */ default void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } //插入排序 class InsertSorter implements Sorter { @Override public int[] sort(int[] arr) { insertSort(arr); return arr; } private void insertSort(int[] arr) { int len = arr.length; int i, j; int tmp; for (i = 1; i &lt; len; i++) { // 从下标1开始遍历,因为下标0的已经排好序 if (arr[i] &lt; arr[i - 1]) { // 如果当前下标对应的记录小于前一位记录,则需要插入,否则不需要插入，直接将记录数增加1 tmp = arr[i]; // 记录下标i对应的元素 for (j = i - 1; j >= 0 &amp;&amp; arr[j] > tmp; j--) { arr[j + 1] = arr[j]; // 记录后移 } arr[j + 1] = tmp; // 插入正确位置 } } } } 复杂度时间复杂度：最好情况：当待排序的序列为顺序表时，会进行n-1次比较，0次替换，复杂度为O(n)；最坏情况：当待排序的序列为逆序表时，会进行2+3+…+n=(n+2)*(n-1)/2次比较，2+3+…+n = (n+2)*(n-1)/2次替换，复杂度为O(n^2)；平均情况：平均比较次数约为n^2/2, 平均移动次数为n^2/2，复杂度为O(n^2)。 空间复杂度：最好情况=最坏情况=平均情况=O(1)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序-选择排序]]></title>
      <url>post%2F2610207546%2F</url>
      <content type="text"><![CDATA[概念简单选择排序是选择类的排序，算法原理：第i次排序（1≤ i ≤n-1），从待排序的n-i+1个记录中， 进行n-i次关键字比较，从n-i+1个记录中选出最小的，并和第i-1个记录进行交换。 演示比如我们待排序的数组是 {9, 1, 5, 8, 3, 7, 4, 6, 2}第1趟排序，1最小，与第0个位置9进行交换： 1 9 5 8 3 7 4 6 2第2趟排序，2最小，与第1个位置9进行交换： 1 2 5 8 3 7 4 6 9第3趟排序，3最小，与第2个位置5进行交换： 1 2 3 8 5 7 4 6 9第4趟排序，4最小，与第3个位置8进行交换： 1 2 3 4 5 7 8 6 9第5趟排序，5最小，第4个位置是5无须交换： 1 2 3 4 5 7 8 6 9第6趟排序，6最小，与第5个位置7进行交换： 1 2 3 4 5 6 8 7 9第7趟排序，7最小，与第6个位置8进行交换： 1 2 3 4 5 6 7 8 9第8趟排序，8最小，第7个位置是8无须交换： 1 2 3 4 5 6 7 8 9 其实就是每一趟排序将当前未排序序列中的最小的记录与未排序序列的最前端的位置进行交换。 Java实现// 定义接口 interface Sorter { /** * 将数组按升序排序 */ int[] sort(int[] arr); /** * 交换数组arr中的第i个位置和第j个位置的关键字 */ default void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } //选择排序 class SelectionSorter implements Sorter { @Override public int[] sort(int[] arr) { selectSort(arr); return arr; } private void selectSort(int[] arr) { int i, j, min; int len = arr.length; for (i = 0; i &lt; len - 1; i++) { min = i; // min记录最小值的下标 for (j = i + 1; j &lt; len; j++) { // 循环i之后的数据 if (arr[j] &lt; arr[min]) // 发现有小于当前最小值的关键字 min = j; // 将该下标赋值给min } if (i != min) // 如果i和min不等，在i之后的数据中找到了最小值，则需要arr[i]于arr[min]进行交换 swap(arr, i, min); } } } 复杂度时间复杂度：对于比较次数而言，无论最好最差情况，其比较次数都是一样的：第i趟排序需要进行n-i次比较，此时比较次数=(n-1)+(n-2)+…+1 = n*(n-1)/2；对于交换次数而言，其最好情况为顺序表，交换次数为0次；最差情况为逆序表，交换次数为n-1次，那么平均情况则为(n-1)/2次交换；由于时间复杂度取决于比较次数和交换次数总和，故而交换排序的时间复杂度为O(n^2)。因为相较于冒泡排序，选择排序的交换次数要少，所以选择排序的性能要优于冒泡排序。 空间复杂度：最好情况=最坏情况=平均情况=O(1)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java-IPv4地址和int类型数字的互相转换]]></title>
      <url>post%2F1779625018%2F</url>
      <content type="text"><![CDATA[问题分析对于ipv4的地址来说，如果用字符串的形式存储的话，其占用字节就比较大，比如对于IPv4地址0.0.0.0的字符串，就需要7个字节，IPv4为255.255.255.255 的字符串，需要15个字节，也就是说存储一个ip需要占用7~15个字节。 那么有没有更节省空间的存储方式呢？答案是有。 方案1： 直接把字符串中的’.’去掉，不就变成一个数字了嘛，比如 “255.255.255.255” 变成 255255255255，然而我们知道int所能表示的最大值 = Integer.MAX_VALUE = 2^31-1 = 2147483647， 255255255255 &gt; 2^31-1，所以需要用长整形long来表示，长整形占用8个字节，也就是说我们将7~15个字节转换为8字节，在绝大多数情况下是节省空间了的。 方案2： 因为考虑到IPv4的地址本质上就是32位的二进制串，而一个int类型的数字刚好为4个字节32个bit位，所以刚好可以用一个int类型的数字转表示IPv4地址。所以，我们可以用4个字节的int数字表示一个ip地址，这样可以大大节省空间。 这里只讨论方案2 :) 演示对于ipv4地址： 192.168.1.3：每段都用二进制表示： 192(10) = 11000000(2) ; 168(10) = 10101000(2) ; 1(10) = 00000001(2) ; 3(10) = 00000011(2) 。所以连在一起就是：11000000101010000000000100000011，对应的int数字就是-1062731775 。 具体算法分析：192左移24位： 11000000 00000000 00000000 00000000168左移16位： 00000000 10101000 00000000 00000000001左移08位： 00000000 00000000 00000001 00000000003左移00位： 00000000 00000000 00000000 00000011按位或的结果： 11000000 10101000 00000001 00000011即 -1062731775 将int类型的数字转换成ip地址，其实就是上述过程的逆过程，这里就不再赘述。 Java实现/** * IPv4地址和int数字的互相转换 * * @author Tianma * */ public class IPv4IntTransformer { /** * IPv4地址转换为int类型数字 * */ public static int ip2Integer(String ipv4Addr) { // 判断是否是ip格式的 if (!isIPv4Address(ipv4Addr)) throw new RuntimeException("Invalid ip address"); // 匹配数字 Pattern pattern = Pattern.compile("\\d+"); Matcher matcher = pattern.matcher(ipv4Addr); int result = 0; int counter = 0; while (matcher.find()) { int value = Integer.parseInt(matcher.group()); result = (value &lt;&lt; 8 * (3 - counter++)) | result; } return result; } /** * 判断是否为ipv4地址 * */ private static boolean isIPv4Address(String ipv4Addr) { String lower = "(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])"; // 0-255的数字 String regex = lower + "(\\." + lower + "){3}"; Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(ipv4Addr); return matcher.matches(); } /** * 将int数字转换成ipv4地址 * */ public static String integer2Ip(int ip) { StringBuilder sb = new StringBuilder(); int num = 0; boolean needPoint = false; // 是否需要加入'.' for (int i = 0; i &lt; 4; i++) { if (needPoint) { sb.append('.'); } needPoint = true; int offset = 8 * (3 - i); num = (ip >> offset) &amp; 0xff; sb.append(num); } return sb.toString(); } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序-冒泡排序及其优化]]></title>
      <url>post%2F42083511%2F</url>
      <content type="text"><![CDATA[概念冒泡排序是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直至没有反序的记录为止。因为按照该算法，每次比较会将当前未排序的记录序列中最小的关键字移至未排序的记录序列最前（或者将当前未排序的记录序列中最大的关键字移至未排序的记录序列最后），就像冒泡一样，故以此为名。 演示比如我们待排序的数组是 {9, 1, 5, 8, 3, 7, 4, 6, 2}第1趟排序：第1次比较，2和6比较，2小于6，反序，进行交换： 9 1 5 8 3 7 4 2 6第2次比较，2和4比较，2小于4，反序，进行交换： 9 1 5 8 3 7 2 4 6第3次比较，2和7比较，2小于7，反序，进行交换： 9 1 5 8 3 2 7 4 6第4次比较，2和3比较，2小于3，反序，进行交换： 9 1 5 8 2 3 7 4 6第5次比较，2和8比较，2小于8，反序，进行交换： 9 1 5 2 8 3 7 4 6第6次比较，2和5比较，2小于5，反序，进行交换： 9 1 2 5 8 3 7 4 6第7次比较，2和1比较，2大于1，正序，不用交换： 9 1 2 5 8 3 7 4 6第8次比较，1和9比较，1小于1，反序，进行交换： 1 9 2 5 8 3 7 4 6可以看出，第一趟排序将当前序列最小值移动至未排序的序列最前面的位置。 第2趟排序： 因为第一趟已经排好1的位置，所以只需要对剩下的{9, 2, 5, 8, 3, 7, 4, 6}再进行冒泡排序… 重复以上操作，直至排序完毕 Java实现// 定义接口 interface Sorter { /** * 将数组按升序排序 */ int[] sort(int[] arr); /** * 交换数组arr中的第i个位置和第j个位置的关键字 */ default void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } // 冒泡排序 class BubbleSorter implements Sorter { @Override public int[] sort(int[] arr) { bubbleSort(arr); return arr; } private void bubbleSort(int[] arr) { int i, j; int len = arr.length; for (i = 0; i &lt; len - 1; i++) { for (j = len - 1; j > i; j--) { if (arr[j - 1] > arr[j]) { swap(arr, j - 1, j); } } } } } 优化当待排序数组为{1, 3, 4, 5, 6, 7, 8, 9, 2}时：第1趟排序的结果为： 1 2 3 4 5 6 7 8 9此时其实序列已经完成，但是根据上述代码仍得继续遍历，直至第9趟排序。这显然是不合理的，如果我们能在代码中加入一个flag标记上一趟排序中是否进行过交换，如果进行过未进行交换，说明当前数组以及有序。优化代码： // 优化的冒泡排序 class OptimizedBubbleSorter extends BubbleSorter { @Override protected void bubbleSort(int[] arr) { int i, j; int len = arr.length; boolean swapped = true; // 标记：上一趟循环是否进行过交换 for (i = 0; i &lt; len - 1 &amp;&amp; swapped; i++) { swapped = false; // 在某一趟遍历中,如果没有可交换的,那么swapped = false,跳出外层循环; // 如果一旦进行了交换,则swapped = true,需要进行下一趟遍历 for (j = len - 1; j > i; j--) { if (arr[j - 1] > arr[j]) { swap(arr, j - 1, j); swapped = true; } } } } } 复杂度时间复杂度：最好情况： 排序表本身是顺序的，根据优化后的代码，则只需要进行n-1次比较，故时间复杂度为O(n)；最差情况： 排序表本身是逆序的，则比较次数为 1+2+…+(n-1) = n*(n-1)/2 , 并作等数量级的移动操作；平均情况： 时间复杂度为 O(n^2) 空间复杂度：最好情况=最坏情况=平均情况=O(1)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[查找-二叉搜索树（Java实现）]]></title>
      <url>post%2F1367710076%2F</url>
      <content type="text"><![CDATA[前言如果查找的数据集是有序的线性表，并且是顺序存储的，查找可以用折半查找、插值查找、斐波那契查找算法（详细算法见：有序表查找（折半、插值、斐波那契查找））等实现。但是正是因为他们是顺序的，所以在插入和删除操作中需要耗费大量时间，也就是说这些算法适合静态查找（只有查找操作），不适合动态查找（不仅有查找操作还有插入删除等操作）。而二叉搜索树正适合动态查找。 定义二叉搜索树又称为二叉排序树，它或者是空树，或者是具有下列性质的二叉树： 如果它的左子树不为空，那么左子树的所有节点都小于根节点的值； 如果它的右子树不为空，那么右子树的所有节点都大于根节点的； 它的左、右子树也分别是二叉搜索树. 二叉树是递归定义的数据结构，其中序遍历是递增的有序序列。 操作1. 插入插入节点的过程是：若原二叉查找树为空，则直接插入；否则，若关键字 k 小于根节点关键字，则插入到左子树中，若关键字 k 大于根节点关键字，则插入到右子树中。注意每次插入的节点必是叶节点。 2. 删除二叉查找树的删除操作是相对复杂一点，它要按 3 种情况来处理： 若被删除节点 t 是叶子节点，则直接删除，不会破坏二叉排序树的性质； 若节点 t 只有左子树或只有右子树，则让 t 的子树成为 t 父节点的子树，替代 t 的位置； 若节点 t 既有左子树，又有右子树，则用 t 的直接前驱或者直接后继代替 t，然后从二叉查找树中删除这个后继，这样就转换成了第一或第二种情况。 3. 查找查找是从根节点开始，若二叉树非空，将给定值与根节点的关键字比较，若相等，则查找成功；若不等，则当给定值小于根节点关键字时，在根节点的左子树中查找，否则在根节点的右子树中查找。其查找平均时间复杂度为O(logn)，但是最差情况为插入的节点是有序的，则该二叉搜索树会变成左斜树(或者右斜树或者可以理解为“链表”)，即最差时间复杂度为O(n)，故而查找性能不是严格意义上的O(logn)，不稳定。 Java实现public class SortedBinaryTree&lt;E> { private Node&lt;E> root; // 根节点 private int size; // 二叉树元素个数 /** * 二叉树节点 */ private static class Node&lt;E> { E element; // 节点元素 Node&lt;E> lChild; // 左孩子 Node&lt;E> rChild; // 右孩子 public Node(E element) { this(element, null, null); } public Node(E element, Node&lt;E> lChild, Node&lt;E> rChild) { this.element = element; this.lChild = lChild; this.rChild = rChild; } } public SortedBinaryTree(List&lt;E> elements) { for (E e : elements) { add(e); } } public SortedBinaryTree(E[] elements) { for (E e : elements) { add(e); } } public SortedBinaryTree() { } /** * 判断当前元素是否存在于树中 * * @param element * @return */ public boolean contains(E element) { return search(root, element); } /** * 递归搜索,查找当前以curRoot为根节点的树中element存在与否 * * @param curRoot * @param element * @return */ @SuppressWarnings("unchecked") private boolean search(Node&lt;E> curRoot, E element) { if (curRoot == null) return false; Comparable&lt;? super E> e = (Comparable&lt;? super E>) element; int cmp = e.compareTo(curRoot.element); if (cmp > 0) { // 查找的元素大于当前根节点对应的元素,向右走 return search(curRoot.rChild, element); } else if (cmp &lt; 0) { // 查找的元素小于当前根节点对应的元素,向左走 return search(curRoot.lChild, element); } else { // 查找的元素等于当前根节点对应的元素,返回true return true; } } /** * 非递归搜索,查找当前以curRoot为根节点的树中的element是否存在 * * @param curRoot * 二叉排序树的根节点 * @param element * 被搜索的元素 * @param target * target[0]指向查找路径上最后一个节点: 如果当前查找的元素存在,则target[0]指向该节点 * @return */ @SuppressWarnings("unchecked") private boolean find(Node&lt;E> curRoot, E element, Node&lt;E>[] target) { if (curRoot == null) return false; Node&lt;E> tmp = curRoot; Comparable&lt;? super E> e = (Comparable&lt;? super E>) element; while (tmp != null) { int cmp = e.compareTo(tmp.element); target[0] = tmp; if (cmp > 0) { // 查找的元素大于当前节点对应的元素,向右走 tmp = tmp.rChild; } else if (cmp &lt; 0) { // 查找的元素小于当前节点对应的元素,向左走 tmp = tmp.lChild; } else { // 查找的元素等于当前根节点对应的元素,返回true return true; } } return false; } /** * 向二叉排序树中添加元素,如果当前元素已经存在,则添加失败,返回false,如果当前元素不存在,则添加成功,返回true * */ @SuppressWarnings("unchecked") public boolean add(E element) { if (root == null) { root = new Node&lt;E>(element); size++; return true; } Node&lt;E>[] target = new Node[1]; if (!find(root, element, target)) { // 当前元素不存在,插入元素 // 此时target节点即为需要插入的节点的父节点 Comparable&lt;? super E> e = (Comparable&lt;? super E>) element; int cmp = e.compareTo(target[0].element); Node&lt;E> newNode = new Node&lt;E>(element); if (cmp > 0) { // 插入的元素大于target指向的节点元素 target[0].rChild = newNode; } else { // 插入的元素小于target指向的节点元素 target[0].lChild = newNode; } size++; return true; } return false; } /** * 删除二叉排序树中的元素,如果当前元素不存在,则删除失败,返回false;如果当前元素存在,则删除该元素,重构二叉树,返回true * * @param element * @return */ @SuppressWarnings("unchecked") public boolean remove(E element) { Node&lt;E>[] target = new Node[1]; if (find(root, element, target)) { // 被删除的元素存在,则继续执行删除操作 remove(target[0]); return true; } return false; } /** * 释放当前节点 * * @param node */ private void free(Node&lt;E> node) { node.element = null; node.lChild = null; node.rChild = null; node = null; } /** * 删除二叉排序树中指定的节点 * * @param node */ private void remove(Node&lt;E> node) { Node&lt;E> tmp; if (node.lChild == null &amp;&amp; node.rChild == null) { // 当前node为叶子节点,删除当前节点,则node = null; node = null; } else if (node.lChild == null &amp;&amp; node.rChild != null) { // 如果被删除的节点左子树为空,则只需要重新连接其右子树 tmp = node; node = node.rChild; free(tmp); } else if (node.lChild != null &amp;&amp; node.rChild == null) { // 如果被删除的节点右子树为空,则只需要重新连接其左子树 tmp = node; node = node.lChild; free(tmp); } else { // 当前被删除的节点左右子树均存在,不为空 // 找到离当前node节点对应元素且最近的节点target(左子树的最右边节点 或者 右子树最左边节点) // 将node节点元素替换成target节点的元素,将target节点删除 tmp = node; // tmp是target的父节点 Node&lt;E> target = node.lChild; // 找到左子树最大子树 while (target.rChild != null) { // 在左子树中进行右拐 tmp = target; target = target.rChild; } node.element = target.element; // node.element元素替换为target.element if (tmp == node) { // tmp == node 说明没有在左子树中进行右拐,也就是node节点的左孩子没有右孩子, // 需要重新连接tmp节点左孩子 tmp.lChild = target.lChild; } else { // tmp != node, 进行了右拐,那么将重新连接tmp的右子树,将target.lChild赋值给tmp.rChild tmp.rChild = target.lChild; } // 释放节点 free(target); } // 删除成功,size--; size--; } public int size() { return size; } public boolean isEmpty() { return size() == 0; } public List&lt;E> preOrderTraverse() { List&lt;E> list = new ArrayList&lt;E>(); preOrderTraverse(root, list); return list; } private void preOrderTraverse(Node&lt;E> curRoot, List&lt;E> list) { if (curRoot == null) return; E e = curRoot.element; list.add(e); preOrderTraverse(curRoot.lChild, list); preOrderTraverse(curRoot.rChild, list); } public List&lt;E> inOrderTraverse() { List&lt;E> list = new ArrayList&lt;E>(); inOrderTraverse(root, list); return list; } private void inOrderTraverse(Node&lt;E> curRoot, List&lt;E> list) { if (curRoot == null) return; inOrderTraverse(curRoot.lChild, list); list.add(curRoot.element); inOrderTraverse(curRoot.rChild, list); } public List&lt;E> postOrderTraverse() { List&lt;E> list = new ArrayList&lt;E>(); postOrderTraverse(root, list); return list; } private void postOrderTraverse(Node&lt;E> curRoot, List&lt;E> list) { if (curRoot == null) return; inOrderTraverse(curRoot.lChild, list); inOrderTraverse(curRoot.rChild, list); list.add(curRoot.element); } /** * 返回中序遍历结果 */ @Override public String toString() { return inOrderTraverse().toString(); } public static void main(String[] args) { Integer[] elements = new Integer[] { 62, 88, 58, 47, 73, 99, 35, 51, 93, 29, 37, 49, 56, 36, 48, 50 }; SortedBinaryTree&lt;Integer> tree = new SortedBinaryTree&lt;Integer>(elements); System.out.println(tree); System.out.println(tree.contains(93)); System.out.println(tree.size()); System.out.println(tree.remove(47)); System.out.println(tree.preOrderTraverse()); System.out.println(tree.size()); } } Github地址SortedBinaryTree]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[查找-有序表查找(折半查找，插值查找，斐波拉契查找)]]></title>
      <url>post%2F243331195%2F</url>
      <content type="text"><![CDATA[引言如果待查找的数组是有序的，那么此时的查找就是有序表查找，这对于查找的帮助是很大的。属于有序表查找的有：折半查找（二分查找）、插值查找以及斐波那契查找。 1. 折半查找折半查找又称为二分查找，是一种效率较高的查找算法。折半查找的先决条件是查找表中的数据元素排列必须是有序的。折半查找先以有序数列的中点位置为比较对象，如果要找的元素值小于中点位置元素，则将待查序列缩小为左半部分，否则为右半部分。通过一次比较，可以将查找的区间缩小一半，每次比较，都可以将当前查找范围缩小至一般，可以明显的减少比较的次数，提高查找效率。时间复杂度：O(logn)算法实现： // 定义接口 interface Searcher { /** * 从数组array中查找关键字key,如果存在则返回该关键字在数组中任意出现的位置(不局限于首次或者末次之类的),否则返回-1 */ int search(int[] array, int key); } /** * 二分法查找,时间复杂度O(logn) */ class BinarySearcher implements Searcher { // 二分法查找前提,查找表array是顺序(这里要求递增)排列的 @Override public int search(int[] array, int key) { int low, high, mid; low = 0; // 定义最低下标为array首位 high = array.length - 1; // 定义最高下标为array末位 while (low &lt;= high) { mid = (low + high) / 2; // 折半 if (array[mid] > key) { // 中值比key大,则high=mid-1 high = mid - 1; } else if (array[mid] &lt; key) { // 中值比key小,则low=mid+1 low = mid + 1; } else { // 相等说明mid即为key在array中所在位置 return mid; } } return -1; } } 2. 插值查找插值查找是二分查找演化而来，相比于二分查找(折半),该算法考虑的是每次折的时候折多少,即不一定是1/2;如在一本字典中找”abstract”这个单词,我们自己来操作肯定是先翻到字典开始的那一小部分,而不是从字典的中间开始进行折半查找。 在二分查找中mid=(low+high)/2=low+1/2*(high-low),插值查找就是对1/2(系数,或者说比例)进行改变，它将1/2变成 (key - array[low])/(array[high] - array[low]),其实就是计算线性比例。 时间复杂度：O(logn)因为插值查找是依赖线性比例的，如果当前数组分布不是均匀的，那么该算法就不合适。 算法实现： class InterpolateSearcher implements Searcher { @Override public int search(int[] array, int key) { int low, high, mid; low = 0; // 定义最低下标为array首位 high = array.length - 1; // 定义最高下标为array末位 while (low &lt;= high) { // 相比二分法查找的更改处 mid = low + (int) (1.0 * (key - array[low]) / (array[high] - array[low]) * (high - low)); if (array[mid] > key) { // 中值比key大,则high=mid-1 high = mid - 1; } else if (array[mid] &lt; key) { // 中值比key小,则low=mid+1 low = mid + 1; } else { // 相等说明mid即为key在array中所在位置 return mid; } } return -1; } } 3. 斐波那契查找根据前面二分查找以及插值查找来看，有序表上的查找的关键就是如何分割当前查找的区域（二分查找对半分割，差值查找按线性比例分割），说到分割，还有一个著名的分割方式就是黄金分割。 斐波那契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、····，在数学上，斐波那契被递归方法如下定义：F(1)=1，F(2)=1，F(n)=f(n-1)+F(n-2) （n&gt;=2）。该数列越往后相邻的两个数的比值越趋向于黄金比例值（0.618） 所以我们可以根据斐波那契数列对当前区域进行分割 :) 查找算法：在斐波那契数列找一个等于略大于查找表中元素个数的数F(n)，将原查找表扩展为长度为F(n)(如果要补充元素，则补充重复最后一个元素，直到满足数组元素个数为F(n)个元素)，完成后进行斐波那契分割，即F(n)个元素分割为前半部分F(n-1)个元素，后半部分F(n-2)个元素，找出要查找的元素在那一部分并递归，直到找到。时间复杂度：O(logn)，平均性能优于二分查找。算法实现： class FibonacciSearcher implements Searcher { private static final int MAX_ARRAY_SIZE = 30; /** * 得到长度为len的斐波那契数列 * * @return */ private int[] fibonacci(int len) { if (len &lt; 0) throw new IllegalArgumentException("length must bigger than 0"); int[] fibonacci = new int[len]; fibonacci[0] = 1; fibonacci[1] = 1; for (int i = 2; i &lt; len; i++) { fibonacci[i] = fibonacci[i - 1] + fibonacci[i - 2]; } return fibonacci; } @Override public int search(int[] array, int key) { int low = 0; // 低位 int len = array.length; int high = len - 1; // 高位 int mid; // 中间位 int k = 0; // 斐波那契数列下标(用于进行分割) // 获取斐波那契数列 int[] fib = fibonacci(MAX_ARRAY_SIZE); // 获取斐波那契数列分割点位置 while (len > fib[k] - 1) { k++; } // 创建临时数组(数组长度为fib[k] - 1) int[] tmp = new int[fib[k] - 1]; // 拷贝原数组到tmp数组中 System.arraycopy(array, 0, tmp, 0, len); // 填充tmp数组中剩余的位置,补充的元素值为最后一个元素值 for (int i = len; i &lt; fib[k] - 1; i++) { tmp[i] = array[high]; } // 开始进行类似于二分查找的查找 while (low &lt;= high) { // 对于tmp数组,整个数组的长度为fib[k]-1 // 而 fib[k]-1 = (fib[k-1]-1) + 1 + (fib[k-2]-1); // 所以可以这样理解： mid下标对应元素可以将整个数组拆分为两部分,第1部分有fib[k-1]-1个元素,第2部分有fib[k-2]-1个元素 // mid=low+fib[k-1]-1; 正是将 数组的[low, max(high,tmp.length-1)] // 部分按照斐波那契规则分为两部分 mid = low + fib[k - 1] - 1; if (tmp[mid] > key) { // 需要查找第1部分 high = mid - 1; // fib[k] = fib[k-1] + fib[k-2] // 第一部分有fib[k-1]个元素,所以将k-1赋值为k k = k - 1; } else if (tmp[mid] &lt; key) { // 需要查找第2部分 low = mid + 1; // fib[k] = fib[k-1] + fib[k-2] // 第二部分有fib[k-2]个元素,所以将k-2赋值给k k = k - 2; } else { // 查找成功 // 以下代码其实就是返回 min(mid, high); // return Math.min(mid, high); if (mid &lt;= high) return mid; else return high; // 因为mid可能大于high,即查找到了补充的元素,那么还是应该返回high } } return -1; } } 结束语以上三种查找算法中，都依赖于顺序表，三者的区别本质上就是分割点选的不同。在分割点的选择中，折半查找 mid=(low+high)/2是加法与除法运算；插值查找mid = low+(key-array[low])/(array[high]-array[low])*(high-low)是复杂的四则运算；斐波那契查找mid=low+fib[k-1]-1是简单的加减运算。在海量数据查找过程中细微的差别会影响最终的效率。 三种查找算法，各有优劣，实际开发可以根据数据的特点综合考虑再做出选择。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[查找-顺序查找]]></title>
      <url>post%2F235983682%2F</url>
      <content type="text"><![CDATA[定义顺序查找又称为线性查找，其算法思路是从数组中的第一个（或最后一个）记录开始，将数组中元素逐个与需要查找的关键字进行比对，若发现有相等的，则查找成功；若始终未能相等，则查找失败。 Java实现// 定义接口 interface Searcher { /** * 从数组array中查找关键字key,如果存在则返回该关键字在数组中任意出现的位置(不局限于首次或者末次之类的),否则返回-1 */ int search(int[] array, int key); } /** * 顺序表查找,时间复杂度为O(n) */ class LinearSearcher implements Searcher { @Override public int search(int[] array, int key) { int len = array.length; for (int i = 0; i &lt; len; i++) { if (array[i] == key) return i; } return -1; } } LinearSearcher是标准的线性查找，这里有缺陷：在循环中每个循环实际上需要判断两次(一次是否相等,一次是否越界)，如何改进呢？其实就是设置“哨兵”： /** * 优化的顺序表查找,时间复杂度O(n),但是比普通顺序表查找效率高 */ class OptimizedLinearSearcher implements Searcher { // 相比单纯的线性查找每次for循环需要判断两次,这里设置关键字值(即哨兵)，可以让每次for循环只判断一次 // 当数据量比较大时,如果单纯从线性查找角度看,优化后的线性搜索优势明显 @Override public int search(int[] array, int key) { int len = array.length; if (len == 0) // array为空,返回-1 return -1; if (array[0] == key) return 0; array[0] = key; // array[0]不是key,那么将key赋值给array[0],将array[0]作为哨兵 // 这里"哨兵"也可以放在数组尾部 int i = len - 1; while (array[i] != key) { // 每次循环少判断一个 i--; } if (i == 0) // 从数组尾部一直查找到array[0]才找到,说明不存在 return -1; return i; } } 不论是线性查找还是改进后的线性查找，其时间复杂度都为O(n)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[KMP字符串模式匹配算法Java实现]]></title>
      <url>post%2F3825161135%2F</url>
      <content type="text"><![CDATA[本文灵感来自于July的博客从头到尾彻底理解KMP，并着重于Java实现 :)。 现有字符串匹配算法有不少，如简单暴力的朴素算法(暴力匹配算法)、KMP算法、BM算法以及Sunday算法等，在这里仅介绍前两种算法。 1. 朴素算法朴素算法即暴力匹配算法，对于长度为n的文本串S和长度为m模式串P，在文本串S中是否存在一个有效偏移i，其中 0≤ i &lt; n - m + 1，使得 S[i… i+m - 1] = P[0 … m-1]（注：下标从0开始），如果存在则匹配成功，否则匹配失败。由于在匹配过程中一旦不匹配，就要让模式串P相对于文本串S右移1，即i需要进行回溯，其时间复杂度为O(n*m)。Java实现： // 定义接口 interface StringMatcher { /** * 从原字符串中查找模式字符串的位置,如果模式字符串存在,则返回模式字符串第一次出现的位置,否则返回-1 * * @param source * 原字符串 * @param pattern * 模式字符串 * @return if substring exists, return the first occurrence of pattern * substring, return -1 if not. */ int indexOf(String source, String pattern); } /** * 暴力匹配 * &lt;p> * 时间复杂度: O(m*n), m = pattern.length, n = source.length */ class ViolentStringMatcher implements StringMatcher { @Override public int indexOf(String source, String pattern) { int i = 0, j = 0; int sLen = source.length(), pLen = pattern.length(); char[] src = source.toCharArray(); char[] ptn = pattern.toCharArray(); while (i &lt; sLen &amp;&amp; j &lt; pLen) { if (src[i] == ptn[j]) { // 如果当前字符匹配成功,则将两者各自增1,继续比较后面的字符 i++; j++; } else { // 如果当前字符匹配不成功,则i回溯到此次匹配最开始的位置+1处,也就是i = i - j + 1 // (因为i,j是同步增长的), j = 0; i = i - j + 1; j = 0; } } // 匹配成功,则返回模式字符串在原字符串中首次出现的位置;否则返回-1 if (j == pLen) return i - j; else return -1; } } 2. KMP算法与朴素算法不同，朴素算法是当遇到不匹配字符时，向后移动一位继续匹配，而KMP算法是当遇到不匹配字符时，不是简单的向后移一位字符，而是根据前面已匹配的字符数和模式串前缀和后缀的最大相同字符串长度数组next的元素来确定向后移动的位数，所以KMP算法的时间复杂度比朴素算法的要少，并且是线性时间复杂度，即预处理时间复杂度是O(m)，匹配时间复杂度是O(n)。 next数组含义：代表在模式串P中，当前下标对应的字符之前的字符串中，有多大长度的相同前缀后缀。例如如果next [j] = k，代表在模式串P中，下标为j的字符之前的字符串中有最大长度为k 的相同前缀后缀。 KMP算法的核心就是求next数组，在字符串匹配的过程中，一旦某个字符匹配不成功，next数组就会指导模式串P到底该相对于S右移多少位再进行下一次匹配，从而避免无效的匹配。 next数组求解方法： next[0] = -1。 如果已知next[j] = k,如何求出next[j+1]呢?具体算法如下: 如果p[j] = p[k], 则next[j+1] = next[k] + 1; 如果p[j] != p[k], 则令k=next[k],如果此时p[j]==p[k],则next[j+1]=k+1,如果不相等,则继续递归前缀索引,令 k=next[k],继续判断,直至k=-1(即k=next[0])或者p[j]=p[k]为止 详细的介绍及分析还请移步从头到尾彻底理解KMP，在下语拙 :(Java实现： /** * KMP模式匹配 * @author Tianma * */ class KMPStringMatcher implements StringMatcher { /** * 获取KMP算法中pattern字符串对应的next数组 * * @param p * 模式字符串对应的字符数组 * @return */ protected int[] getNext(char[] p) { // 已知next[j] = k,利用递归的思想求出next[j+1]的值 // 如果已知next[j] = k,如何求出next[j+1]呢?具体算法如下: // 1. 如果p[j] = p[k], 则next[j+1] = next[k] + 1; // 2. 如果p[j] != p[k], 则令k=next[k],如果此时p[j]==p[k],则next[j+1]=k+1, // 如果不相等,则继续递归前缀索引,令 k=next[k],继续判断,直至k=-1(即k=next[0])或者p[j]=p[k]为止 int pLen = p.length; int[] next = new int[pLen]; int k = -1; int j = 0; next[0] = -1; // next数组中next[0]为-1 while (j &lt; pLen - 1) { if (k == -1 || p[j] == p[k]) { k++; j++; next[j] = k; } else { k = next[k]; } } return next; } @Override public int indexOf(String source, String pattern) { int i = 0, j = 0; char[] src = source.toCharArray(); char[] ptn = pattern.toCharArray(); int sLen = src.length; int pLen = ptn.length; int[] next = getNext(ptn); while (i &lt; sLen &amp;&amp; j &lt; pLen) { // 如果j = -1,或者当前字符匹配成功(src[i] = ptn[j]),都让i++,j++ if (j == -1 || src[i] == ptn[j]) { i++; j++; } else { // 如果j!=-1且当前字符匹配失败,则令i不变,j=next[j],即让pattern模式串右移j-next[j]个单位 j = next[j]; } } if (j == pLen) return i - j; return -1; } } 3. 优化的KMP算法（改进next数组）具体过程移步从头到尾彻底理解KMP的3.3.8 Next 数组的优化在这里给出Java实现： /** * 优化的KMP算法(对next数组的获取进行优化) * * @author Tianma * */ class OptimizedKMPStringMatcher extends KMPStringMatcher { @Override protected int[] getNext(char[] p) { // 已知next[j] = k,利用递归的思想求出next[j+1]的值 // 如果已知next[j] = k,如何求出next[j+1]呢?具体算法如下: // 1. 如果p[j] = p[k], 则next[j+1] = next[k] + 1; // 2. 如果p[j] != p[k], 则令k=next[k],如果此时p[j]==p[k],则next[j+1]=k+1, // 如果不相等,则继续递归前缀索引,令 k=next[k],继续判断,直至k=-1(即k=next[0])或者p[j]=p[k]为止 int pLen = p.length; int[] next = new int[pLen]; int k = -1; int j = 0; next[0] = -1; // next数组中next[0]为-1 while (j &lt; pLen - 1) { if (k == -1 || p[j] == p[k]) { k++; j++; // 修改next数组求法 if (p[j] != p[k]) { next[j] = k;// KMPStringMatcher中只有这一行 } else { // 不能出现p[j] = p[next[j]],所以如果出现这种情况则继续递归,如 k = next[k], // k = next[[next[k]] next[j] = next[k]; } } else { k = next[k]; } } return next; } } 4. 花絮提到字符串匹配，或者说字符串查找，我们会想到Java中的String类就有一个String.indexOf(String str);方法，那它使用的是什么算法呢？在这里截取JavaSE-1.8的源码： // String.indexOf(String str); 最终会调用该方法 /** * Code shared by String and StringBuffer to do searches. The * source is the character array being searched, and the target * is the string being searched for. * * @param source the characters being searched.(源字符数组) * @param sourceOffset offset of the source string.(源字符数组偏移量) * @param sourceCount count of the source string.(源字符数组长度) * @param target the characters being searched for.(待搜索的模式字符数组) * @param targetOffset offset of the target string.(模式字符数组偏移量) * @param targetCount count of the target string.(模式数组长度) * @param fromIndex the index to begin searching from.(从原字符数组的哪个下标开始查询) */ static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) { if (fromIndex >= sourceCount) { return (targetCount == 0 ? sourceCount : -1); } if (fromIndex &lt; 0) { fromIndex = 0; } if (targetCount == 0) { return fromIndex; } char first = target[targetOffset]; int max = sourceOffset + (sourceCount - targetCount); for (int i = sourceOffset + fromIndex; i &lt;= max; i++) { /* Look for first character. */ // 找到第一个匹配的字符的位置 if (source[i] != first) { while (++i &lt;= max &amp;&amp; source[i] != first); } /* Found first character, now look at the rest of v2 * if (i &lt;= max) { // 找到了第一个匹配的字符，看余下的是否完全匹配 int j = i + 1; int end = j + targetCount - 1; for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++); if (j == end) { /* Found whole string. */ return i - sourceOffset; } // 如果不完全匹配，因为外层for循环中有i++，即i+1继续匹配 // 故而该方法本质上就是字符串匹配的朴素算法 } } return -1; } 通过对代码片段的注释和分析可以看出，Java源码中的String.indexOf(String str); 内部所使用的算法其实就是字符串匹配的朴素算法… 源码github地址:StringMatchSample 重要参考:从头到尾彻底理解KMP]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[栈的应用之中缀表达式和后缀表达式]]></title>
      <url>post%2F1484310523%2F</url>
      <content type="text"><![CDATA[中缀表达式： 是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于的中间（例：3 + 4），中缀表达式是人们常用的算术表示方法，但是不易被计算机所解析。 后缀表达式：是一个通用的算术或逻辑公式表示方法， 操作符是后缀形式处于操作数的后面（例：3 4 +），后缀表达式虽然不是人们所习惯的运算表示方法，但是易被计算机解析。例如：对于中缀表达式 9+(3-1)*2+10/2 , 其后缀表达式是 9 3 1 - 3 * + 10 2 / + , 那么为了方便计算机解析计算，我们需要将中缀表达式转换成后缀表达式，然后再对后缀表达式进行解析。 1. 中缀表达式转后缀表达式： 当读到一个操作数时，立即将它放到输出中。读到的是操作符则需要接着判断是否该入栈。读到的是左圆括号则入栈。 在读到操作符时，如果栈为空或者栈顶操作符为（，则入栈。如果栈顶操作符不为（，且此操作符优先级小于或等于此时栈顶操作符，则将栈中元素弹出直至 ①遇到左括号 或者 ②栈顶元素为更低优先级 或者 ③栈为空为止，并将当前操作符入栈；否则当前操作符继续入栈。操作符中，+-优先级低，*/优先级高。 如果遇到一个右括号，那么就将栈中元素弹出并输出直至遇到左括号为止。但是这个左括号只被弹出，并不输出。 如果读到输入的末尾，若栈不为空则将栈元素弹出直到该栈变成空栈，并将弹出的符号写到输出中。 “9+(3-1)*2+10/2” 转换过程： 操作过程 栈中元素 输出 读入 9，输出 9 读入 +，栈为空，规则2，入栈 + 9 读入 ( ，左括号，规则1，入栈 + ( 9 读入 3，输出 + ( 9 3 读入 -，栈顶为（，规则2，入栈 + ( - 9 3 读入 1，输出 + ( - 9 3 1 读入 ) ，右括号，规则3，出栈并输出 + 9 3 1 - 读入 *，*优先级高于栈顶+，规则,2，入栈 + * 9 3 1 - 读入 3，输出 + * 9 3 1 - 3 读入 +，+优先级低于栈顶*，规则2，栈中元素出栈，当前操作符入栈 + 9 3 1 - 3 * + 读入 10， 输出 + 9 3 1 - 3 * + 10 读入 / ， /优先级高于+，入栈 + / 9 3 1 - 3 * + 10 读入 2， 输出 + / 9 3 1 - 3 * + 10 读至末尾，规则4，栈不为空，栈中元素出栈并输出 9 3 1 - 3 * + 10 / + 2. 后缀表达式计算最终结果： 从左到右遍历表达式的每个数字和符号,遇到是数字则进栈,遇到是运算符则将栈顶两个元素出栈,进行运算并将运算结果进栈； 遍历完后缀表达式,此时栈中剩余的数字就是运算结果。 “9 3 1 - 3 * + 10 2 / +” 计算过程： 操作过程 栈中元素 读入 9，入栈 9 读入 3，入栈 9 3 读入 1，入栈 9 3 1 读入 -，运算并将结果入栈 9 2 读入 3，入栈 9 2 3 读入 *，运算并将结果入栈 9 6 读入 +，运算并将结果入栈 15 读入 10，入栈 15 10 读入 2，入栈 15 10 2 读入 /，运算并将结果入栈 15 5 读入 +，运算并将结果入栈 20 读入完毕，栈中元素即为结果 20 简单中缀表达式计算的java实现： public class SimpleCalcutor { private class Item { private String value; private Integer number; public Item(String value) { this.value = value; try { number = Integer.parseInt(value); } catch (Exception ignore) { } } public boolean isNumber() { return number != null; } public int getNumber() { if (isNumber()) return number; throw new NumberFormatException(); } public boolean isAdd() { return "+".equals(value); } public boolean isSub() { return "-".equals(value); } public boolean isMul() { return "*".equals(value); } public boolean isDiv() { return "/".equals(value); } public boolean isLeftBracket() { return "(".equals(value); } public boolean isRightBracket() { return ")".equals(value); } public int getPriority() { if (isAdd() || isSub()) return 0; if (isMul() || isDiv()) return 1; throw new RuntimeException("This is not +, -, *, /"); } @Override public String toString() { return value != null ? value.toString() : null; } } /** * 计算结果 * * @param calStr * @return */ public int calculate(String calStr) { List&lt;Item> infixes = parse(calStr); List&lt;Item> postfixes = infix2postfix(infixes); return calculateByPostfix(postfixes); } /** * 利用正则表达式将待计算的字符串转化为List&lt;Item>形式 ,如 10/2 -> [10, /, 2] * * @param calStr * @return */ private List&lt;Item> parse(String calStr) { Pattern pattern = Pattern.compile("\\D|\\d+"); Matcher m = pattern.matcher(calStr); List&lt;Item> items = new ArrayList&lt;Item>(); while (m.find()) { items.add(new Item(m.group(0))); } return items; } /** * 中缀表达式转换为后缀表达式 * &lt;p> * 1.当读到一个操作数时，立即将它放到输出中。读到的是操作符则需要接着判断是否该入栈。读到的是左圆括号则入栈。&lt;br> * 2.如果遇到一个右括号，那么就将栈中元素弹出并输出直至遇到左括号为止。但是这个左括号只被弹出，并不输出。&lt;br> * 3.在读到操作符时，如果此操作符优先级小于或等于此时栈顶操作符，则将栈中元素弹出直至(1)遇到左括号或者(2)栈顶元素为更低优先级或者(3) * 栈为空为止。操作符中，'+''-'优先级最低，'('')'优先级最高。 &lt;br> * 4.如果读到输入的末尾，将栈元素弹出直到该栈变成空栈，将符号写到输出中。 * * @return */ private List&lt;Item> infix2postfix(List&lt;Item> infixes) { List&lt;Item> postfixes = new ArrayList&lt;Item>(); Stack&lt;Item> stack = new Stack&lt;Item>(); for (Item item : infixes) { if (item.isNumber()) { postfixes.add(item); } else if (item.isRightBracket()) { // ) 右括号,将栈中元素弹出直至左括号,且左括号和右括号不加入到后缀表达式中 while (true) { Item tmp = stack.pop(); if (tmp.isLeftBracket()) break; postfixes.add(tmp); } } else if (item.isLeftBracket()) { // ( 左括号,将左括号入栈 stack.push(item); } else { // 当前操作符为 +, -, *, /, if (stack.isEmpty()) { // 操作符栈为空,则将当前操作符压入栈 stack.push(item); continue; } Item top = stack.peek(); if (top.isLeftBracket()) { // 操作符栈顶为左括号(,则将当前操作符压入栈 stack.push(item); continue; } if (item.getPriority() &lt;= top.getPriority()) { // 如果此操作符(+,-,*,/)优先级小于或等于此时栈顶操作符 // 则将栈中元素弹出直至(1)遇到左括号或者(2)栈顶元素为更低优先级或者(3)栈为空为止 // 并将弹出的元素加入后缀表达式中,将当前操作符压入栈中 while (true) { Item tmp = stack.peek(); if (tmp.isLeftBracket() || tmp.getPriority() &lt; item.getPriority()) { break; } postfixes.add(tmp); stack.pop(); if (stack.isEmpty()) break; } stack.push(item); } else { // 如果当前操作符(+,-,*,/)优先级大于此时栈顶操作符,则将当前操作符压入栈 stack.push(item); } } } // 如果栈中元素不为空,则将栈中元素全部弹出,加入后缀表达式中 while (!stack.isEmpty()) { postfixes.add(stack.pop()); } return postfixes; } /** * 通过后缀表达式计算数值 * &lt;p> * 1. 从左到右遍历表达式的每个数字和符号,遇到是数字则进栈,遇到是运算符则将栈顶两个元素出栈,进行运算并将运算结果进栈&lt;br> * 2. 遍历完后缀表达式,此时栈中剩余的数字就是运算结果 * * @param postfixes * @return */ private int calculateByPostfix(List&lt;Item> postfixes) { Stack&lt;Integer> stack = new Stack&lt;Integer>(); for (Item item : postfixes) { if (item.isNumber()) { stack.push(item.getNumber()); } else { // 运算符 int num1 = stack.pop(); int num2 = stack.pop(); int result; if (item.isAdd()) { result = num2 + num1; } else if (item.isSub()) { result = num2 - num1; } else if (item.isMul()) { result = num2 * num1; } else if (item.isDiv()) { result = num2 / num1; } else { throw new IllegalArgumentException("Operator invalid : " + item.value); } stack.push(result); } } return stack.pop(); } public static void main(String[] args) { SimpleCalcutor calcutor = new SimpleCalcutor(); String calStr = "9+(3-1)*3+10/2"; int result = calcutor.calculate(calStr); System.out.println(result); } } 源码github地址：SimpleCalculator 参考链接：利用栈将中缀表达式转换成后缀表达式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android根据图片Uri获取图片绝对路径]]></title>
      <url>post%2F3401996021%2F</url>
      <content type="text"><![CDATA[当我们需要选择并获取图片将其展示出来时，一般会这样处理： // 进入选择图片的界面 private void selectImage(){ Intent intent = new Intent(Intent.ACTION_GET_CONTENT); intent.setType("image/*"); startActivityForResult(intent, CHOOSE_IMAGE); } // 在onActivityResult()回调方法中进行数据获取 protected void onActivityResult(int requestCode, int resultCode, Intent data) { // ... 进行一些判断处理 Uri uri = data.getData(); // ... 接下来进行图片显示 } 以上可以看出我们获取的是Uri类型的数据，要显示图片可以先根据Uri获取图片的位置，然后再显示在界面上，那么如何根据Uri来获取图片的绝对路径呢？ 这涉及到Android版本适配问题，因为Android Api版本不同，获取Uri对应的图片绝对路径也不一样，那么需要对不同的Api进行适配： /** * 根据图片的Uri获取图片的绝对路径(已经适配多种API) * @return 如果Uri对应的图片存在,那么返回该图片的绝对路径,否则返回null */ public static String getRealPathFromUri(Context context, Uri uri) { int sdkVersion = Build.VERSION.SDK_INT; if (sdkVersion &lt; 11) { // SDK &lt; Api11 return getRealPathFromUri_BelowApi11(context, uri); } if (sdkVersion &lt; 19) { // SDK &gt; 11 &amp;&amp; SDK &lt; 19 return getRealPathFromUri_Api11To18(context, uri); } // SDK &gt; 19 return getRealPathFromUri_AboveApi19(context, uri); } /** * 适配api19以上,根据uri获取图片的绝对路径 */ private static String getRealPathFromUri_AboveApi19(Context context, Uri uri) { String filePath = null; String wholeID = DocumentsContract.getDocumentId(uri); // 使用&#39;:&#39;分割 String id = wholeID.split(&quot;:&quot;)[1]; String[] projection = { MediaStore.Images.Media.DATA }; String selection = MediaStore.Images.Media._ID + &quot;=?&quot;; String[] selectionArgs = { id }; Cursor cursor = context.getContentResolver().query( MediaStore.Images.Media.EXTERNAL_CONTENT_URI, projection, selection, selectionArgs, null); int columnIndex = cursor.getColumnIndex(projection[0]); if (cursor.moveToFirst()) { filePath = cursor.getString(columnIndex); } cursor.close(); return filePath; } /** * 适配api11-api18,根据uri获取图片的绝对路径 */ private static String getRealPathFromUri_Api11To18(Context context, Uri uri) { String filePath = null; String[] projection = { MediaStore.Images.Media.DATA }; CursorLoader loader = new CursorLoader(context, uri, projection, null, null, null); Cursor cursor = loader.loadInBackground(); if (cursor != null) { cursor.moveToFirst(); filePath = cursor.getString(cursor.getColumnIndex(projection[0])); cursor.close(); } return filePath; } /** * 适配api11以下(不包括api11),根据uri获取图片的绝对路径 */ private static String getRealPathFromUri_BelowApi11(Context context, Uri uri) { String filePath = null; String[] projection = { MediaStore.Images.Media.DATA }; Cursor cursor = context.getContentResolver().query(uri, projection, null, null, null); if (cursor != null) { cursor.moveToFirst(); filePath = cursor.getString(cursor.getColumnIndex(projection[0])); cursor.close(); } return filePath; } 以上便可以获取Uri对应的图片的绝对路径，然后就可以愉快的做我们想做的事情咯~ 参考链接:Android | Display Selected Image and Its Real Pathandroid get real path by Uri.getPath()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android获取图片压缩后的Bitmap避免OOM]]></title>
      <url>post%2F3401996020%2F</url>
      <content type="text"><![CDATA[OOM即Out Of Memory的简称，Android平台避免OOM异常的发生是非常有必要的。而在Android中加载大量大图便可能会导致OOM异常的出现，解决的办法之一就是加载图片之前对图片进行压缩然后再获取图片对应的Bitmap对象，那么应该如何操作呢？ 如下： /** * 通过图片的绝对路径来获取对应的压缩后的Bitmap对象 */ public static Bitmap getCompressedBitmap(String filePath, int requireWidth, int requireHeight) { // 第一次解析将inJustDecodeBounds设置为true,用以获取图片大小,并且不需要将Bitmap对象加载到内存中 BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeFile(filePath, options); // 第一次解析 // 计算inSampleSize的值,并且赋值给Options.inSampleSize options.inSampleSize = calculateInSampleSize(options, requireWidth, requireHeight); // 使用获取到的inSampleSize再次解析图片 options.inJustDecodeBounds = false; return BitmapFactory.decodeFile(filePath, options); } /** * 通过图片资源id获取图片对应的压缩后的Bitmap对象 */ public static Bitmap getCompressedBitmap(Resources res, int resId, int requiredWidth, int requiredHeight) { BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeResource(res, resId, options);// 第一次解析 options.inSampleSize = calculateInSampleSize(options, requiredWidth, requiredHeight); options.inJustDecodeBounds = false; return BitmapFactory.decodeResource(res, resId, options);// 第一次解析 } /** * 计算压缩的inSampleSize的值,该值会在宽高上都进行压缩(也就是压缩前后比例是inSampleSize的平方倍) */ private static int calculateInSampleSize(BitmapFactory.Options options, int requireWidth, int requireHeight) { // 获取源图片的实际的宽度和高度 int realWidth = options.outWidth; int realHeight = options.outHeight; int inSampleSize = 1; if (realWidth > requireWidth || realHeight > requireHeight) { // 计算出实际的宽高与目标宽高的比例 int widthRatio = Math.round((float) realWidth / (float) requireWidth); int heightRatio = Math.round((float) realHeight / (float) requireHeight); // 选择宽高比例最小的值赋值给inSampleSize,这样可以保证最终图片的宽高一定会大于或等于目标的宽高 inSampleSize = widthRatio &lt; heightRatio ? widthRatio : heightRatio; } return inSampleSize; } 以上代码中，有一点值得商榷：到底是要让图片显示完全还是让图片宽高和需要的宽高一致呢？如果需要让图片宽高和需要的宽高一致的话，就选择比率小的: inSampleSize = widthRatio &lt; heightRatio ? widthRatio : heightRatio; 如果需要让图片显示完全的话，就选择比率大的： inSampleSize = widthRatio > heightRatio ? widthRatio : heightRatio; 如果两者都要兼顾的话，就让方法多设置参数，让调用者决定去吧！ :) 参考链接：Displaying Bitmaps EfficientlyAndroid高效加载大图、多图解决方案，有效避免程序OOM]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android获取Bitmap在其ImageView中的偏移量]]></title>
      <url>post%2F4080066433%2F</url>
      <content type="text"><![CDATA[在ImageView中设置不同的scaleType(包括center, centerInside, centerCrop, fitXY, fitCenter, fitStart, fitEnd, matrix)属性时，ImageView中实际的图片(也就是Bitmap)会根据不同的scaleType属性来确定自己相对于ImageView的位置。 例如： fitCenter: fitStart:图片中的天蓝色是我给ImageView设置的backgroud属性，可以看出Bitmap相对于ImageView的位置与scaleType属性是相关的。那么，如何获取Bitmap在其ImageView中的偏移量（也就是在x和y方向上的像素偏移量）呢？代码片段如下： /** * 获取Bitmap在ImageView中的偏移量数组,其中第0个值表示在水平方向上的偏移值,第1个值表示在垂直方向上的偏移值 * * @param imageView * @param includeLayout 在计算偏移的时候是否要考虑到布局的因素,如果要考虑该因素则为true,否则为false * @return the offsets of the bitmap inside the imageview, offset[0] means horizontal offset, offset[1] means vertical offset */ private int[] getBitmapOffset(ImageView imageView, boolean includeLayout) { int[] offset = new int[2]; float[] values = new float[9]; Matrix matrix = imageView.getImageMatrix(); matrix.getValues(values); // x方向上的偏移量(单位px) offset[0] = (int) values[2]; // y方向上的偏移量(单位px) offset[1] = (int) values[5]; if (includeLayout) { ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams) imageView.getLayoutParams(); int paddingTop = imageView.getPaddingTop(); int paddingLeft = imageView.getPaddingLeft(); offset[0] += paddingLeft + params.leftMargin; offset[1] += paddingTop + params.topMargin; } return offset; } 上面的代码中Matrix类实际上是一个3*3的矩阵，看Android源码： public class Matrix { public static final int MSCALE_X = 0; public static final int MSKEW_X = 1; public static final int MTRANS_X = 2; public static final int MSKEW_Y = 3; public static final int MSCALE_Y = 4; public static final int MTRANS_Y = 5; public static final int MPERSP_0 = 6; public static final int MPERSP_1 = 7; public static final int MPERSP_2 = 8; ... } 其中MTRANS_X，MTRANS_Y字段分别表示x和y方向上的平移量。所以在代码片段中会出现： offset[0] = (int) values[2]; offset[1] = (int) values[5]; 参考链接：android - how to get the image edge x/y position inside imageviewAndroid中图像变换Matrix的原理、代码验证和应用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python3.4在内存中生成zip压缩文件]]></title>
      <url>post%2F4080066432%2F</url>
      <content type="text"><![CDATA[最近使用Django1.8.5搭建了一个Web项目，用来生成Android客户端的皮肤apk，相当于一个在线的皮肤apk生成工具，于是就理所当然的需要进行在线的下载apk的操作。由于Android项目比较大，一种主题皮肤对应的apk不止一个，一次性下载多个文件的话，于是选择打包下载。 本文在使用Python在内存中生成zip文件的基础上也进行了小的修改。主要是原文的生产环境是Python2.x，而我使用的是Python3.4，在语法上有些小的变动。 # !user/bin/env python3 # -*-coding : utf-8 -*- import zipfile from io import BytesIO import os u''' Create zip file in memory. ''' class InMemoryZIP(object): def __init__(self): # create the in-memory file-like object self.in_memory_zip = BytesIO() def append(self, filename_in_zip, file_contents): """ Appends a file with name filename_in_zip \ and contents of file_contents to the in-memory zip. """ # create a handle to the in-memory zip in append mode zf = zipfile.ZipFile(self.in_memory_zip, 'a', zipfile.ZIP_DEFLATED, False) # write the file to the in-memory zip zf.writestr(filename_in_zip, file_contents) # mark the files as having been created on Windows # so that Unix permissions are not inferred as 0000 for zfile in zf.filelist: zfile.create_system = 0 return self def appendfile(self, file_path, file_name=None): """ Read a file with path file_path \ and append to in-memory zip with name file_name. """ if file_name is None: file_name = os.path.split(file_path)[1] f = open(file_path, 'rb') file_contents = f.read() self.append(file_name, file_contents) f.close() return self def read(self): """ Returns a string with the contents of the in-memory zip. """ self.in_memory_zip.seek(0) return self.in_memory_zip.read() def writetofile(self, filename): """ Write the in-memory zip to a file """ f = open(filename, 'wb') f.write(self.read()) f.close() if __name__ == '__main__': imz = InMemoryZIP() imz.appendfile('a.txt').append('test.txt', 'This is content in test.txt') imz.writetofile('test.zip') 与原链接中的博文相比主要改动如下： 将原文的 import StringIO 改成了 from io import BytesIO，主要就是 Python2.x 和 Python3.x 的格式区别。其实也可以将 import StringIO 改成 from io import BytesIO as StringIO ，这样的话在代码中就不需要进行替换，但是可能会误导其他读这段代码的人。 在Django中简单的使用方法为: #... def downloadFiles(request): fns = ["/apk/foo1.apk", "/apk/foo2.apk", "/apk/foo3.apk",] imz = InMemoryZip() for fn in fns: imz.appendfile(fn) data = img.read() response = HttpResponse(content_type="application/octet-stream") response["Content-Disposition"] = "attachment; %s" % "foo.zip" response["Content-Length"] = len(data) response.write(data) return response 与原链接的博文相比改动就是 HttpResponse 中的参数要使用 content_type 而不是 mimetype最后引用原文的一段话: 这个方法虽然很方便，不过很耗资源，我试着用它在 Django 里压缩一个 1.4G 的文本文件，差不多用了 8 分钟，期间 CPU 使用率一直是 100%，所以，如果要压缩的是大文件，或者压缩任务比较频繁，可能需要认真处理一下性能问题。 也就是说这个方法适合下载小文件，要是下载的文件较大的话，建议阅读以下文章: Django 大文件下载 Django 实现下载文件功能]]></content>
    </entry>

    
  
  
</search>
