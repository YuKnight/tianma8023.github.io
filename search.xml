<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小米8 刷入 MIUI 欧洲版并 Root]]></title>
    <url>%2Fpost%2F731913467%2F</url>
    <content type="text"><![CDATA[先大致介绍一下各个 MIUI 版本： 国内版 MIUI 国内版就是官方 MIUI 的国内版，优点：能吃上新功能，有小爱，缺点：有广告，臃肿，后台常驻很多系统组件，同时有不少系统组件没办法禁用，Google 套件不太好安装，安装好了之后也会经常因为不稳定而 Crash。官方站点：米柚 国际版 MIUI 也称为 俄罗斯版，国际版就是官方 MIUI 的国际版，优点：自带 Google 套件，无广告，缺点：还是比较臃肿，自带的 Google 套件过多。官方站点：MIUI Global 欧洲版 MIUI 也称为 波兰版，属于 MIUI 的第三方定制 Rom，也就是通常所说的 魔改MIUI，但不是小作坊制作，稳定性比较可靠。优点：自带 Google 套件，无广告，不臃肿，缺点：无小爱。 官方站点：XIAOMI.EU 刷入教程以最新的开发版（18.12.27）的欧洲版为例，已经在该版本上成功刷入。 解锁小米手机（本质是解锁 Bootloader），地址：解锁小米手机 打开手机开发者选项，下载并刷入 LR.TEAM 制作的非官方 Twrp，使用该帖子中自带的一键刷入的bat脚本，按提示刷入twrp。地址：LR.Team 小米8 专版TWRP 下载需要刷入的包 下载Rom，18.12.27 的欧洲版 MIUI 卡刷包，帖子地址：MIUI 10 18.12.27 下载通用的 Disable DM-verify 包，帖子地址：Universal DM-Verity, ForceEncrypt, Disk Quota Disablers 下载 Magisk-v18.0.zip，地址：Magisk Github Releases 刷入卡刷包，并Root 三清：进入 Recovery 模式，进入TWRP -&gt; 清除 -&gt; 高级清除 -&gt; 选择 “system”, “cache”, “data” 并清除 刷入 MIUI Rom 卡刷包：将卡刷包放进手机SD卡中，进入 TWRP -&gt; 安装 -&gt; 选择卡刷包并确认刷入 刷入 Disable-DM-verify 的包：TWRP -&gt; 安装 -&gt; 选择并确认刷入 Root系统：刷入 Magisk-v18.0.zip 包，步骤同上。 重启，大功告成！ 参考 关于卡米的问题：TWRP bootloop after restore… 关于卡米的问题：Bootloop after root]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>玩机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xposed注册系统服务]]></title>
    <url>%2Fpost%2F3242480973%2F</url>
    <content type="text"><![CDATA[我们知道像 ClipboardManager, ActivityManager 实际上底层都是通过 Binder 以 aidl 接口的形式实现的，对应的服务端类名都是 xxxService 的形式，例如 ClipboardService, ActivityManagerService。幸运的是，在 Xposed 框架支持下，我们也可以注册自定义的系统服务。 系统服务注册流程分析不想看源码分析过程的，可以直接跳到 自定义系统服务实现。 在这里以 API 27(Android 8.1) 的 ActivityManagerService 为例，ActivityManagerService 是系统主进程的开端，这个类是 “核心Java系统” 开始以及 “系统上下文” 创建的地方。 SystemServer 由 Zygote 进程 fork 而来，其进程名为 system_server，大概流程为：ZygoteInit#main() -&gt; Zygote#forkSystemServer() -&gt; com_android_internal_os_Zygote#nativeForkSystemServer() -&gt; com_android_internal_os_Zygote#ForkAndSpecializeCommon() -&gt; ZygoteInit#handleSystemServerProcess() -&gt; ZygoteInit#zygoteInit() -&gt; RuntimeInit#applicationInit() -&gt; RuntimeInit#findStaticMain() -&gt; SystemServer#main() 关于 SystemServer 更详细的生成过程分析，请参看 Android系统启动-SystemServer上篇 下面分析 SystemServer 方法都做了什么： SystemServer#main()： public static void main(String[] args) { new SystemServer().run(); } private void run() { // 创建主线程 Looper Looper.prepareMainLooper(); // 创建系统Context createSystemContext(); // 创建SystemServiceManager mSystemServiceManager = new SystemServiceManager(mSystemContext); // 启动各种系统服务 // 1. 启动引导服务 startBootstrapServices(); // 2. 启动核心服务 startCoreServices(); // 3. 启动其他服务 startOtherServices(); Looper.loop(); } 创建系统Context - createSystemContext() private void createSystemContext() { ActivityThread activityThread = ActivityThread.systemMain(); mSystemContext = activityThread.getSystemContext(); mSystemContext.setTheme(DEFAULT_SYSTEM_THEME); final Context systemUiContext = activityThread.getSystemUiContext(); systemUiContext.setTheme(DEFAULT_SYSTEM_THEME); } 关于 ActivityThread#systemMain() 中创建了 ActivityThread 对象，并调用其 attach 方法： public static ActivityThread systemMain() { ActivityThread thread = new ActivityThread(); thread.attach(true); } ActivityThread() { mResoureceManager = ResoureceManager.getInstance(); } private void attach(boolean attach) { if(!system) { ... } else { // 系统Context android.ddm.DdmHandleAppName.setAppName(&quot;system_process&quot;,UserHandle.myUserId()); mInstrumentation = new Instrumentation(); ContextImpl context = ContextImpl.createAppContext(this, getSystemContext().mPackageInfo); mInitialApplication = context.mPackageInfo.makeApplication(true, null); mInitialApplication.onCreate(); } } 关于 Application 的创建过程，就不再分析了。 启动引导服务 - startBootstrapServices() // 初始化 ActivityManagerService mActivityManagerService = mSystemServiceManager.startService(ActivityManagerService.Lifecycle.class).getService(); ... // 设置系统进程 mActivityManagerService.setSystemProcess(); 追踪 SystemServiceManager#startService: public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) { final String name = serviceClass.getName(); final T service; Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class); service = constructor.newInstance(mContext); startService(service); return service; } public void startService(final SystemService service) { service.onStart(); } SystemServiceManager#startService() 最终会调用 SystemService 实现类的 onStart() 方法。 也就是说，会调用 ActivityManagerService.Lifecycle#onStart() 方法： public static final class Lifecycle extends SystemService { private final ActivityManagerService mService; public Lifecycle(Context context) { super(context); mService = new ActivityManagerService(); } @Override public void onStart() { mService.start(); } public ActivityManagerService getService() { return mService(); } } 最终会调用 ActivityManagerService 的构造方法和 start 方法，完成其初始化和初步配置。 再看一下 ActivityManagerService#setSystemProcess()： public void setSystemProcess() { ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true); ... } 至此，ActivityServiceManager 作为系统服务被注册添加到 ServiceManager 当中。 自定义系统服务实现 自定义 ICustomService.aidl： package com.tianma.customsystemservice.aidl; interface ICustomService { /* toUppercase */ String toUpperCase(String str); /* add numbers */ int add(int num1, int num2); } 创建 ICustomService.aidl 的实现类 CustomService.java： public class CustomService extends ICustomService.Stub { @Override public String toUpperCase(String str) throws RemoteException { return str.toUpperCase(); } @Override public int add(int num1, int num2) throws RemoteException { return num1 + num2; } } 创建 CustomServiceHook 类实现 IXposedHookZygoteInit，用来注册系统服务： public class CustomServiceHook implements IXposedHookZygoteInit { @Override public void initZygote(StartupParam startupParam) throws Throwable { if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) { // android 5.0+ Class&lt;?&gt; activityThread = Class.forName(&quot;android.app.ActivityThread&quot;); XposedBridge.hookAllMethods(activityThread, &quot;systemMain&quot;, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { final ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); Class&lt;?&gt; ams = XposedHelpers.findClass(&quot;com.android.server.am.ActivityManagerService&quot;, classLoader); XposedHelpers.findAndHookConstructor(ams, Context.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { CustomService.register((Context) param.args[0], classLoader); } }); } }); } else { final ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); Class&lt;?&gt; ams = XposedHelpers.findClass(&quot;com.android.server.am.ActivityManagerService&quot;, classLoader); XposedBridge.hookAllMethods(ams, &quot;main&quot;, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { CustomService.register((Context) param.getResult(), classLoader); } }); } } } 上述代码中，ActivityManagerService 是系统主进程的开端，这个类是 “核心Java系统” 开始以及 “系统上下文” 创建的地方。在 Android L 之前，可以直接访问 ActivityManagerService 这个类；从 Android L 起系统使用了独立的类加载器(ClassLoader)，需要先 Hook ActivityThread，因为 ActivityThread 中创建了可以用来访问 ActivityManagerService 的类加载器。 CustomService 的 register() 方法用来注册系统服务： public static void register(Context context, ClassLoader classLoader) { Class&lt;?&gt; svcManager = XposedHelpers.findClass(&quot;android.os.ServiceManager&quot;, classLoader); CustomService customService = new CustomService(context); XposedHelpers.callStaticMethod(svcManager, /* methodName */&quot;addService&quot;, /* name */getServiceName(), /* service */ customService, /* allowIsolated */ true); log(&quot;register service succeed&quot;); } private static String getServiceName() { // 5.0 之后，selinux &quot;user.&quot; 前缀 return (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP ? &quot;user.&quot; : &quot;&quot;) + &quot;customservice&quot;; } 其实就是通过调用 ServiceManager#addService() 来实现，需要注意的是，Android L 起，系统服务名需要加 user. 前缀。 完整的 CustomService 实现： package com.tianma.customsystemservice.aidl; import android.content.Context; import android.os.Build; import android.os.IBinder; import android.os.RemoteException; import android.util.Log; import java.lang.reflect.Method; import de.robv.android.xposed.XposedHelpers; public class CustomService extends ICustomService.Stub { private static final String TAG = &quot;CustomService&quot;; private Context mContext; private static ICustomService mClient; private CustomService(Context context) { mContext = context; } @Override public String toUpperCase(String str) throws RemoteException { return str.toUpperCase(); } @Override public int add(int num1, int num2) throws RemoteException { return num1 + num2; } public static void register(Context context, ClassLoader classLoader) { Class&lt;?&gt; svcManager = XposedHelpers.findClass(&quot;android.os.ServiceManager&quot;, classLoader); CustomService customService = new CustomService(context); XposedHelpers.callStaticMethod(svcManager, /* methodName */&quot;addService&quot;, /* name */getServiceName(), /* service */ customService, /* allowIsolated */ true); log(&quot;register service succeed&quot;); } private static String getServiceName() { // 5.0 之后，selinux &quot;user.&quot; 前缀 return (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP ? &quot;user.&quot; : &quot;&quot;) + &quot;customservice&quot;; } public static ICustomService getService() { if (mClient == null) { try { Class&lt;?&gt; svcManager = Class.forName(&quot;android.os.ServiceManager&quot;); Method getServiceMethod = svcManager.getDeclaredMethod(&quot;getService&quot;, String.class); IBinder binder = (IBinder) getServiceMethod.invoke(null, getServiceName()); mClient = ICustomService.Stub.asInterface(binder); } catch (Exception e) { e.printStackTrace(); log(e); } } return mClient; } private static void log(String text) { Log.d(TAG, text); } private static void log(Throwable t) { Log.e(TAG, Log.getStackTraceString(t)); } } 调用： ICustomService customService = CustomService.getService(); if (customService != null) { int sum = customService.add(1, 2); String upper = customService.toUpperCase(&quot;hello world&quot;); } 完整示例源码：CustomSystemService 参考Custom System Service using XposedBridgeXPrivacy - XPrivacy.javaXposed Issue - classLoader ClassNotFoundExceptionAndroid系统启动-SystemServer上篇Android系统启动-SystemServer下篇基于xposed实现android注册系统服务，解决跨进程共享数据问题使用Xposed添加自定义系统服务]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>Xposed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android shell service 命令]]></title>
    <url>%2Fpost%2F3076548912%2F</url>
    <content type="text"><![CDATA[Android Shell 中有 service 命令，其二进制文件位于 /system/bin/service，该命令可以用来调试，甚至是应用于开发。 先看一下 service 用法： $ adb shell service Usage: service [-h|-?] service list service check SERVICE service call SERVICE CODE [i32 N | i64 N | f N | d N | s16 STR ] ... Options: i32: Write the 32-bit integer N into the send parcel. i64: Write the 64-bit integer N into the send parcel. f: Write the 32-bit single-precision number N into the send parcel. d: Write the 64-bit double-precision number N into the send parcel. s16: Write the UTF-16 string STR into the send parcel. service / service -h / service -? 都是用来获取 service 命令帮助信息的命令。 service list 用来列出当前可用的系统服务。比如：$ adb shell service list Found 126 services: 0 sip: [android.net.sip.ISipService] 1 Genyd: [com.genymotion.genyd.IGenydService] 2 SystemPatcher: [com.genymotion.systempatcher.ISystemPatcher] 3 carrier_config: [com.android.internal.telephony.ICarrierConfigLoader] 4 phone: [com.android.internal.telephony.ITelephony] ... 43 notification: [android.app.INotificationManager] ... service check SERVICE 用来检测指定的服务是否可用。比如:$ adb shell service check notification Service notification: found 表示 notification 服务可用。 service call 命令用来调用服务中的方法，具体在下文单独说明。 service call 命令service call SERVICE CODE [i32 N | i64 N | f N | d N | s16 STR ] ...此命令用来调用服务中的方法，其中： SERVICE 代表服务名称； CODE 代表所要调用的的服务中的方法在其 aidl 文件中对应的位置，第几个位置就调第几个方法； [i32 N | i64 N | f N | d N | s16 STR ] ... 表示方法的参数，其中：i32 表示 int 类型，i64 表示 long 类型，f 表示 float 类型，d 表示 double 类型，s16 表示 String 类型。 该命令语法如下： service call &lt;your_service_name&gt; &lt;number at which the founction in your_service_name.aidl&gt; &lt;type of argument&gt; &lt;argument&gt; 即 service call &lt;服务名&gt; &lt;服务名.aidl中的第几个方法&gt; &lt;参数类型&gt; &lt;参数值&gt; 那么 SERVICE 所代表的系统服务的 aidl 源文件到底在哪儿看呢？下文以 notification 系统服务为例。 首先调用 service list 找到指定系统服务对应的 aidl ：$ adb shell service list 43 notification: [android.app.INotificationManager] notification 命令对应的系统服务的 aidl 是 android.app.INotificationManager.aidl 其次，在 Android 的 framework 源码中找到对应的 aidl 文件，详细步骤为： android framework 源码地址为：https://android.googlesource.com/platform/frameworks/base/ 找到对应的系统版本，以 android-9.0.0_r18 为例，该版本源码地址为：https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r18 android.app.INotificationManager.aidl 对应的路径为 /core/java/android/app/INotificationManager.aidl，找到地址：https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r18/core/java/android/app/INotificationManager.aidl 最终地址为：android-9.0.0_r18 INotificationManager.aidl 我们看一下 android-9.0.0_r18 版本的 INotificationManager.aidl 部分片段： interface INotificationManager { void cancelAllNotifications(String pkg, int userId); void clearData(String pkg, int uid, boolean fromApp); void enqueueToast(String pkg, ITransientNotification callback, int duration); void cancelToast(String pkg, ITransientNotification callback); void finishToken(String pkg, ITransientNotification callback); void enqueueNotificationWithTag(String pkg, String opPkg, String tag, int id, in Notification notification, int userId); void cancelNotificationWithTag(String pkg, String tag, int id, int userId); // ... 省略 } cancelAllNotifications() 对应的 CODE 就是 1。 service call notification 1 表示清除当前所有的通知，其中 pkg, userId 参数缺省。 service call notification 1 s16 &#39;com.example.package&#39; 表示清除当前所有包名为 com.example.package 的 App 发出的通知。 service call notification 2 s16 &#39;com.example.package&#39; i32 108 i32 1 表示调用 clearData(&quot;com.example.package&quot;, 108, 1); 其中布尔值 true 用 132 1 表示。 小结service call CODE 中的 CODE 根据当前系统版本对应的 aidl 变化而变化，适用于调试，而应用于产品开发则需要充分考虑版本问题。 参考Answer - Where to find description of all ‘/system/bin/service’ calls]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Shell命令</tag>
        <tag>ADB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webview加载本地资源时的多语言国际化问题]]></title>
    <url>%2Fpost%2F1478478287%2F</url>
    <content type="text"><![CDATA[在开发中，有时候 App 的本地资源（如离线 html 文件）等会用 Webview 去加载，如果同时需要考虑多语言国际化问题，应该如何处理呢？ 需求说明比如现在有这样一个需求，一般 App 都有相关的权限申请说明，现在要求用 Webview 去加载本地的 html 资源文件并显示相关权限声明，且支持多语言国际化。 问题分析我们知道，res 目录可以方便进行多语言国际化的支持。那现在可以把权限声明（perm_state.html）文件放置于 /res/raw/ 的不同语言目录中，以实现国际化： 简体中文的支持：/res/raw-zh-rCN/perm_state.html： &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;权限声明&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body { padding: 0 10px; background-color: #0; } a.title { font-size: 16px; font-weight: bold; } a.content { font-size: 14px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;a class=&quot;title&quot;&gt;接收短信（RECEIVE_SMS）&lt;/a&gt;&lt;br/&gt; &lt;a class=&quot;content&quot;&gt;解析短信中的验证码需要能够接收短信权限。&lt;/a&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 默认英文支持：/res/raw/perm_state.html： &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;Permission Statement&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body { padding: 0 10px; background-color: #0; } a.title { font-size: 16px; font-weight: bold; } a.content { font-size: 14px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;a class=&quot;title&quot;&gt;Receive SMS permission&lt;/a&gt;&lt;br/&gt; &lt;a class=&quot;content&quot;&gt;Receive SMS permission should be granted for parsing SMS.&lt;/a&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; ResUtils#loadRawRes 用来加载 /res/raw 资源文件中的内容： public class ResUtils { // ...省略 public static String loadRawRes(Context context, @RawRes int rawId) { InputStream is = null; String data = &quot;&quot;; try { is = context.getResources().openRawResource(rawId); byte[] buffer = new byte[is.available()]; is.read(buffer); data = new String(buffer); } catch (IOException e) { XLog.e(&quot;Error occurs when open raw file, id = &quot; + rawId, e); } finally { if (is != null) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } } return data; } } 接下来就是用 Webview 加载 html 资源文件： public void loadHtmlData() { String data = ResUtils.loadRawData(context, R.raw.perm_state); weview.loadData(data, &quot;text/html&quot;, &quot;utf-8&quot;); } 以上就是一种解决方案，那么，有没有可以优化的空间呢？ 观察到，/res/raw-zh-rCN/perm_state.html 和 /res/raw/perm_state.html 是有相同的 css 样式的，那么能否将 css 样式抽取出来共用呢？当然是可以的 ~ 方案优化把 css 样式抽取出来生成 perm_state_style.css 文件： body { padding: 0 10px; background-color: #0; } a.title { font-size: 16px; font-weight: bold; } a.content { font-size: 14px; } /res/raw-zh-rCN/perm_state.html 修改为： &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;权限声明&lt;/title&gt; &lt;link href=&quot;perm_state_style.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;a class=&quot;title&quot;&gt;接收短信（RECEIVE_SMS）&lt;/a&gt;&lt;br/&gt; &lt;a class=&quot;content&quot;&gt;解析短信中的验证码需要能够接收短信权限。&lt;/a&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 其他的 perm_state.html 修改方式跟上述一致就不再赘述。 WebView 有以下两个方法函数： loadData(String data, String mimeType, String encoding): 直接使用 webview 加载 data 包含的数据。 loadDataWithBaseURL(String baseUrl, String data, String mimeType, String encoding, String historyUrl)： 将 baseUrl 作为基础路径的前提下，使用 webview 加载 data 包含的数据。 我们看到 &lt;link href=&quot;perm_state_style.css&quot;/&gt; 是直接引用的 perm_state_style.css，所以可以使用 loadDataWithBaseURL 方法把 css 文件放置于 baseUrl 所代表的目录下即可实现 html 文件中对 css 样式的引用和加载。 那么，perm_state_style.css 到底放哪儿呢？ 有两种方案。 css 置于 res/raw 目录将 css 置于 /res/raw 目录，即生成 /res/raw/perm_state_style.css。 使用 WebView 加载资源文件： pulic void loadHtmlData() { String data = ResUtils.loadRawData(context, R.raw.perm_state); weview.loadDataWithBaseURL(&quot;file:///android_res/raw/&quot;, data, &quot;text/html&quot;, &quot;utf-8&quot;, null); } 但是如果生成的 Apk 是经过混淆的话，这种方案需要在混淆文件中加入如下配置（至于为什么要这样做，暂未可知）： -keepclassmembers class **.R$* { public static &lt;fields&gt;; } -keep class **.R$* 这种方式 perm_state.html 和 perm_state_style.css 基本在同一目录，结构清晰，但是会在最终混淆过后生成的 Apk 中保留 R.java 文件，会稍微增加 Apk 最终大小。 css 置于 assets 目录将 css 置于 /assets 目录，即生成 /assets/perm_state_style.css。 使用 WebView 加载资源文件： public void loadHtmlData() { String data = ResUtils.loadRawData(context, R.raw.perm_state); weview.loadDataWithBaseURL(&quot;file:///android_asset/&quot;, data, &quot;text/html&quot;, &quot;utf-8&quot;, null); } 这种方式 perm_state.html 和 perm_state_style.css 不在同一目录，结构不太清晰，但是因为没有混淆限制，不会在最终 Apk 中生成 R.java 文件，稍微减少 Apk 最终大小。 孰优孰劣，暂未可知。 相关源码请参考个人项目 SmsCodeExtractor 参考File under /res/raw not accessible in Debug buildvariant]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>i18n</tag>
        <tag>Webview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xposed开发之短信Hook]]></title>
    <url>%2Fpost%2F2799676006%2F</url>
    <content type="text"><![CDATA[我的 Xposed 模块 - 短信验证码提取 中比较关键的就是如何通过 Hook 短信接收过程，并获取短信内容。 在前一篇文章（Android O SMS 接收过程源码分析）已经分析了 Android O 上的短信接收过程。其他版本的源码分析便不再展开，核心思路基本一致，都是通过状态机中不同状态之间的转换，对不同类型的事件消息进行处理，从而完成对新短信的接收、广播等操作。 Xposed 开发中，下面几点很重要： Hook 的方法函数在保证一定会被调用的同时，要尽量保证不是被频繁调用的，能精准打击就不要无差别范围攻击。能达到这一效果，就能很好地提升性能。 Hook 的方法尽量保证在不同版本上保持一致，当然也不排除可能因为版本大更迭，方法签名都发生巨大变化，这时就需要针对不同版本来进行不同的 Hook 操作了。 如何做到以上两点，其实就是阅读源码。这是最简单最有效的方法，却又是最困难最麻烦的方法（阅读源码确实麻烦，有时候往往会陷于各种细节之处无法自拔）。 通过阅读和比较从 4.4 到 8.1 系统中关于短信接收源码，可以发现 dispatchIntent() 方法是发送接收到短信过程中最后一道关卡，同时该方法的 Intent intent 参数即为携带了短信数据的参数，所以也能很方便获取短信数据。所以，Hook 短信获取，围绕方法 dispatchIntent() 即可。 编码实现： public class SmsHandlerHook implements IHook { private static final String TELEPHONY_PACKAGE = &quot;com.android.internal.telephony&quot;; private static final String SMS_HANDLER_CLASS = TELEPHONY_PACKAGE + &quot;.InboundSmsHandler&quot;; private static final String SMSCODE_PACKAGE = BuildConfig.APPLICATION_ID; private Context mModContext; @Override public void onLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable { if (&quot;com.android.phone&quot;.equals(lpparam.packageName)) { XLog.i(&quot;SmsCode initializing&quot;); printDeviceInfo(); try { hookSmsHandler(lpparam); } catch (Throwable e) { XLog.e(&quot;Failed to hook SmsHandler&quot;, e); throw e; } XLog.i(&quot;SmsCode initialize completely&quot;); } } @SuppressWarnings(&quot;deprecation&quot;) private static void printDeviceInfo() { XLog.i(&quot;Phone manufacturer: %s&quot;, Build.MANUFACTURER); XLog.i(&quot;Phone model: %s&quot;, Build.MODEL); XLog.i(&quot;Android version: %s&quot;, Build.VERSION.RELEASE); int xposedVersion; try { xposedVersion = XposedBridge.getXposedVersion(); } catch (Throwable e) { xposedVersion = XposedBridge.XPOSED_BRIDGE_VERSION; } XLog.i(&quot;Xposed bridge version: %d&quot;, xposedVersion); XLog.i(&quot;SmsCode version: %s (%d)&quot;, BuildConfig.VERSION_NAME, BuildConfig.VERSION_CODE); } private void hookSmsHandler(XC_LoadPackage.LoadPackageParam lpparam) { hookConstructor(lpparam); hookDispatchIntent(lpparam); } private void hookConstructor(XC_LoadPackage.LoadPackageParam lpparam) { if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) { hookConstructor24(lpparam); } else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) { hookConstructor19(lpparam); } } private void hookConstructor24(XC_LoadPackage.LoadPackageParam lpparam) { XLog.i(&quot;Hooking InboundSmsHandler constructor for android v24+&quot;); XposedHelpers.findAndHookConstructor(SMS_HANDLER_CLASS, lpparam.classLoader, /* name */ String.class, /* context */ Context.class, /* storageMonitor */ TELEPHONY_PACKAGE + &quot;.SmsStorageMonitor&quot;, /* phone */ TELEPHONY_PACKAGE + &quot;.Phone&quot;, /* cellBroadcastHandler */ TELEPHONY_PACKAGE + &quot;.CellBroadcastHandler&quot;, new ConstructorHook()); } private void hookConstructor19(XC_LoadPackage.LoadPackageParam lpparam) { XLog.i(&quot;Hooking InboundSmsHandler constructor for Android v19+&quot;); XposedHelpers.findAndHookConstructor(SMS_HANDLER_CLASS, lpparam.classLoader, /* name */ String.class, /* context */ Context.class, /* storageMonitor */ TELEPHONY_PACKAGE + &quot;.SmsStorageMonitor&quot;, /* phone */ TELEPHONY_PACKAGE + &quot;.PhoneBase&quot;, /* cellBroadcastHandler */ TELEPHONY_PACKAGE + &quot;.CellBroadcastHandler&quot;, new ConstructorHook()); } private void hookDispatchIntent(XC_LoadPackage.LoadPackageParam lpparam) { if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { hookDispatchIntent23(lpparam); } else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) { hookDispatchIntent21(lpparam); } else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) { hookDispatchIntent19(lpparam); } } private void hookDispatchIntent19(XC_LoadPackage.LoadPackageParam lpparam) { XLog.i(&quot;Hooking dispatchIntent() for Android v19+&quot;); XposedHelpers.findAndHookMethod(SMS_HANDLER_CLASS, lpparam.classLoader, &quot;dispatchIntent&quot;, /* intent */ Intent.class, /* permission */ String.class, /* appOp */ int.class, /* resultReceiver */ BroadcastReceiver.class, new DispatchIntentHook(3)); } private void hookDispatchIntent21(XC_LoadPackage.LoadPackageParam lpparam) { XLog.i(&quot;Hooking dispatchIntent() for Android v21+&quot;); XposedHelpers.findAndHookMethod(SMS_HANDLER_CLASS, lpparam.classLoader, &quot;dispatchIntent&quot;, /* intent */ Intent.class, /* permission */ String.class, /* appOp */ int.class, /* resultReceiver */ BroadcastReceiver.class, /* user */ UserHandle.class, new DispatchIntentHook(3)); } private void hookDispatchIntent23(XC_LoadPackage.LoadPackageParam lpparam) { XLog.i(&quot;Hooking dispatchIntent() for Android v23+&quot;); XposedHelpers.findAndHookMethod(SMS_HANDLER_CLASS, lpparam.classLoader, &quot;dispatchIntent&quot;, /* intent */ Intent.class, /* permission */ String.class, /* appOp */ int.class, /* opts */ Bundle.class, /* resultReceiver */ BroadcastReceiver.class, /* user */ UserHandle.class, new DispatchIntentHook(4)); } private class ConstructorHook extends XC_MethodHook { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { try { afterConstructorHandler(param); } catch (Throwable e) { XLog.e(&quot;Error occurred in constructor hook&quot;, e); throw e; } } } private void afterConstructorHandler(XC_MethodHook.MethodHookParam param) { Context context = (Context) param.args[1]; if (mModContext == null) { mModContext = context; } } private class DispatchIntentHook extends XC_MethodHook { private final int mReceiverIndex; DispatchIntentHook(int receiverIndex) { mReceiverIndex = receiverIndex; } @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { try { beforeDispatchIntentHandler(param, mReceiverIndex); } catch (Throwable e) { XLog.e(&quot;Error occurred in dispatchIntent() hook, &quot;, e); throw e; } } } private void beforeDispatchIntentHandler(XC_MethodHook.MethodHookParam param, int receiverIndex) { // 此 intent 即为携带短信数据的 intent Intent intent = (Intent) param.args[0]; String action = intent.getAction(); // 过滤掉 SMS_DELIVER_ACTION 之外的 Action if (!Telephony.Sms.Intents.SMS_DELIVER_ACTION.equals(action)) { return; } // 发送广播，让接收者处理短信数据 Intent broadcastIntent = new Intent(); broadcastIntent.setComponent(new ComponentName(SMSCODE_PACKAGE, SmsCodeReceiver.class.getName())); broadcastIntent.putExtra(SmsCodeService.EXTRA_KEY_SMS_INTENT, intent); mModContext.sendBroadcast(broadcastIntent); } } 代码开源在 XposedSmsCode 参考 NekoSMS]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>SMS</tag>
        <tag>Xposed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android O SMS 接收过程源码分析]]></title>
    <url>%2Fpost%2F2078965013%2F</url>
    <content type="text"><![CDATA[Android O (8.0 和 8.1) 起，Google 开启了 Project Treble 计划，引入了新的系统架构模式 Treble。 关于 Treble 架构，详情请参考: Treble Project Treble是Android升级的最终方案吗？ Android Treble架构解析 简单来说，宏观上，Treble 之前的 Android 设备更新系统时，在更新上层系统之前必须先更新底层供应商（Vendor）的硬件支持代码，这很麻烦，新系统往往不能得到及时更新，Treble 将 Vendor(芯片供应制造商编写的设备专属底层代码) 和 Android 系统代码分离，这样就规避之前版本的问题。 HAL (Hardware Abstract Layer - 硬件抽象层) 将硬件设备和 Android 操作系统分割开来，负责硬件设备和操作系统的通信。Android O 起，HAL 的硬件组件得到划分，比如音频，无线电频。这些底层的硬件划分通过 HIDL (HAL interface defination language - HAL接口定义语言) 和上层的操作系统中的系统服务进行通信。目前有数十个不同的 HIDL接口包，其中 HIDL 也是通过 Binder 实现通信的。 HIDL 和 AIDL 很相似，具体语法有区别，但核心都是通过 Binder 实现通讯 RIL (Radio interface layer - 无线接口层) 用于提供电话通信（Telephony）服务，其中也包括了 SMS，而 RIL 是位于 HAL 层的。所以 Android O 起，RIL 的通信方式由之前的 Socket 通信变成了 Binder 通信。 关于 RIL 的底层逻辑，详情参考 Android 8.0 RIL框架分析 RIL 源码分析这里用 Android 8.1 (api 27) 的源码来进行分析。 RIL 借由 IRadioIndication 和 IRadioResponse 定义了 HIDL 接口，建立起 HAL 层和 framework 层的 RIL 通信交互。在 Framework 层，由 RadioIndication 和 RadioResponse 分别实现了该 HIDL 接口： // RadioIndication 用于处理 RIL 底层发起的消息 public class RadioIndication extends IRadioIndication.Stub { // ...省略 } // RadioResponse 用于对 RIL 底层进行响应，回馈消息， public class RadioResponse extends IRadioResponse.Stub { // ...省略 } 无线通信制式有 CDMA 和 GSM ，在 Android 系统中也有对应的编码实现。 GSM 制式下的 SMS 接收过程GSM 制式下，新短信到来，会调用 RadionIndication#newSms()： public class RadionIndication extends IRadioIndication.Stub { RIL mRil; RadioIndication(RIL ril) { mRil = ril; } public void newSms(int indicationType, ArrayList&lt;Byte&gt; pdu) { // 根据 indication 类型，用于必要时获取唤醒锁和发送ACK消息 mRil.processIndication(indicationType); byte[] pduArray = RIL.arrayListToPrimitiveArray(pdu); if (RIL.RILJ_LOGD) mRil.unsljLog(RIL_UNSOL_RESPONSE_NEW_SMS); mRil.writeMetricsNewSms(SmsSession.Event.Tech.SMS_GSM, SmsSession.Event.Format.SMS_FORMAT_3GPP); // 解析出 SmsMessage 实体 SmsMessage sms = SmsMessage.newFromCMT(pduArray); if (mRil.mGsmSmsRegistrant != null) { // 通知给 RIL 中的 GSM 注册者 mRil.mGsmSmsRegistrant.notifyRegistrant(new AsyncResult(null, sms, null)); } } } 解析出 SmsMessage 对象后，将短信数据封装在 AsyncResult 对象并通知给相应的 GSM 注册者。 RIL 的 mGsmSmsRegistrant 是 Registrant 对象： public class Registrant { WeakReference refH; int what; Object userObj; public Registrant(Handler h, int what, Object obj) { refH = new WeakReference(h); this.what = what; userObj = obj; } // ...省略 // 通知注册者 public void notifyRegistrant(AsyncResult ar) { internalNotifyRegistrant (ar.result, ar.exception); } // 本质上使用 Handler 进行消息通知 void internalNotifyRegistrant (Object result, Throwable exception) { Handler h = getHandler(); if (h == null) { clear(); } else { Message msg = Message.obtain(); msg.what = what; msg.obj = new AsyncResult(userObj, result, exception); h.sendMessage(msg); } } public Handler getHandler() { if (refH == null) return null; return (Handler) refH.get(); } } 可以看出，Registrant 其实就是借由 Handler 发送消息，携带 SMS 信息的 AsyncResult 的消息则是在 Handler#handleMessage() 中被处理。而 Handler 是在 Registrant 的构造函数中被引用的，我们需要看 Handler 到底是哪个，就需要看 Ril 的 mGsmSmsRegistrant 在哪里被初始化。 RIL 继承自 BaseCommands，通过调用 setOnNewGsmSms 实现 mGsmSmsRegistrant 的初始化。 public abstract class BaseCommands implements CommandsInterface { protected Registrant mGsmSmsRegistrant; // ...省略 // 初始化 Gsm SMS 的 Registrant @Override public void setOnNewGsmSms(Handler h, int what, Object obj) { mGsmSmsRegistrant = new Registrant (h, what, obj); } } &nbsp;而 setOnNewGsmSms 在 GsmInboundSmsHandler 的构造函数中被调用： public class GsmInboundSmsHandler extends InboundSmsHandler { private GsmInboundSmsHandler(Context context, SmsStorageMonitor storageMonitor, Phone phone) { super(&quot;GsmInboundSmsHandler&quot;, context, storageMonitor, phone, GsmCellBroadcastHandler.makeGsmCellBroadcastHandler(context, phone)); // 初始化 Gsm SMS 的 Registrant，该注册者只关注类型为 EVENT_NEW_SMS 的事件 phone.mCi.setOnNewGsmSms(getHandler(), EVENT_NEW_SMS, null); mDataDownloadHandler = new UsimDataDownloadHandler(phone.mCi); } } 从以上分析可以看出， GsmInboundSmsHandler 注册的 Registrant 对象只关注 EVENT_NEW_SMS 事件，并且在 RadioIndication#newSms() 中也会发送 EVENT_NEW_SMS 事件消息。 我们现在来看一下 GsmInboundSmsHandler 的继承关系，GsmInboundSmsHandler 继承自 InboundSmsHanlder，而 InboundSmsHandler 继承自 StateMachine， 这里的 StateMachine 就是 有限状态机，状态机里面的不同状态（State）可以在特定条件下进行相互转换。那么，这里的 StateMachine 类是如何实现状态机的呢？ public class StateMachine { // ... 省略 private static class SmsHandler extends Handler { /** * 通过调用 State 的 processMessage 方法去处理发送至此状态机的消息。 */ @Override public final void handleMessage(Message msg) { if (!mHasQuit) { // ...省略 if (mIsConstructionCompleted) { // 处理消息 msgProcessedState = processMsg(msg); } // ...省略 // 根据当前状态，执行相应的状态变化操作，即状态迁移 performTransitions(msgProcessState, msg); } } /** * 处理消息，执行 State 的 processMessage 方法，如果当前状态无法处理，则调用父状态进行处理，以类推 * @return 返回处理了当前消息的状态 */ private final State processMsg(Message msg) { // ... 省略 // 用当前状态处理消息，无法处理则循环下去 while (!curStateInfo.state.processMessage(msg)) { curStateInfo = curStateInfo.parentStateInfo; if (curStateInfo == null) { mSm.unhandledMessage(msg); break; } //... 省略 } return (curStateInfo != null) ? curStateInfo.state : null; } // 根据处理了该消息的状态信息，执行相关状态迁移。 private void performTransitions(State msgProcessedState, Message msg) { // ... 省略 } // 执行状态转移 private final void transitionTo(IState destState) { // ... 忽略 } // 在当前状态机中添加状态，需要指明其父状态 private void addState(State state, State parent) { // ... 忽略 } } private SmsHandler mSmsHandler; public final Handler getHandler() { return mSmsHandler; } protected StateMachine(String name, Looper looper) { initStateMachine(name, looper); } private void initStateMachine(String name, Looper looper) { mName = name; mSmHandler = new SmHandler(looper, this); } } public interface IState { // 进入状态 void enter(); // 退出状态 void exit(); // 处理状态 boolean processMessage(Message msg); // ...省略 } public class State implements IState { // ...省略 } 通过上面的源码可以看出来，StateMachine 其实就是通过 Handler 去实现的，通过 handleMessage() 来处理当前状态，通过 transitionTo() 来进行状态迁移，通过 addState() 来进行状态机中状态的添加。而 GsmInboundSmsHandler 初始化方法中的 getHandler() 返回的就是 StateMachine 中的 SmsHandler 对象 mSmsHandler。 接下来看一下状态机中初始时，添加了哪些状态，在 InboundSmsHandler 构造函数中： public abstract class InboundSmsHanlder extends StateMachine { protected InboundSmsHandler(String name, Context context, SmsStorageMonitor storageMonitor, Phone phone, CellBroadcastHandler cellBroadcastHandler) { super(name); // 添加默认状态 addState(mDefaultState); // 添加 启动状态 - StartupState addState(mStartupState, mDefaultState); // 添加 空闲状态 - IdleState addState(mIdleState, mDefaultState); // 添加 分发状态 - DeliveringState addState(mDeliveringState, mDefaultState); // 添加 等待状态 - WaitingState addState(mWaitingState, mDeliveringState); // 设置初始状态为 StartupState setInitialState(mStartupState); } } &nbsp;初始状态是 StartupState： private class StartupState extends State { // ...省略 @Override public boolean processMessage(Message msg) { log(&quot;StartupState.processMessage:&quot; + msg.what); switch (msg.what) { // ...省略 case EVENT_START_ACCEPTING_SMS: // 类型为 EVENT_START_ACCEPTING_SMS 的信息发送后，进入 IdleState transitionTo(mIdleState); return HANDLED; // ...省略 } } } &nbsp;而在 GsmInboundSmsHandler 初始化之后，就会发送 EVENT_START_ACCEPTING_SMS 消息： public class ImsSMSDispatcher extends SMSDispatcher { public ImsSMSDispatcher(Phone phone, SmsStorageMonitor storageMonitor, SmsUsageMonitor usageMonitor) { super(phone, usageMonitor, null); // Create dispatchers, inbound SMS handlers and // broadcast undelivered messages in raw table. mCdmaDispatcher = new CdmaSMSDispatcher(phone, usageMonitor, this); // 初始化 GsmInboundSmsHandler mGsmInboundSmsHandler = GsmInboundSmsHandler.makeInboundSmsHandler(phone.getContext(), storageMonitor, phone); // 初始化 GsmInboundSmsHandler mCdmaInboundSmsHandler = CdmaInboundSmsHandler.makeInboundSmsHandler(phone.getContext(), storageMonitor, phone, (CdmaSMSDispatcher) mCdmaDispatcher); mGsmDispatcher = new GsmSMSDispatcher(phone, usageMonitor, this, mGsmInboundSmsHandler); // 发送初始化信息 SmsBroadcastUndelivered.initialize(phone.getContext(), mGsmInboundSmsHandler, mCdmaInboundSmsHandler); InboundSmsHandler.registerNewMessageNotificationActionHandler(phone.getContext()); } } public class SmsBroadcastUndelivered { // ...省略 public static void initialize(Context context, GsmInboundSmsHandler gsmInboundSmsHandler, CdmaInboundSmsHandler cdmaInboundSmsHandler) { if (instance == null) { instance = new SmsBroadcastUndelivered( context, gsmInboundSmsHandler, cdmaInboundSmsHandler); } if (gsmInboundSmsHandler != null) { // GsmInboundSmsHandler 发送 EVENT_START_ACCEPTING_SMS 消息 gsmInboundSmsHandler.sendMessage(InboundSmsHandler.EVENT_START_ACCEPTING_SMS); } if (cdmaInboundSmsHandler != null) { // CdmaInboundSmsHandler 发送 EVENT_START_ACCEPTING_SMS 消息 cdmaInboundSmsHandler.sendMessage(InboundSmsHandler.EVENT_START_ACCEPTING_SMS); } } } &nbsp;所以在 GsmInboundSmsHandler 发送 EVENT_START_ACCEPTING_SMS 之后，状态机进入 IdleState 状态： private class IdleState extends State { // ...省略 @Override public boolean processMessage(Message msg) { log(&quot;IdleState.processMessage:&quot; + msg.what); if (DBG) log(&quot;Idle state processing message type &quot; + msg.what); switch (msg.what) { case EVENT_NEW_SMS: case EVENT_INJECT_SMS: case EVENT_BROADCAST_SMS: deferMessage(msg); transitionTo(mDeliveringState); return HANDLED; // ...省略 } } } &nbsp;在之前的分析中说到，RadioIndication#newSms() 发送 EVENT_NEW_SMS 事件消息，所以在接收到该消息之后，IdleState 状态会进入到 DeliveringState 状态： private class DeliveringState extends State { // ...省略 @Override public boolean processMessage(Message msg) { switch (msg.what) { case EVENT_NEW_SMS: // 处理新短信 handleNewSms((AsyncResult) msg.obj); sendMessage(EVENT_RETURN_TO_IDLE); return HANDLED; // ...省略 } } } &nbsp;DeliveringState 状态下，接收到 EVENT_NEW_SMS 消息事件，会执行 handleNewSms() 方法，接下来看下该方法： public abstract class InboundSmsHandler { // 处理新信息 private void handleNewSms(AsyncResult ar) { // ...省略 try { SmsMessage sms = (SmsMessage) ar.result; result = dispatchMessage(sms.mWrappedSmsMessage); } catch (RuntimeException ex) { // ... } // ...省略 } private int dispatchMessage(SmsMessageBase smsb) { // ...省略 return dispatchMessageRadioSpecific(smsb); } protected abstract int dispatchMessageRadioSpecific(SmsMessageBase smsb); protected int dispatchNormalMessage(SmsMessageBase sms) { SmsHeader smsHeader = sms.getUserDataHeader(); InboundSmsTracker tracker; // 初始化并获取 InboundSmsTracker 对象 if ((smsHeader == null) || (smsHeader.concatRef == null)) { tracker = TelephonyComponentFactory.getInstance().makeInboundSmsTracker(sms.getPdu(), sms.getTimestampMillis(), destPort, is3gpp2(), false, sms.getOriginatingAddress(), sms.getDisplayOriginatingAddress(), sms.getMessageBody()); } else { // ... tracker = TelephonyComponentFactory.getInstance().makeInboundSmsTracker(sms.getPdu(), sms.getTimestampMillis(), destPort, is3gpp2(), sms.getOriginatingAddress(), sms.getDisplayOriginatingAddress(), concatRef.refNumber, concatRef.seqNumber, concatRef.msgCount, false, sms.getMessageBody()); } return addTrackerToRawTableAndSendMessage(tracker, tracker.getDestPort() == -1); } } public class GsmInboundSmsHandler extends InboundSmsHandler { protected int dispatchMessageRadioSpecific(SmsMessageBase smsb) { // ...省略 return dispatchNormalMessage(smsb); } } 从上面的源码中可以看出，handleNewSms() 调用链为 handleNewSms() -&gt; dispatchMessage() -&gt; dispatchMessageRadioSpecific() -&gt; dispatchNormalMessage() -&gt; addTrackerToRawTableAndSendMessage()。 接着看 addTrackerToRawTableAndSendMessage() 方法： protected int addTrackerToRawTableAndSendMessage(InboundSmsTracker tracker, boolean deDup) { switch(addTrackerToRawTable(tracker, deDup)) { // 插入短信数据库 case Intents.RESULT_SMS_HANDLED: sendMessage(EVENT_BROADCAST_SMS, tracker); return Intents.RESULT_SMS_HANDLED; case Intents.RESULT_SMS_DUPLICATED: return Intents.RESULT_SMS_HANDLED; case Intents.RESULT_SMS_GENERIC_ERROR: default: return Intents.RESULT_SMS_GENERIC_ERROR; } } private int addTrackerToRawTable(InboundSmsTracker tracker, boolean deDup) { if (deDup) { // 处理短信冗余重复的逻辑 try { if (duplicateExists(tracker)) { return Intents.RESULT_SMS_DUPLICATED; // reject message } } catch (SQLException e) { return Intents.RESULT_SMS_GENERIC_ERROR; // reject message } } String address = tracker.getAddress(); String refNumber = Integer.toString(tracker.getReferenceNumber()); String count = Integer.toString(tracker.getMessageCount()); ContentValues values = tracker.getContentValues(); // 插入短信数据库 Uri newUri = mResolver.insert(sRawUri, values); try { long rowId = ContentUris.parseId(newUri); if (tracker.getMessageCount() == 1) { // set the delete selection args for single-part message tracker.setDeleteWhere(SELECT_BY_ID, new String[]{Long.toString(rowId)}); } else { // set the delete selection args for multi-part message String[] deleteWhereArgs = {address, refNumber, count}; tracker.setDeleteWhere(tracker.getQueryForSegments(), deleteWhereArgs); } // 成功插入新短信数据到短信数据库，则返回 RESULT_SMS_HANDLED return Intents.RESULT_SMS_HANDLED; } catch (Exception e) { loge(&quot;error parsing URI for new row: &quot; + newUri, e); return Intents.RESULT_SMS_GENERIC_ERROR; } } 上述源码中，先执行 addTrackerToRawTable() 来试图将新短信数据插入到短信数据库，根据该方法返回的结果进而返回不同的值。插入成功后，返回 Intents.RESULT_SMS_HANDLED，并通过 sendMessage(EVENT_BROADCAST_SMS, tracker) 发送 EVENT_BROADCAST_SMS 事件。 相同的思路，EVENT_BROADCAST_SMS 事件最终还是会在 DeliveringState 状态时被处理： private class DeliveringState extends State { // ...省略 @Override public boolean processMessage(Message msg) { switch (msg.what) { // ...省略 case EVENT_BROADCAST_SMS: InboundSmsTracker inboundSmsTracker = (InboundSmsTracker) msg.obj; if (processMessagePart(inboundSmsTracker)) { sendMessage(EVENT_UPDATE_TRACKER, inboundSmsTracker); transitionTo(mWaitingState); } else { sendMessage(EVENT_RETURN_TO_IDLE); } return HANDLED; } } } &nbsp;EVENT_BROADCAST_SMS 事件到来，会执行 processMessagePart() 方法： private boolean processMessagePart(InboundSmsTracker tracker) { // ...省略 // Sms 的 BroadcastReceiver，接收系统广播，经过一定处理后，将短信广播继续向下分发广播 SmsBroadcastReceiver resultReceiver = new SmsBroadcastReceiver(tracker); boolean filterInvoked = filterSms(pdus, destPort, tracker, resultReceiver, true ); if (!filterInvoked) { // 分发 Sms 投递意图 dispatchSmsDeliveryIntent(pdus, tracker.getFormat(), destPort, resultReceiver); } // ...省略 } private void dispatchSmsDeliveryIntent(byte[][] pdus, String format, int destPort, SmsBroadcastReceiver resultReceiver) { Intent intent = new Intent(); intent.putExtra(&quot;pdus&quot;, pdus); intent.putExtra(&quot;format&quot;, format); if (destPort == -1) { intent.setAction(Intents.SMS_DELIVER_ACTION); // 先看系统没有默认的短信App ComponentName componentName = SmsApplication.getDefaultSmsApplication(mContext, true); if (componentName != null) { // 系统默认的短信App存在，则仅给该App发送 SMS_DELIVER_ACTION 广播 intent.setComponent(componentName); } else { // 否则向所有的相关 Receiver 发送 SMS_DELIVER_ACTION 广播 intent.setComponent(null); } // ...省略 } else { intent.setAction(Intents.DATA_SMS_RECEIVED_ACTION); Uri uri = Uri.parse(&quot;sms://localhost:&quot; + destPort); intent.setData(uri); intent.setComponent(null); // Allow registered broadcast receivers to get this intent even // when they are in the background. intent.addFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND); } Bundle options = handleSmsWhitelisting(intent.getComponent()); // 分发广播意图 dispatchIntent(intent, android.Manifest.permission.RECEIVE_SMS, AppOpsManager.OP_RECEIVE_SMS, options, resultReceiver, UserHandle.SYSTEM); } public void dispatchIntent(Intent intent, String permission, int appOp, Bundle opts, BroadcastReceiver resultReceiver, UserHandle user) { // ...省略 // 发送广播 mContext.sendOrderedBroadcastAsUser(intent, user, permission, appOp, opts, resultReceiver, getHandler(), Activity.RESULT_OK, null, null); } 通过调用链：processMessagePart() -&gt; dispatchSmsDeliveryIntent() -&gt; dispatchIntent() 最终向系统发送相关短信广播。至此，Gsm 制式下的 Android 系统短信接收和广播发送过程基本分析完毕。 CDMA 制式下的 SMS 接收过程CDMA 制式下，新短信到来，会调用 RadionIndication#cdmaNewSms()： public class RadionIndication extends IRadioIndication.Stub { RIL mRil; RadioIndication(RIL ril) { mRil = ril; } public void cdmaNewSms(int indicationType, CdmaSmsMessage msg) { mRil.processIndication(indicationType); mRil.writeMetricsNewSms(SmsSession.Event.Tech.SMS_CDMA, SmsSession.Event.Format.SMS_FORMAT_3GPP2); SmsMessage sms = SmsMessageConverter.newSmsMessageFromCdmaSmsMessage(msg); if (mRil.mCdmaSmsRegistrant != null) { mRil.mCdmaSmsRegistrant.notifyRegistrant(new AsyncResult(null, sms, null)); } } } 同样也会通过 mRil.mCdmaSmsRegistrant.notifyRegistrant 来通知给 CDMA 相关的 Registrant 对象。接下来流程和 GSM 制式下的流程基本一致，就不再详述了。 参考 Android6.0的SMS(短信）源码分析–短信接收 Treble Project Treble是Android升级的最终方案吗？ Android Treble架构解析 Android 8.0 RIL框架分析 RIL]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>SMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xposed开发之检查模块是否启用]]></title>
    <url>%2Fpost%2F3879534821%2F</url>
    <content type="text"><![CDATA[个人开发的 Xposed 模块中，确实有检查自己模块是否已启用的需求，那么该如何实现呢？ 思路分析最直接思路就是直接去 Xposed Installer 的模块列表里面，自己的模块是否已被勾选。那么， Xposed Installer 有提供相关 api 调用来返回某模块是否被勾选吗？答案是，没有。 那么，能不能 Hook Xposed Installer 的模块列表界面，从而获取是否被勾选呢？ 想到这里的时候其实是把此问题复杂化了：只要能 Hook 成功了，就说明自己模块已经启用了，那么何不 Hook 自己的模块应用本身呢？ 这样也避免了还需要去逆向 Xposed Installer 的麻烦。 想到这里，其实整个问题都已经迎刃而解了。 编程实现当前模块相关的工具类 ModuleUtils public class ModuleUtils { private ModuleUtils() {} /** * 返回模块版本 * 注意：该方法被本模块Hook住，返回的值是 BuildConfig.MODULE_VERSION，如果没被Hook则返回-1 */ private static int getModuleVersion() { return -1; } /** * 当前模块是否在XposedInstaller中被启用 */ public static boolean isModuleEnabled() { return getModuleVersion() &gt; 0; } } ModuleUtils.isModuleEnabled() 正常条件下一定是返回 false 的，而我们接下来要做的就是去 Hook getModuleVersion() 方法，让其在已启用的情况下返回正值，这样就能通过 isModuleEnabled() 判断模块是否已经启用了。 ModuleUtilsHook 用来 Hook ModuleUtils： public class ModuleUtilsHook implements IXposedHookLoadPackage { private static final String SMSCODE_PACKAGE = BuildConfig.APPLICATION_ID; private static final int MODULE_VERSION = BuildConfig.MODULE_VERSION; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable { if (SMSCODE_PACKAGE.equals(lpparam.packageName)) { try { XLog.i(&quot;Hooking current Xposed module status...&quot;); hookModuleUtils(lpparam); } catch (Throwable e) { XLog.e(&quot;Failed to hook current Xposed module status.&quot;); } } } private void hookModuleUtils(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable { String className = ModuleUtils.class.getName(); XposedHelpers.findAndHookMethod(className, lpparam.classLoader, &quot;getModuleVersion&quot;, XC_MethodReplacement.returnConstant(MODULE_VERSION)); } } 其中上面的 MODULE_VERSION 是在项目 module 的 build.gradle 自定义的： android { // ... defaultConfig { // ... buildConfigField(&quot;int&quot;, &quot;MODULE_VERSION&quot;, &quot;18&quot;) } } 最后，因为 ModuleUtilsHook 在 Hook 过程中用到了反射，所以不应该混淆 ModuleUtils 的 getModuleVersion 方法： -keep class com.github.tianma8023.xposed.smscode.utils.ModuleUtils { int getModuleVersion(); } 源码请戳 ModuleUtilsHook]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Xposed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xposed开发之微信赞赏]]></title>
    <url>%2Fpost%2F790893590%2F</url>
    <content type="text"><![CDATA[个人开发者开发出来的 App，经常会见到微信赞赏（或者捐赠）入口。这个是如何实现的呢？一般有以下方案： 一般的个人 App 是不会接入微信/支付宝 SDK 的，因为 SDK 嵌入成本高，也会增加不小的 APK 体积，应用市场审核一般也是通过不了的。 而微信对通过直接使用相应的 URI 传参跳转至微信相应捐赠页面是不可行的。 众多独立 App 开发者就采取迂回策略，通过 App 内嵌收款二维码 或者 赞赏码图片，把图片放到相册中，并跳转至微信扫一扫界面，通过引导用户从相册中选取相应的二维码图片，达到曲线救国的目的。 以上方案中，只有方案 3 可行，看起来挺麻烦的，但不失为一种有效的方案。 那么，如果让强大的 Xposed 来做，会不会有其他的方式呢？因为的解决方案中有很致命的点在于，需要引导用户自己去选取二维码图片从而实现迂回跳转到捐赠/转账页面，这一系列操作中交互很多，其实是很不方便的。 Xposed 能越过这些麻烦的操作的同时也能达到最终目的吗？ 原理分析从上面可行的 方案3 中，以微信赞赏为例，赞赏时的界面如下： 微信赞赏界面 其 Activity 为 QrRewardSelectMoneyUI，因为该 Activity 没有暴露给其他第三方 App 进行调用，所以上面的 方案2 是不可行的，而是需要通过微信内部其他 Activity 实现跳转。 实质上就是微信内部 Activity 带着相关的参数跳转到赞赏界面，其本质就是通过 Intent 携带相关参数，启动目标赞赏 Activity。 那么 Xposed 实现微信捐赠的思路就来了： 用户点击 App 中的微信赞赏时，跳转至微信的主界面 com.tencent.mm.ui.LauncherUI Hook 主界面的 onCreate 方法，在 Intent 中添加相关参数，跳转至捐赠界面 com.tencent.mm.plugin.collect.reward.ui.QrRewardSelectMoneyUI，并销毁主界面 Activity。 为了以防万一，Hook QrRewardSelectMoneyUI 的 onCreate 方法，已确保相关参数正确传递。完工。 那么，启动 QrRewardSelectMoneyUI 时到底需要传递哪些参数呢？ 这时就可以通过反编译查看源码，或者通过 Xposed Hook 的方式，进行相关参数的获取。 技术实现常量类 Const： public interface Const { String WECHAT_PACKAGE_NAME = &quot;com.tencent.mm&quot;; String WECHAT_LAUNCHER_UI = WECHAT_PACKAGE_NAME + &quot;.ui.LauncherUI&quot;; String WECHAT_QR_REWARD_SELECT_MONEY_UI = WECHAT_PACKAGE_NAME + &quot;.plugin.collect.reward.ui.QrRewardSelectMoneyUI&quot;; String WECHAT_KEY_EXTRA_DONATE = &quot;TianmaDonate&quot;; // 核心参数，可以通过 Xposed Hook 的方式获取参数的值。 String WECHAT_QRCODE_URL = &quot;m01pPa@:hEyGJ5P*a1@$xPI&quot;; } 核心Hook类 DonateWechatHook： public class DonateWechatHook implements IXposedHookLoadPackage { private static final String KEY_SCENE = &quot;key_scene&quot;; private static final String KEY_QRCODE_URL = &quot;key_qrcode_url&quot;; private static final String KEY_CHANNEL = &quot;key_channel&quot;; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable { if (Const.WECHAT_PACKAGE_NAME.equals(lpparam.packageName)) { try { hookLauncherUIOnCreate(lpparam); hookQrRewardSelectMoneyUI(lpparam); } catch (Throwable e) { e.printStackTrace(); } } } /** * Hook com.tencent.mm.ui.LauncherUI#onCreate(); */ private void hookLauncherUIOnCreate(XC_LoadPackage.LoadPackageParam lpparam) { XposedHelpers.findAndHookMethod(Const.WECHAT_LAUNCHER_UI, lpparam.classLoader, &quot;onCreate&quot;, Bundle.class, new LauncherUIOnCreateHook()); } private class LauncherUIOnCreateHook extends XC_MethodHook { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { Activity activity = (Activity) param.thisObject; if (activity != null) { Intent intent = activity.getIntent(); if (intent != null) { ComponentName cn = intent.getComponent(); String className = cn == null ? null : cn.getClassName(); // 自定义的参数，用于区分正常启动微信主界面 boolean hasDonateExtra = intent.hasExtra(Const.WECHAT_KEY_EXTRA_DONATE); if (Const.WECHAT_LAUNCHER_UI.equals(className) &amp;&amp; hasDonateExtra) { // 参数校验成功，则跳转至微信赞赏界面，并销毁主Activity intent.removeExtra(Const.WECHAT_KEY_EXTRA_DONATE); Intent donateIntent = new Intent(); donateIntent.setClassName(activity, Const.WECHAT_QR_REWARD_SELECT_MONEY_UI); donateIntent.putExtra(KEY_SCENE, 2); donateIntent.putExtra(KEY_QRCODE_URL, Const.WECHAT_QRCODE_URL); donateIntent.putExtra(KEY_CHANNEL, 13); donateIntent.putExtra(Const.WECHAT_KEY_EXTRA_DONATE, true); activity.startActivity(donateIntent); activity.finish(); } } } } } /** * Hook com.tencent.mm.plugin.collect.reward.ui.QrRewardSelectMoneyUI#onCreate(); */ private void hookQrRewardSelectMoneyUI(XC_LoadPackage.LoadPackageParam lpparam) { XposedHelpers.findAndHookMethod(Const.WECHAT_QR_REWARD_SELECT_MONEY_UI, lpparam.classLoader, &quot;onCreate&quot;, Bundle.class, new QrRewardSelectMoneyUIOnCreateHook()); } private class QrRewardSelectMoneyUIOnCreateHook extends XC_MethodHook { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { Activity activity = (Activity) param.thisObject; if (activity != null) { Intent intent = activity.getIntent(); if (intent != null) { // 确保参数合法 boolean hasDonateExtra = intent.hasExtra(Const.WECHAT_KEY_EXTRA_DONATE); if (hasDonateExtra) { String qrCodeUrl = intent.getStringExtra(KEY_QRCODE_URL); if (TextUtils.isEmpty(qrCodeUrl)) { intent.putExtra(KEY_QRCODE_URL, Const.WECHAT_QRCODE_URL); } intent.removeExtra(Const.WECHAT_KEY_EXTRA_DONATE); } } } } } } 调用则是正常启动微信主界面，并传递特定参数即可： public void donateByWechat() { Intent intent = new Intent(); intent.setClassName(Const.WECHAT_PACKAGE_NAME, Const.WECHAT_LAUNCHER_UI); intent.putExtra(Const.WECHAT_KEY_EXTRA_DONATE, true); startActivity(intent); } 源码： DoanteWechatHook 参考WechatLuckeyMoney]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Xposed</tag>
        <tag>微信捐赠</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于抄袭开源项目的感想]]></title>
    <url>%2Fpost%2F2854760725%2F</url>
    <content type="text"><![CDATA[昨天，一位用户告诉我，最新 Xposed 仓库上最新版本（2.6.6）的 阻止运行 增加了新的功能：收到短信验证码弹出提示，并自动复制验证码到剪切板。这跟我本人的模块 验证码提取器Xposed 的核心功能之一是重合的。因为考虑到 阻止运行 这款 Xposed 模块本身是专攻对流氓 App 的治理的，新增的这个功能怎么都和其核心业务不搭边，在好奇心的驱使下，我反编译了其 2.6.6 版本的 apk… 谈到开源项目，就应该想到 开源协议（即 开放源代码软件许可证）。开源项目是基于开源协议的，目前有各式各样的开源协议（自由及开放源代码软件许可证比较），以下是其简明的对比图： 开源协议对比图（摘自 阮一峰 博客） 而我开源的 Xposed 模块 - XposedSmsCode，是 GPL 协议的，也就是参考了这个项目代码的其他项目，应该也同样使用 GPL 协议将其开源出来。 然而，反编译 阻止运行(2.6.6) 的 apk 之后，看了其混淆后的代码，我很震惊：这个所谓的新加入的功能，可以说是完完全全抄袭了我已开源的 Xposed 模块中的代码。 以下是对比图（左边是反编译的 阻止运行 的代码，右边是我的源码，点击查看大图）： 1 2 3 4 5 6 7 类似截图中完全一致的地方还有很多，由于代码被混淆了，变量名看不出来是否一致，但类名，甚至是需要打印的日志信息也几乎完全一致，足以见 阻止运行 这款 App 的恶劣而龌龊的行为了。 那么问题来了， 阻止运行 是不是也 开源 并遵循了 GPL 协议了呢？然而并没有，呵呵。劣迹斑斑，昭然于心。阻止运行 也确确实实恶心到我了，我只想说一句：我从未见过如此厚颜无耻之人！！！ 这也让我想起了 Shadowsocks vs ShadowsocksR 以及 黑阈 vs 阻止运行，一切都是那么的相似，一切也都是那么的恶心。 我始终有一个开源的梦想，想为开源社区做点贡献，个人的贡献虽小，但也会积少成多。我开源的目的是为了分享知识，并希望能借此吸引和鼓励更多的开发者加入开源行列中来，并一起维护大家的开源社区。这算是一种情怀吧。然而这真真切切就是我所希望和期盼的…… 最后提一下 阻止运行 的 “光荣历史”，请参考 阻止运行、猎鹰网络、黑域 始末 。至于其他的，我什么都不想说了，sad ~]]></content>
      <categories>
        <category>漫谈</category>
      </categories>
      <tags>
        <tag>抄袭</tag>
        <tag>开源项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 应用关联特定后缀名的文件]]></title>
    <url>%2Fpost%2F2507991710%2F</url>
    <content type="text"><![CDATA[Android 开发中，会碰到一些特殊后缀的文件需要用自家 App 打开，也就是需要 Android 应用关联特定后缀名的文件。 问题分析应用场景比如：App 导出特定后缀名的备份文件，用户在文件浏览器中点击该文件时，需要用自家 App 打开并恢复备份数据。在这里以此为例。当然，适用场景绝不局限于此。 从文件管理器到自家 App，其实就是一个 Intent 传递过程，Intent 所携带的最关键的信息就是 data 信息, 而 data 由 mimeType 和 URI 组成。mimeType 表示文件媒体类型， URI 的结构为： &lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;] 关于此部分信息可参考 data element 或者 data 匹配规则 。 需要解决的问题就变成了：应该怎样配置自家App，才能关联包含特定 URI 的 Intent。其实就等效于 Activity 如何能打开包含指定的 Intent 信息。 Android 7.0 之前，分享文件的 URI 一般是通过如下示例代码得到：File fileToShare = ...; Uri fileUri = Uri.fromFile(fileToShare); 这里的 Uri 是 file:// 格式的。 Android 7.0 起，文件分享加入了更加安全的机制，引入了 FileProvider，获取分享文件的 URI：File fileToShare = ...; Uri fileUri = FileProvider.getUriFromFile(Context, authority, fileToShare); 这里的 Uri 是 content:// 格式的。 再就是要限定特殊的后缀名，除了后缀名之外都不限制，所以路径应该采用 pathPattern 来进行通配符通配。关于 pathPattern 语法： . 表示匹配任意字符； * 表示匹配0到多次； .* 表示匹配任意长度字符串； \ 是转义字符，但在 xml 中用 \\ 来表示。比如用 \\. 表示小数点 .； 解决方案比如，我们的 App 中的 com.example.ActivityA 要支持打开后缀名为 .myext 的文件，其 mimeType 为 text/plain。 通过以上分析，我们需要在 AndroidManifest.xml 中配置： &lt;activity android:name=&quot;com.example.ActivityA&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt; &lt;data android:scheme=&quot;content&quot; android:host=&quot;*&quot; android:pathPattern=&quot;/.*\\.myext&quot; android:mimeType=&quot;text/plain&quot;/&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt; &lt;data android:scheme=&quot;file&quot; android:host=&quot;*&quot; android:pathPattern=&quot;/.*\\.myext&quot; android:mimeType=&quot;text/plain&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 需要注意的是，在接收读取 Uri 为 file:// 形式的文件数据之前，需要获取 READ_EXTERNAL_STORAGE 权限。 content:// 形式的文件数据则不需要该权限。 参考Intents and Intent FiltersAndroid intent filter: associate app with file extensiondat element]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>文件关联</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式 - 分组 & 前瞻 & 后瞻]]></title>
    <url>%2Fpost%2F2202983150%2F</url>
    <content type="text"><![CDATA[之前在处理短信验证码问题的时候，碰到了关于验证码正则的问题，其中涉及到正则表达中的 前瞻（lookahead） 和 后瞻（lookbehind），借此机会总结一下正则表达式的这种高级用法。 问题分析先看以下案例： 您的验证码为 1247 ，请注意查收。 您的验证码为1247，请注意查收。 Your verification code is 1247 . 您的验证码为 124789 ，请注意查收。 针对以上 4 个例子，给出正则表达式，如何才能保证只提取其中的 4 位数验证码，并过滤掉 6 位数的验证码呢？（也就是对于情况123，提取出 1247，对于情况4，则返回无法提取。） 最开始想当然的认为这个正则很好写，[0-9]{4} 就搞定了，然而在匹配第 4 条的时候，匹配出来的结果也是 1247，显然不满足要求。然后再考虑到，4 位数字的字符串两边是有边界的，所以可以用 \b[0-9]{4}\b 来表示，然而这却没办法满足情况 2，在情况 2 下，匹配出来的结果为空。 最后的想法是，只要保证 匹配 4 位数字字符串，且其前后都不再有数字，则可以匹配以上所有情况。要满足这样的需求，则需要引申出 分组 以及 前瞻，后瞻 的概念。 相关概念分组（Group）hellohellohello 针对以上文本，我们可以用 hellohellohello 正则表达式去匹配，更好的写法是 (hello){3}。其中被圆括号 () 括起来的部分称之为 分组。 分组的引用对于一个正则表达式来说，其中的分组是有相应编号（引用）的。 对于文本 ABCDEFG，可以用正则表达式 ((A(BC))((DE)F))G 来匹配： 编号 组 匹配内容 0 (A(BC)(DE)F)G ABCDEFG 1 ((A(BC)(DE)F)) ABCDEF 2 (A(BC)) ABC 3 (BC) BC 4 ((DE)F) DEF 5 (DE) DE 关于分组的编号，其实就是二叉树的前序遍历（根节点 -&gt; 左子树 -&gt; 右子树），排除其中不是分组的部分的即可： 对于 (A(BC)(DE)F)G，我们可以在最外层先一对圆括号： ((A(BC)(DE)F)G) -&gt;0 ↓ ↓ (A(BC)(DE)F) -&gt;1 G ↓ ↓ (A(BC)) -&gt;2 ((DE)F) -&gt;4 ↓ ↓ ↓ ↓ A (BC) -&gt;3 (DE) -&gt;5 F ↓ ↓ BC DE 根据编号 0~5, 可以找到对应编号的分组 分组的种类分组的种类可以分为两大类，即 捕获型分组 和 非捕获型分组: 捕获型分组：将捕获（即匹配）到的内容放进分组中，简单来说 捕获型分组的内容是要进入分组编号 的，用 (pattern) 来表示。上面用到的分组都是捕获型分组。 非捕获型分组： 不将捕获（即匹配）到的内容放进分组中，简单来说 非捕获型分组的内容是不会进入分组编号 的，包括了 (?:pattern)（标准的非捕获型分组）, (?=pattern)（肯定前瞻分组）, (?!pattern)（否定前瞻分组）, (?&lt;=pattern)（肯定后瞻分组）, (?&lt;!pattern)（否定后瞻分组） 标准非捕获型分组 - (?:pattern)(?:pattern) 是标准的非捕获型分组。 还是以前面的文本 ABCDEFG 为例，可以用包含了标准的非捕获分组的正则表达式 (?:(A(BC))((DE)F))G 去匹配，(?:pattern) 不参与分组，也就是 (?:(A(BC))((DE)F)) 不参与分组，所以： 编号 组 匹配内容 0 (A(BC)(DE)F)G ABCDEFG 1 (A(BC)) ABC 2 (BC) BC 3 ((DE)F) DEF 4 (DE) DE 前瞻 &amp; 后瞻我们一般把文本开头的方向称之为 前 面，文本结尾称之为 后 面。而 正则表达式解析引擎默认是从左往右解析的，因此对于解析引擎来说，文本尾部方向就是前方 。 其实通过英文 lookahead 和 lookbehind 也能快速理解 前 后 的正确含义。 前瞻 和 后瞻 都分别包含 肯定 和 否定，都属于 非捕获型分组。值得注意的是，并非所有的计算机语言都支持正则表达式的后瞻。 肯定前瞻，用 (?=pattern) 表示。通俗解释： 匹配到的文本后面要跟着 pattern 代表的文本，也就是说 (?=pattern) 本身仅参与文本匹配时的预测，匹配到的文本不会包含 pattern 的内容。 比如 ab(?=cd)，表示 匹配文本中包含的 ab 字符串，且该 ab 字符串后面要紧跟着 cd，否则无法匹配。比如该表达式能匹配到 abcd 中的 ab, 但不能匹配到 abef 中的 ab。注意到匹配到的文本（ab）并不会包含 pattern（(?=cd)） 的内容。 其他三种 否定前瞻， 肯定后瞻， 否定后瞻 概念可以类比出来，就不再赘述。 前瞻 &amp; 后瞻 匹配规则及其匹配内容举例： 表达式 肯定前瞻 ab(?=cd) 否定前瞻 ab(?!cd) 肯定后瞻(?&lt;=ab)cd 否定后瞻 (?&lt;!ab)cd 文本 abcdefgh ab 空 cd 空 abefcdgh 空 ab 空 cd 问题解决那么，针对文章开头的 匹配 4 位数字字符串，且其前后都不再有数字 的正则表达式的书写就迎刃而解了： (?&lt;![0-9])[0-9]{4}(?![0-9]) 参考Java 正则表达式JavaScript 正则表达式的分组匹配使用正则表达式找出不包含特定字符串的条目]]></content>
      <categories>
        <category>Algorithm &amp; Data Structure</category>
      </categories>
      <tags>
        <tag>Regular Expression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xposed 碎碎念]]></title>
    <url>%2Fpost%2F2251443378%2F</url>
    <content type="text"><![CDATA[最早接触 Xposed 是在 酷安网 上，约摸是2014年，那个时候的酷安还叫酷市场。当时手里就一台小米2s，由于热衷于刷机尝鲜，稀里糊涂地就接触到了Xposed。当时最震撼的莫过于 WechatUI(链接已失效)，我们知道，在 Materail Design 未流行的时候，国内市场通行各式各样的美化主题和美化App，也就是那个时候的 MIUI 还有其它的国产 Rom 或者 App 来进行主题美化。而 Android 版微信还有很大的 iOS 风格，WeChatUI 却能将微信修改为 MD 风格，着实惊艳。 Xposed 的功能非常强大，不光能对其他 App 的 UI 进行修改，同时也能对其他 App 内部的逻辑进行修改，这些修改称之为 Hook，具体的修改方式包含增加，删减，替换等。Xposed 可以对几乎所有的 App 通过 Hook 的方式修改代码逻辑，应用方向也很广阔，基于 Xposed 开发的 App 一般称之为 Xposed 模块 或者 Xposed 插件。Xposed 模块可以增强系统功能（如 应用管理 治理国内毒瘤），能增删第三方 App 的功能（如 Wechat Magician 实现微信防撤回、增加图片发送上限、朋友圈关键字屏蔽功能等），甚至可以能用于第三方的逆向破解等。Xposed 功能非常强大，几乎无所不能，所以也是一把双刃剑。优点前面已说明，缺点也不少： Xposed 模块安装多了之后，手机会变卡，并且会因为 Xposed 插件没跟上App版本等缘故时不时出现FC的异常 Xposed 插件权限相当高，会被不良商家所利用（点名批评，斗恶龙的勇者最终成为恶龙的典型，也是良心App商业化后黑化的典型：阻止运行），所以使用时需要注意。 Xposed 权限高，所以忌惮。目前部分 App 会检测系统中是否安装了 Xposed 框架，如果安装则不让运行（如 下厨房，摩拜单车等），甚至可以引起封号（微信？ 此处存疑）。当然了，完全可以用 Xposed 去替换这些软件中检测 Xposed 框架是否存在的代码块，XD 所以，合理的使用 Xposed，能让自己的手机和 App 用起来更舒心。 Xposed 原理Xposed 相关的三个核心项目均出自 rovo89 大佬之手： Xposed：Xposed的C++部分，用来替换 /system/bin/app_process，进而控制 Zygote(受精卵) 进程。同时为 XposedBridge 提供 JNI 方法调用，并在启动 Zygote 进程的过程中加载 XposedBridge.jar。Android 系统中所有的其他进程都由 Zygote 孵化（fork）而来，所以其他应用所在进程在加载启动过程中都会含有 XposedBridge。 XposedBridge：加载 Xposed Modules（模块），并为 Xposed Modules（模块） 提供 API 用于开发。API 主要包括: IXposedHookZygoteInit: 在 Zygote 进程启动（即 Android 启动）过程中 Hook 的接口 IXposedHookLoadPackage: 在新的 App 加载过程中 Hook 的接口，可以 Hook 当前应用的 Java 方法 IXposedHookInitPackageResources: 在初始化资源过程中 Hook 的接口，可以替换当前应用的资源（图标，样式等等）。 XposedInstaller：Xposed 的安装程序，内含 Xposed 和 XposedBridge，并提供对 Xposed Modules 管理。 Xposed 模块推荐在这里推荐一些实用的或者有意思的 Xposed 模块： 应用管理Xposed 已开源 X-APM，应用控制类（绿色守护，黑阈，MyAndroidTools等）模块应用，神器。 启用截图DisableFlagSecure 已开源 DisableFlagSecure，关掉系统底层的 FLAG_SECURE ，这样之前不能截屏/录屏的都能截屏/录屏了，比如 QQ 里面的闪图。 ScanLogin 已开源 ScanLogin，扫码自动登录，免去 PC 端微信登录后还需要在手机端再点一下确认登录的尴尬。 Xposed Edge 边缘手势操作模块，功能强大，有 pro 版。 网易云音乐插件 如今的网易云音乐 Android 端越来越臃肿了，是时候用这个模块精简精简了。 GravityBox 重力工具箱，非常棒的系统设置模块，按照自己喜欢的样子定制 Rom，需要下载对应 Android 版本的模块。 指纹支付 已开源 Xposed-Fingerprint-pay, 指纹支付模块，让不支持微信，支付宝，QQ等指纹支付的原生Rom 也能体验指纹支付。 WechatMagician 微信巫师，用于微信防撤回等众多有意思的扩展功能。特别值得一提的是，源码设计的很棒，汲取了其他微信相关模块每逢微信更新必崩溃的教训，自行设计一套 API，极大提高插件稳定性。 MDWechat Material Design 的微信，很棒。 最后再推荐一下自己开发的 Xposed 模块（凑表脸，还是后面再发文详细详解吧，摊手）： 验证码提取Xposed 识别短信验证码，复制到系统剪切板，并能自动输入。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Xposed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 笔记：AIDL进阶]]></title>
    <url>%2Fpost%2F3246519744%2F</url>
    <content type="text"><![CDATA[在上一篇博客 Android 笔记：IPC - AIDL 中讲到的 IPC 方式之一 AIDL 的基本用法，本文主要记录一下 AIDL 的进阶。 &nbsp; AIDL 中的注册与反注册之前的 IBookManager 中只提供了获取 书籍列表(getBookList) 和 添加书籍(addBook) 的方法，现在我们将其扩展一下，希望能加入“当新的书本被添加之后，能够通知出去”。这是一种 观察者模式： 由于 AIDL 中无法使用普通接口，所以添加新的 IOnNewBookArrived.aidl 接口，用于回调新书的到来： package com.github.tianma8023.ipclearn.aidl; import com.github.tianma8023.ipclearn.aidl.Book; interface IOnNewBookArrivedListener { void onNewBookArrived(in Book newBook); } IBookManager.aidl 接口中添加新的注册监听/取消监听的方法： package com.github.tianma8023.ipclearn.aidl; import com.github.tianma8023.ipclearn.aidl.Book; import com.github.tianma8023.ipclearn.aidl.IOnNewBookArrivedListener; interface IBookManager { List&lt;Book&gt; getBookList(); void addBook(in Book book); void registerListener(IOnNewBookArrivedListener listener); void unregisterListener(IOnNewBookArrivedListener listener); } 远程服务端实现 BookManagerService, 实现新加的两个方法，在 Service 中开启线程，定时加入一本新书通知所有注册者： public class BookManagerService extends Service { private static final String TAG = &quot;BMS&quot;; // 当前Service是否被销毁 private AtomicBoolean mIsServiceDestroyed = new AtomicBoolean(false); // 书籍列表 private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;&gt;(); // 观察者列表 private CopyOnWriteArrayList&lt;IOnNewBookArrivedListener&gt; mListenerList = new CopyOnWriteArrayList&lt;&gt;(); private Binder mBinder = new IBookManager.Stub() { @Override public List&lt;Book&gt; getBookList() throws RemoteException { return mBookList; } @Override public void addBook(Book book) throws RemoteException { mBookList.add(book); } @Override public void registerListener(IOnNewBookArrivedListener listener) throws RemoteException { if (!mListenerList.contains(listener)) { mListenerList.add(listener); } else { Log.d(TAG, &quot;listener already exists &quot; + listener); } } @Override public void unregisterListener(IOnNewBookArrivedListener) throws RemoteException { if (mListenerList.contains(listener)) { mListenerList.remove(listener); Log.d(TAG, &quot;unregister listener succeed.&quot;); } else { Log.d(TAG, &quot;listener not found, unregiser failed&quot;); } } }; @Override public IBinder onBind(Intent intent) { return mBinder; } @Override public void onCreate() { super.onCreate(); mBookList.add(new Book(1, &quot;Think in Java&quot;)); mBookList.add(new Book(2, &quot;Android Programming&quot;)); new Thread(new ServiceWorker).start(); } @Override public void onDestroy() { mIsServiceDestroyed.set(true); super.onDestroy(); } private void onNewBookArrived(Book book) throws RemoteException { mBookList.add(book); // 通知所有Listener Log.d(TAG, &quot;new book arrived, notify all listeners&quot;); for (IOnNewBookArrivedListener listener : mListenerList) { listener.onNewBookArrived(book); } } private class ServiceWorker implements Runnable { @Override public void run() { // 每5s在后台生成一本新书 while(!mIsServiceDestroyed.get()) { try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } int bookId = mBookList.size() + 1; Book newBook = new Book(bookId, &quot;new book#&quot; + bookId); try { onNewBookArrived(newBook); } catch (RemoteExcption e) { e.printStackTrace(); } } } } } BookManagerServicce 置于独立进程中： &lt;service android:name=&quot;.aidl.BookManagerService&quot; android:process=&quot;:remote&quot; /&gt; 客户端 BookManagerActivity： public class BookManagerActivity extends Activity { private static final String TAG = &quot;BookManagerActivity&quot;; private static final int MSG_NEW_BOOK_ARRIVED = 1; private IBookManager mRemoteBookManager; private ServiceConnection mConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { IBookManager bookManager = IBookManager.Stub.asInterface(service); mRemoteBookManager = bookManager; try { // 服务端的 getBookList() 方法可能会比较耗时，所以需要酌情考虑是否在子线程中进行访问 List&lt;Book&gt; bookList = bookManager.getBookList(); Log.i(TAG, &quot;book list type: &quot; + bookList.getClass().getCanonicalName()); Log.i(TAG, &quot;query book list: &quot; + bookList); bookManager.registerListener(mOnNewBookArrivedListener); } catch(RemoteException e) { e.printStackTrace(); } } public void onServiceDisconnected(ComponentName name) { mRemoteBookManager = null; } }; private Handler mHandler = new Handler(new Handler.Callback() { @Override public boolean handleMessage(Message msg) { switch (msg.what) { case MSG_NEW_BOOK_ARRIVED: String message = &quot;received new book: &quot; + msg.obj; Log.d(TAG, message); break; } return true; } }); private IOnNewBookArrivedListener mOnNewBookArrivedListener = new IOnNewBookArrivedListener.Stub() { @Override public void onNewBookArrived(Book newBook) throws RemoteException { mHandler.obtainMessage(MSG_NEW_BOOK_ARRIVED, newBook).sendToTarget(); } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_book_manager); Intent intent = new Intent(this, BookManagerService.class); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); } @Override protected void onDestroy() { preDestroy(); super.onDestroy(); } private void preDestroy() { // unregister listener if (mRemoteBookManager != null &amp;&amp; mRemoteManager.asBinder().isBinderAlive()) { try { Log.i(TAG, &quot;unregister listener: &quot; + mOnNewBookArrivedListener); mRemoteBookManager.unregisterListener(mOnNewBookArrivedListener); } catch (RemoteException e) { e.printStackTrace(); } } // unbind service unbindService(mConnection); } } log日志： com.github.tianma8023.ipclearn:remote I/BMS: new book arrived, notify all listeners com.github.tianma8023.ipclearn D/BookManagerActivity: received new book: Book{bookId=3, bookName=&#39;new book#3&#39;} com.github.tianma8023.ipclearn I/BookManagerActivity: unregister listener: com.github.tianma8023.ipclearn.aidl.BookManagerActivity$4@80e21c1 com.github.tianma8023.ipclearn:remote D/BMS: listener not found, unregister failed 通过日志，可以看出，服务端每次的书籍推送确实收到，但是在服务端执行 unregisterListener 的时候却并没有正确执行。问题的原因在于， Binder 会把客户端传递过来的对象重新转化成新的对象，在客户端注册/反注册过程中使用的是同一个客户端对象，但是通过 Binder 传递到服务端的对象则不一样，所以会存在反注册失败的现象。 上述问题的解决方案就是使用 RemoteCallbackList。RemoteCallbackList 由系统提供，专门用来删除跨进成的 listener 接口。 public class RemoteCallbackList&lt;E extends IInterface&gt; public interface IOnNewBookArrivedListener extends android.os.IInterface 可以看出来，RemoteCallbackList 是一个泛型，可以管理任意的 AIDL 接口。 RemoteCallbackList 部分源码： public class RemoteCallbackList&lt;E extends IInterface&gt; { ArrayMap&lt;IBinder, Callback&gt; mCallbacks = new ArrayMap&lt;IBinder, Callback&gt;(); private final class Callback implements IBinder.DeathRecipent { final E mCallback; final Object mCookie; Callback(E callback, Object cookie) { mCallback = callback; mCookie = cookie; } // 省略... } } 可以看出来 RemoteCallbackList 内部其实是一个 Map，建立起 IBinder 到 Callback 的映射，而 Callback 又封装了真正的 IInterface 的 listener，也就是实际上建立起了 IBinder 到 listener 的映射。 虽然之前的 IOnNewBookArrivedListener 会由客户端的一个对象会在服务端生成不一样的对象，但是其底层的 Binder 是一样的，所以 RemoteCallbackListener 正是利用了这个特性，真正地实现反注册。 正确姿势：用 RemoteCallbackList 替换前面的 CopyOnWriteArrayList： // private CopyOnWiteArrayList&lt;IOnNewBookArrivedListener&gt; mListenerList = new CopyOnWriteArrayList&lt;&gt;(); private RemoteCallbackList&lt;IOnNewBookArrivedListener&gt; mListenerList = new RemoteCallbackList&lt;&gt;(); 修改 registerListener 和 unregisterListener： @Override public void registerListener(IOnNewBookArrivedListener listener) throws RemoteException { mListenerList.register(listener); } @Override public void unregisterListener(IOnNewBookArrivedListener listener) throws RemoteException { mListenerList.unregister(listener); } 修改通知所有已注册的 listener 的 onNewBookArrived 方法： private void onNewBookArrived(Book book) throws RemoteException { mBookList.add(book); // 通知所有listener Log.i(TAG, &quot;new book arrived, notify all listeners&quot;); final int N = mListenerList.beginBroadcast(); for (int i = 0; i &lt; N; i++) { IOnNewBookArrivedListener listener = mListenerList.getBroadcastItem(i); if(listener != null) { listener.onNewBookArrived(book); } } mListenerList.finishBroadcast(); } 注意，遍历 RemoteCallbackList 必须要用上述方式进行，即 begiinBroadcast 和 finishBroadcast 必须配对使用。 AIDL 重连 Service当服务端程序意外停止时，Binder 会意外死亡，需要重新连接 Service，有两种解决方案： 给 Binder 设置 DeathRecipient 监听，当 Binder 死亡时，会回调 DeathRecipient#binderDied()，这时可以重连 Service； 在 ServiceConnection#onServiceDisconnected() 中重连 Service。 两者的区别在于在 bindDied 中是在客户端的 Binder 线程池被调用，而 onServiceDisconnected 是在UI线程中被回调。 BookManagerActivity 中加入： public class BookManagerActivity extends Activity { // ... private IBookManager mRemoteBookManager; private IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient() { @Override public void binderDied() { // 子线程，binder线程 if (mRemoteBookManager == null) return; mRemoteBookManager.asBinder().unlinkToDeath(mDeathRecipient, 0); mRemoteBookManager = null; // TODO: 重新绑定 Service } } private ServiceConnection mConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { IBookManager bookManager = IBookManager.Stub.asInterface(service); mRemoteBookManager = bookManager; try { mRemoteBookManager.asBinder().linkToDeath(mDeathRecipient, 0); // ... 省略 } catch (RemoteException e) { e.printStackTrace(); } } @Override public void onServiceDisconnected(ComponentName name) { mRemoteBookManager = null; // 主线程 // TODO: 重连 Service } } } 权限验证默认情况下，远程服务可以被其他外部组件连接上，所以，必要的时候需要加入权限验证。通常有以下几种方案： 在远程 Service 的 onBind 中进行验证，这里的验证方式也有很多，常用的是使用 permission 进行验证：在 AndroidManifest 中声明所需要的权限：&lt;permission android:name=&quot;com.github.tianma8023.ipclearn.permission.ACCESS_BOOK_SERVICE&quot; android:level=&quot;normal&quot; /&gt; 在 BookManagerService 的 onBind 中做权限验证：public IBinder onBind(Intent intent) { // 权限验证 int result = checkCallingOrSelfPermission (com.github.tianma8023.ipclearn.permission.ACCESS_BOOK_SERVICE); if (result == PackageManager.PERMISSION_DENIED) return null; return mBinder; } 这样就完成了权限的验证，当有客户端需要连接该服务时，需要申请权限：&lt;uses-permission android:name=&quot;com.github.tianma8023.ipclearn.permission.ACCESS_BOOK_SERVICE&quot; /&gt; 在服务端的 Binder#onTransact() 中进行权限验证：private Binder mBinder = new IBookManager.Stub() { // ... @Override public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException { // 权限验证 // 1. 需要声明自定权限 &quot;com.github.tianma8023.ipclearn.permission.ACCESS_BOOK_SERVICE&quot; // 2. 包名前缀必须是 &quot;com.github.tianma8023&quot; int check = checkCallingOrSelfPermission(&quot;com.github.tianma8023.ipclearn.permission.ACCESS_BOOK_SERVICE&quot;); if (check == PackageManager.PERMISSION_DENIED) return false; String packageName = null; String[] packages = getPackageManager().getPackagesForUid(getCallingUid()); if (packages != null &amp;&amp; packages.length &gt; 0) { packageName = packages[0]; } if (packageName == null || !packageName.startsWith(&quot;com.github.tianma8023&quot;)) { return false; } return super.onTransact(code, data, reply, flags); } } 上述代码片段，验证了 permission，还验证了包名前缀，只有都满足要求的才能验证通过。 为 Service 指定 android:permission 属性。 代码参考IPCLearn]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android notes</tag>
        <tag>IPC</tag>
        <tag>AIDL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记：IPC]]></title>
    <url>%2Fpost%2F3352500871%2F</url>
    <content type="text"><![CDATA[IPC (Interprocess Communication) 即进程间通信，需要用到 IPC 主要有以下原因： 应用内自身原因需要采用多进程，比如，大应用模块多，需要的内存大，而 Android 对单进程内存有大小限制，所以需要多进程获取更多的内存空间； 当前应用需要获取其他应用数据。 Android 多进程模式开启多进程模式Android 中开启多进程有两种方式： 给四大组件在 AndroidManifest 中指定 android:process 属性 通过 JNI 在 native 层 fork 子进程（属于Linux处理方式） &lt;activity android:name=&quot;.FirstActivity&quot; android:label=&quot;FirstActivity&quot; /&gt; &lt;activity android:name=&quot;.SecondActivity&quot; android:label=&quot;SecondActivity&quot; android:process=&quot;:remote&quot; /&gt; &lt;activity android:name=&quot;.ThirdActivity&quot; android:label=&quot;ThirdActivity&quot; android:process=&quot;com.github.tianma8023.ipclearn.remote&quot; /&gt; 这里，应用程序的包名是 com.github.tianma8023.ipclearn，其中 FirstActivity 运行在以包名为进程名的默认进程中；而SecondActivity 在启动时，会运行在名为 com.github.tianma8023.ipclearn:remote 的进程中；ThirdActivity 在启动时，会运行在名为 com.github.tianma8023.ipclearn.remote 的进程中。以 : 开头的进程是当前应用的私有进程，其他应用程序的四大组件不会和它跑在同一个进程中；不以 : 开头的进程是全局进程，其他应用可以通过 ShareUID 的方式和其跑在同一个进程中。 多进程模式弊端多进程模式会造成如下问题： 静态成员变量以及单例模式失效： Android系统为每个进程都分配有独立的虚拟机，不同的虚拟机有着不同的内存空间分配，在不同虚拟机下访问同一个类对象会分配到不同的地址空间，也就是属于不同的对象。 线程同步机制失效： 在不同的内存地址空间中，同步锁（无论是对象锁还是全局锁）也不一样，故没办法在不同进程间进行线程同步。 SharedPreferences 可靠性降低 SharedPreferences 底层通过读写 XML 文件来实现，在不同进程中并发读写是会产生同步问题的。 Application 会多次创建： 每个进程有独立的虚拟机，自然也有独立的 Application 对象 从以上信息可以得出：位于不同进程的四大组件之间，但凡通过内从共享数据、变量的，都会共享失败。 Android 中的 IPC 方式BundleActivity, Service, BroadcastReceiver 都支持在 Intent 中传递 Bundle 数据，而因为 Bundle 实现了 Parcelable 接口，所以可以在不同的进程间传输，也就是进行了进程间单向通信。 共享文件既然共享内存会失效，那就通过共享文件的方式，但是也会存在并发读写的问题，所以文件共享方式适合对数据同步要求不高的进程间通信。虽然 SharedPreferences 本质是文件读写，但由于 Android 系统对其有缓存策略，即在内存中也会持有 SharedPreferences 的缓存，因此进程间通信不宜用 SharedPreferences。 AIDLAIDL(Android Interface Definition Language) 的进程间通信方式主要依靠 Binder 实现。 定义一个实体类 Book： // Book.java package com.github.tianma8023.ipclearn.aidl; public class Book implements Parcelable { public int bookId; public String bookName; // constructor ... // implements Parcelable ... } 创建 Book.aidl： // Book.aidl package com.github.tianma8023.ipclearn.aidl; // 声明自定义的Parcelable对象 parcelable Book; 创建 IBookManager.aidl 欲实现对 Book 的管理操作： // IBookManager.aidl package com.github.tianma8023.ipclearn.aidl; // 显式导入自定义的数据类型 import com.github.tianma8023.ipclearn.aidl.Book; interface IBookManager { List&lt;Book&gt; getBookList(); void addBook(in Book book); } AIDL 中仅支持一下几种数据类型： 基本数据类型(int, long, char, boolean, double 等)； String 和 CharSequence； List：只支持 ArrayList，且 List 中的每个元素必须是 AIDL 支持的数据类型; Map：只支持 HashMap，且 Map 中的每个元素都必须是 AIDL 支持的数据类型； Parcelable：实现了Parcelable的对象； AIDL：所有的 AIDL 接口本身也可以在其他 AIDL 文件中使用。 需要注意： 自定义的 Parcelable 对象 和 AIDL 对象必须显式的 import 进来，无论它们是否在同一个包内。 如果 AIDL 文件中引用了自定义的 Parcelable 对象，则该 Parcelable 对象必须创建一个与它同名的 AIDL 文件，并在其中声明它为 parcelable 类型 AIDL 文件中除了基本数据类型之外，其他类型参数都需标上：in(输入型参数), out(输出型参数) 或者 inout(输入输出型参数)。因为不同标识的参数底层开销不一样，所以最好别滥用 inout 之后 build 操作，Android Studio 会在模块 /build 目录下面生成对应的 IBookManager.java 文件，大致内容如下： // IBookManager.java /* * This file is auto-generated. DO NOT MODIFY. * Original file: F:\\AndroidStudio\\IPCLearn\\app\\src\\main\\aidl\\com\\github\\tianma8023\\ipclearn\\aidl\\IBookManager.aidl */ package com.github.tianma8023.ipclearn.aidl; public interface IBookManager extends android.os.IInterface { /** Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.github.tianma8023.ipclearn.aidl.IBookManager { private static final java.lang.String DESCRIPTOR = &quot;com.github.tianma8023.ipclearn.aidl.IBookManager&quot;; /** Construct the stub at attach it to the interface. */ public Stub() { // ... } /** * Cast an IBinder object into an com.github.tianma8023.ipclearn.aidl.IBookManager interface, * generating a proxy if needed. */ public static com.github.tianma8023.ipclearn.aidl.IBookManager asInterface(android.os.IBinader obj) { // ... } @Override public android.os.IBinder asBinder() { return this; } @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) { // ... } private static class Proxy implements com.github.tianma8023.ipclearn.aidl.IBookManager { private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) { // ... } @Override public android.os.IBinder asBinder() { return mRemote; } public java.lang.String getInterfaceDescriptor() { return DESCRIPTOR: } @Override public java.util.List&lt;com.github.tianma8023.ipclearn.aidl.Book&gt; getBookList() throws android.os.RemoteException { // ... } @Override public void addBook(com.github.tianma8023.ipclearn.aidl.Book book) throws android.os.RemoteException { // ... } } } public java.util.List&lt;com.github.tianma8023.ipclearn.aidl.Book&gt; getBookList() throws android.os.RemoteException; public void addBook(com.github.tianma8023.ipclearn.aidl.Book book) throws android.os.RemoteException; } AS 自动生成的 aidl 对应的 java 类，可以很好的了解 Binder 的工作机制，所以有必要读一读这里的源码。 这里大致介绍下各个字段及方法的含义： Stub#DESCRIPTOR: Binder 的唯一标识 Stub#asInterface(android.os.IBinader obj):将 服务端 的 Binder 对象转化成 客户端 所需要的 AIDL 接口类型的对象。当服务端和客户端位于同一进程中时，此方法返回的就是服务端对象本身。当它们不在同一个进程中时，返回的是由系统封装后的 Stub.Proxy 对象（也就是需要转换） Stub#asBinder(): 返回当前 Binder 对象 Stub#onTransact(int code, Parcel data, Parcel reply, int flags)：该方法会运行在服务端的 Binder 线程池中。客户端发起的跨进程请求会通过系统底层封装后交由此方法处理。服务端通过 code 参数确认接下来调用执行的目标方法。如果该方法返回 false，则客户端的请求会失败，所以可以利用此特性进行权限认证。 Proxy#getBookList():此方法运行在客户端。客户端使用此方法进行跨进程调用时，会转化为让服务端（远端）的 Binder 执行 transact 方法，与此同时客户端线程挂起，并最终调用服务端的 onTransact，即调用上一条的 Stub#onTransact() 方法，当服务端相应方法执行完毕后返回结果后，客户端当前线程结束挂起，继续执行，并取出服务端返回的结果。 Proxy#addBook()：与上述的 Proxy#getBookList() 类似 Binder 的工作机制图：Binder 工作机制 当客户端发起远程请求时，客户端当前线程会被挂起，等待服务端进程返回结果，所以，如果服务端进程很耗时，则不能在 UI 线程中发起远程请求。 远程服务端实现 Service： public class BookManagerService extends Service { private static final String TAG = &quot;BookManagerService&quot;; private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;Book&gt;(); private Binder mBinder = new IBookManager.Stub() { @Override public List&lt;Book&gt; getBookList() throws RemoteException { return mBookList; } @Override public void addBook(Book book) throws RemoteException { mBookList.add(book); } }; public BookManagerService() { } @Override public IBinder onBind(Intent intent) { return mBinder; } @Override public void onCreate() { super.onCreate(); mBookList.add(new Book(1, &quot;Think In Java&quot;)); mBookList.add(new Book(2, &quot;Android Programing&quot;)); } } 在 AndroidManifest 中将 BookManagerService 置于独立进程中，实现对进程间通信的模拟： &lt;service android:name=&quot;.aidl.BookManagerService&quot; android:process=&quot;:remote&quot; /&gt; 因为 IBookManager.Stub 类是 Binder 的一个抽象子类，所以在 Serivce 中实现 IBookManager.Stub 即可在 onBind() 中返回相应的 Binder 对象。 考虑到 AIDL 中的方法是在服务端的 Binder 线程池中执行的，所以考虑同步就使用了 CopyOnWriteArrayList。注意到 CopyOnWriteArrayList 并不是 ArrayList 的子类，但其实现的最基本的底层原理和 ArrayList 一致（基于数组，可以通过下标 index 进行访问等）。虽然服务端返回的是 CopyOnWriteArrayList，但 Binder 可以通过相同的机理去访问 CopyOnWriteArrayList 中的数据并最终形成新的 ArrayList 返回给客户端。这就与之前提到的 AIDL支持的 List 只有 ArrayList 并不冲突了。 客户端跟绑定普通服务的客户端一致，比较简单： public class BookManagerActivity extends Activity { private static final String TAG = &quot;BookManagerActivity&quot;; private ServiceConnection mConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { IBookManager bookManager = IBookManager.Stub.asInterface(service); try { // 服务端的 getBookList() 方法可能会比较耗时，所以需要酌情考虑是否在子线程中进行访问 List&lt;Book&gt; bookList = bookManager.getBookList(); Log.i(TAG, &quot;book list type: &quot; + bookList.getClass().getCanonicalName()); Log.i(TAG, &quot;query book list: &quot; + bookList); } catch(RemoteException e) { e.printStackTrace(); } } public void onServiceDisconnected(ComponentName name) { } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_book_manager); Intent intent = new Intent(this, BookManagerService.class); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); } @Override protected void onDestroy() { unbindService(mConnection); super.onDestroy(); } } 以上是 AIDL 的基本用法，进阶用法请参考 Android 笔记：AIDL进阶 Messenger使用 Messenger 可以在不同的进程之间传递 Message 对象，实现进程间数据交互通信。 Messenger 的构造函数： public Messenger(Handler target) { mTarget = target.getIMessenger(); } public Messenger(IBinder target) { mTarget = IMessenger.Stub.asInterface(target); } 通过第二个构造函数可以看出来，Messegner 的底层就是 AIDL。 Messenger 对 AIDL 做了封装，由于 Messenger 机制一次只能处理一个请求，因此在服务端不需要考虑线程同步。 Messenger 远程服务端 Service: public class MessengerServerService extends Service { private static final String TAG = &quot;MessengerServerService&quot;; private final Messenger mMessenger = new Messenger(new MessengerHandler()); private static class MessengerHandler extends Handler { @Override public void handleMessage(Message msg) { switch(msg.what) { case TConstants.MSG_FROM_CLIENT: // 服务端接收客户端消息 Log.i(TAG, &quot;msg from client: &quot; + msg.getData().get(TConstants.KEY_MSG)); // 服务端向客户端发送消息 Messenger client = msg.replyTo; Bundle replyBundle = new Bundle(); replyBundle.putString(TConstants.KEY_SERVER, &quot;Okay, I&#39;m server, your message has been received.&quot;); Message replyMsg = Message.obtain(null, TConstants.MSG_FROM_SERVER); replyMsg.setData(replyBundle); try { client.send(replyMsg); } catch (RemoteException e) { e.printStackTrace(); } break; } super.handleMessage(msg); } } @Override public IBinder onBind(Intent intent) { return mMessenger.getBinder(); } } 注册 Service 运行在单独进程中： &lt;service android:name=&quot;.messenger.MessengerServerService&quot; android:process=&quot;:remote&quot; /&gt; Messenger 客户端 Activity ： public class MessengerClientActivity extends Activity { private static final String TAG = &quot;MessengerClientActivity&quot;; // 客户端向服务端发送消息的Messenger private Messenger mMessenger; private ServiceConnection mConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { // 客户端向服务端发送消息 mMessenger = new Messenger(service); Message msg = Message.obtain(null, TConstants.MSG_FROM_CLIENT); Bundle data = new Bundle(); data.putString(TConstants.KEY_MSG, &quot;Hello, this is client.&quot;); msg.setData(data); // 指定message的replyTo为Messenger对象 msg.replyTo = mGetReplyMessenger; try { mMessenger.send(msg); } catch (RemoteException e) { e.printStackTrace(); } } @Override public void onServiceDisconnected(ComponentName name) { // do nothing } } // 客户端接收服务端消息的Messenger private Messenger mGetReplyMessenger = new Messenger(new MessengerHandler()); private static class MessengerHandler extends Handler { @Override public void handleMessage(Message msg) { switch (msg.what) { case TConstants.MSG_FROM_SERVER: Log.i(TAG, &quot;msg from server: &quot; + msg.getData().getString(TConstants.KEY_REPLY)); break; } super.handleMessage(msg); } } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_messenger_client); Intent intent = new Intent(this, MessengerServerService.class); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); } @Override protected void onDestroy() { unbindService(mConnection); super.onDestroy(); } } 注意： Message 的 obj 字段，在 Android 2.0 以前不支持跨进程传输，在 Android 2.0 以后也仅仅在系统提供的实现了 Parcelable 接口的对象上才能支持跨进程传输。 Messenger 原理 ContentProviderContentProvider 底层也是由 AIDL 实现，其主要有6个抽象方法：onCreate, getType, query, update, insert, delete, 其中除了 onCreate 由系统调用运行在主线程之外，其他的都由外界回调运行在 Binder 线程池中。 注意，ContentProvider 底层依赖的数据存储没有要求，可以用 SQLite 数据库，也可以用普通文件，亦可以用 SharedPreferences，不过通常情况下底层存储都是依赖的数据库。 在客户端要观察 ContentProvider 中的数据变化情况，可以通过 ContentResolver#registerContentObserver 方法来注册观察者，ContentResolver#unregisterContentObserver 取消注册。 SocketSocket 也可以实现进程间通信，可以凭借 TCP 或者 UDP 的套接字来实现。与一般的 Socket 编程没有太大区别，主要是在 Android 编程中需要考虑在主线程上更新UI，在子线程发起 Socket 请求即可。 各个 IPC 方式对比 名称 优点 缺点 适用场景 Bundle 简单 只能传输Bundle支持的数据 四大组件间的进程间通信 文件共享 简单易用 不适合并发场景，无法做到进程间即时通信 无并发访问的情景，交换简单的数据，实时性要求不高的场景 AIDL 功能强大，支持一对多并发通信，支持即时通信 使用稍复杂，需要处理线程同步 一对多通信，有RPC需求 Messenger 功能一般，支持一对多串行通信，支持即时通信 不适用于高并发场景，数据只能通过Message进行传输，只能传输Bundle支持的数据类型 适用于低并发的一对多的即时通信，无RPC需求，或者不需要返回结果的PRC需求 ContentProvider 在数据源访问方面功能强大，支持一对多并发数据共享，可以通过Call扩展其他方法操作 受约束的AIDL，主要提供数据源的CRUD操作 一对多进程间的数据共享 Socket 功能强大，可以通过网络传输字节流，支持一对多并发即时通信 实现起来稍微麻烦，不支持直接的RPC 网络数据交换 代码参考IPCLearn]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android notes</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018一月新番推荐]]></title>
    <url>%2Fpost%2F3847558889%2F</url>
    <content type="text"><![CDATA[狗年吉祥，狗年汪汪汪 (┬＿┬)2018年1月新番季已经过了不少时间了，这里安利下我觉得ok的（没列出来的有可能是没看XD），可以讨论但不接受反驳（笑）： 《Darling in the Franxx》 10.0 &nbsp;★★★★★★★★★★ 5.0 &nbsp; ★★★★★ 你是我的 darling 吗？ 02，驾驶望鹤兰的理由，我还有一个，我想成为你的翅膀。 我们没有天空，她没有翅膀。 在“大人”们的思维禁锢下，“爱”和“个性”被无视，青春的骚动被压制，“孩子”们像比翼鸟一样，即便是撞的头破血流也要飞向光明的天空寻找自己的 Darling … 2018.07.06 更新： 看完23话，基本已经是烂尾了。前13话所构建的世界是反乌托邦的，故事跌宕起伏，很有心意。然而后面的引入外星人（wtf???），整部番从 “热血少年追求真理反抗反乌托邦的世界” 变成了 “星球大战环保番” 喵喵喵？？？ 前13话10分满分，后11话0分，所以综合5分 （手动微笑） 我现在除了看dift第24集，什么都想干。 锦织敦史：只要我思维跳的够快，我观众的刀片就扔不到我。 Zero Two 《摇曳露营△》 9.5 &nbsp;&nbsp;&nbsp;★★★★★★★★★☆ 如果说，之前诸君的 Waifu 穿着单薄，稍微卖肉，能露胖次，会秀欧派，卖萌耍嗲。抚子和凛酱则会告诉你即便穿着严实我也是你喜爱的 Waifu 抚子和凛实在是太可爱了。 Yuru Camp 《紫罗兰永恒花园》 9.5 &nbsp;&nbsp;&nbsp;★★★★★★★★★☆ 我想知道，爱是什么？ 连缀人们的思念，为了知晓爱为何物。 薇尔莉特 《擅长捉弄人的高木同学》 9.0 &nbsp;&nbsp;&nbsp;★★★★★★★★★ 别名：《擅长调情的西片太太》、《与空气斗智斗勇的西片同学》、《擅长虐狗的西片夫妇》 回想起来，自己初高中时代也会捉弄心仪的女生呐~ (✿◡‿◡) 高木同学 《比宇宙更远的地方》 9.0 &nbsp;&nbsp;&nbsp;★★★★★★★★★ 只要有梦想，比宇宙更遥远的地方，也一定能抵达。这就是青春啊~ ヾ(o◕∀◕)ﾉヾ 玉木真理 《龙王的工作！》 8.0 &nbsp;&nbsp;&nbsp;★★★★★★★★ 表面将棋，实则萝莉。八嘎师父，大萝卜鸡。 雏鹤爱 《Slow Start》 8.0 &nbsp;&nbsp;&nbsp;★★★★★★★★ 芳文社 &amp; A-1 Pictures 一月是你的百合 小玉挺可爱&nbsp;百地玉手 《Citrus～柑橘味香气～》 7.5 &nbsp;&nbsp;&nbsp;★★★★★★★☆ 橘里橘气 (｡･∀･)ﾉﾞ]]></content>
      <categories>
        <category>漫谈</category>
      </categories>
      <tags>
        <tag>番剧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 笔记：Activity 二三事]]></title>
    <url>%2Fpost%2F579806496%2F</url>
    <content type="text"><![CDATA[本文主要记录一些与 Activity 相关的，并不是很容易弄清楚的点。 Activity 生命周期先上 Google 官方的图：Activity 生命周期 onCreate()：当前 Activity 实例第一次被创建时调用 onStart()：Activity 不可见到可见 时调用 onResume()： Activity 获取焦点，可以进行交互时调用 onPause()：Activity 失去焦点，无法交互时调用 onStop()：Activity 完全不可见时调用 onDestroy()：Activity 即将销毁前调用 onRestart()：Activity 正在被重新启动时调用 这里又引申出 Activity 相关的三个生存期： 完整生存期： onCreate() -&gt; onDestroy() 可见生存期： onStart() -&gt; onStop() 前台（可交互）生存期： onResume() -&gt; onPause()&nbsp; Q：Activity A 启动 Activity B 时，A 的 onPause() 先执行还是 B 的 onResume() 先执行呢？A：A 的 onPause() 先执行。结论：考虑到只有在当前 Activity 的 onPause() 执行完毕之后，新的 Activity 的 onResume() 才执行，所以，在 onPause() 中尽量别做重量级操作。 异常情况下的生命周期Activity 异常情况重建过程 这里的 异常情况 主要指以下两种情况： 系统相关的资源配置发生改变产生的异常： 如果Activity不作特殊处理，当系统配置发生改变（比如屏幕方向发生改变），Activity就会被销毁并重建，onSaveInstanceState() 和 onRestoreInstanceState() 这两个方法就会在这一过程中被调用。 内存资源不足导致 Activity 被回收的异常：Activity会有优先级分级情况，优先级依次降低： 前台 Acitivty，即正在交互的 Activity 可见但非前台 Activity 不可见后台 Activity 内存资源不足导致 Activity 被回收，在后续也会通过 onSaveInstanceState() 和 onRestoreInstanceState() 存储和恢复数据。没有四大组件在运行的进程很容易被系统杀死，所以，一些后台工作不适合脱离四大组件独自后台运行，最佳实践是依赖 Service 以保证进程有较高的优先级。 Activity 在异常情况下进行重建时，系统会默认对 View 相关的状态进行存储和恢复，具体会恢复特定 View 的什么状态数据需要去查阅源码。也就是说，非 View 相关的数据，需要自行存储和恢复。 针对上面的第一种情况，Activity 的 configChanges 可以指定一些资源配置属性，当这些资源配置发生改变之后，Activity 不会重建，不会调用 onSaveInstanceState() 和 onRestoreInstanceState()，取而代之的是回调 onConfigurationChanged() 方法。最常用的 configChanges 选项有： locale：设备的本地位置发生改变，一般指切换系统语言； orientation：屏幕方向发生改变，比如旋转手机屏幕； keyboardHidden：键盘的可访问性发生改变，比如用户调出键盘。 Activity 启动模式Activity 的 launchMode 由四种： standard：默认启动方式，每次启动这样的 Activity 都会生成创建新实例。谁启动以 standard 为 launchMode 的 Activity, 该 Activity 就会运行在它的那个任务栈中； singleTop：栈顶复用模式，要启动的 Activity 已经有实例在栈顶，则不会生成新实例，不会调用 onCreate() 和 onStart() 而会调用该 Activity 的 onNewIntent() 方法；其他情况，参考 standard 模式； singleTask：栈内复用模式。比如 Activity A 的 TaskAffinity 属性指定的任务栈为 a，当启动 A 时，如果任务栈 a 不存在，则创建 a 任务栈，并创建 Activity A 让其入栈；如果任务栈 a 存在，且 A 实例不存在，则 A 入栈；如果任务栈 a 存在，且 A 实例存在，则清空（pop）在 A 之上的所有 Activity 让 A 置于栈顶，并回调 A 的 onNewIntent() 方法；TaskAffinity 即 任务相关性，这个参数标识 Activity 所需要的任务栈的名字，默认情况下，这个值是应用包名。 TaskAffinity 主要和 singleTask 启动模式配对使用，singleTask 启动模式的 Activity 会启动在 TaskAffinity 指定的任务栈中。比如：&lt;activity android:name=&quot;com.example.ExampleActivity&quot; android:taskAffinity=&quot;com.exmple.exampleTask&quot; android:launchMode=&quot;singleTask&quot;/&gt; singleInstance：单实例模式。可以看做是特殊的 singleTask 模式，除了具有 singleTask 特性外，此种模式的 Activity 只能单独在一个任务栈。 IntentFilter 匹配规则IntentFilter 用在 Activity 的隐式调用上，先看 IntentFilter 示例： &lt;activity android:name=&quot;com.example.ExampleActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.SEND&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:mimeType=&quot;text/plain&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.SEND&quot; /&gt; &lt;action android:name=&quot;android.intent.action.SEND_MULTIPLE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;com.example.intent.category.CUSTOM_1&quot; /&gt; &lt;category android:name=&quot;com.example.intent.category.CUSTOM_2&quot; /&gt; &lt;data android:scheme=&quot;http&quot; android:host=&quot;com.example.com&quot; android:port=&quot;4000&quot; android:path=&quot;folder&quot; android:mimeType=&quot;text/plain&quot; /&gt; &lt;data android:scheme=&quot;content&quot; android:host=&quot;com.example.project&quot; android.port=&quot;1080&quot; android:path=&quot;images&quot; android:mimeType=&quot;image/*&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 可以看出一个 Activity 可以包含多个 IntentFilter，即形成一个 IntentFilter 列表，只要匹配任何一个 IntentFilter 就可以启动该 Activity。而 IntentFilter 中可以包含 action、 category、 data 三元素，只有这三个都匹配成功，整个 IntentFilter 才能匹配成功。 action 匹配规则Intent 中的 action 必须和 IntentFilter 中包含的 action 之一匹配就可以匹配成功。如果，把 Intent 中指定的 action 看做元素 a，把 IntentFilter 中指定的 action 所构成的集合看成集合 A，则 当 a ∈ A 时， action 匹配成功。 category 匹配规则 如果 Intent 指定 category，就必须被包含在 IntentFilter 中所指定的 category。如果，Intent 中指定的 category 元素构成集合 A, IntentFilter 中指定的 category 元素构成集合 S，则当 A ⊆ S 时， category 匹配成功； 如果 Intent 不指定 category, 则默认的 category 为 android.intent.category.DEFAULT, 也会匹配成功。 data 匹配规则data 部分由 mimeType 和 URI 组成，mimeType 表示媒体类型，比如图片、音频、视频、文本等格式，URI 的结构为： &lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;] 比如： http://com.example.com:8080/search/info content://com.example.project:200/folder/subfolder/etc scheme：URI 的模式，比如 http、file、content，也可以是自定义字符串，如果没有指定 scheme 的值，则整个 URI 无效； host：URI 的主机名，如果没有指定，则整个 URI 无效； port：端口号； path、 pathPrefix、 pathPattern 分别代表 完整路径匹配、前缀路径匹配、正则路径匹配。它们必须需要以 / 开头。 data 的匹配规则跟 action 类似，也就是如果，把 Intent 中指定的 data 看做元素 d，把 IntentFilter 中指定的 data 元素所构成的集合看成集合 D，则 当 d ∈ D 时， data 匹配成功。 如果 data 节点中只指定了 mimeType，那么系统默认的 URI 的 scheme 为 content 和 file。也就是说，在这种情况下，比如 intent 指定的 scheme 为 http 则会出现 Activity 找不到的异常。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android notes</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 折腾记]]></title>
    <url>%2Fpost%2F1810369046%2F</url>
    <content type="text"><![CDATA[本博客以 Hexo 3.2.2 为静态博客框架，以 material 1.3.0 为主题搭建而成。 参阅这两个的官方文档便可以初步搭建一个美美哒的博客了。 本文主要记录一下所折腾的东西。&nbsp; 个性化配置&amp;优化这里 是官方收录的 Hexo 插件。 这里列一下博客用到的插件，大部分都可以看其对应官方文档就能正确配置。 链接固定链接插件：hexo-abbrlink之前的 permalink 格式是： permalink: post/:year/:month/:day/:title/ # 例如 http://tianma.space/2018/02/08/Hello-World 使用 hexo-abbrlink 插件格式是: permalink: post/:abbrlink/ # abbrlink config abbrlink: alg: crc32 #算法 support crc16(default) and crc32 rep: dec #进制 support dec(default) and hex # 例如： http://tianma.space/post/3678283086/ 部署当访问博客网站 Tianma 国内IP走的 coding: tianma8023.coding.me 国外IP走的 GitHub: tianma8023.github.io 这样一定程度上能加快网站加载速度。 达到以上效果，大致来说，需要以下步骤： 将博客部署到 GitHub 和 Coding, 具体参阅 hexo干货系列：（四）将hexo博客同时托管到github和coding 和 git多网站ssh部署方案 注册域名,国内有 万网，国外有 GoDaddy , 然后进行域名绑定，即国内走 Coding 国外走 GitHub ，相关教程很多就不赘述了。 静态资源压缩优化使用 gulp 压缩 Hexo 静态资源 gulp 的官方定义非常简洁：基于文件流的构建系统。 说人话系列：gulp 是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成。 更多详细配置请参考 使用 gulp 压缩 hexo 静态资源 CDN服务CDN 存储服务商使用的是 七牛云，配合 hexo-qiniu-sync 食用。 使用 CDN 存储服务的主要目的就是把 图片、视频、音乐等其他较大的静态资源 上传到七牛云，加速博客网站静态资源加载。 详细请参考 使用七牛为Hexo存储图片等资源。 更新：由于七牛云现行规定是，使用了内容存储服务的必须要绑定在中国大陆已备案的域名，而我目前的域名是在 GoDaddy 上注册的，没法备案，所以已将 CDN 从七牛云迁移至 阿里云OSS。 音乐播放音乐播放器采用的是 DIYGod 的 APlayer, 以 MetingJS 为辅助配合食用。 详情参考: Hexo 折腾：音乐播放 图片 图片描述(description)：因为 material 主题本身没有对图片做过多处理，当使用: ![description](xxx.jpg) 插入图片时，最后的 description 是没有显示的。这里采用 hexo-image-caption 插件将上述 markdown 生成如下元素： &lt;img src=&quot;xxx.jpg&quot; alt=&quot;description&quot;/&gt; &lt;span class=&quot;image-caption&quot;&gt;description&lt;/span&gt; 从而展示 description，当然了，出于美观，需要对 .image-caption 元素指定相应的 css 样式。 更多配置参考其文档。 图片放大查看： 由于 material 主题没有该功能，这里便采用 FancyBox 库实现该功能，详情参考 Hexo 折腾：利用 Fancybox 添加图片放大预览查看功能 看板娘看板娘采用的以 live2d 技术为核心，以 hexo-helper-live2d 为插件，配合 live2d 模型制作而成。 详情参考： hexo-helper-live2d 本博客给看板娘加入了 鼠标滑动悬停 和 点击 事件监听，以做出更多响应。 具体参考 给博客添加能动的看板娘(Live2D)-将其添加到网页上吧 分页由于 material 主题本身没有分页功能，而 hexo-theme-next 提供了分页功能，在 next 主题启发下，其实 hexo 本身就提供了 paginator 这一 Helpers(辅助函数)&nbsp;实现分页。具体步骤为： 在 material/layout/index.ejs 中的 index nav 模块中插入：&lt;% if (page.total &gt; 1) { %&gt; &lt;!-- Index nav --&gt; &lt;nav class=&quot;material-nav mdl-cell mdl-cell--12-col&quot;&gt; &lt;%- paginator({ prev_text: __(&#39;&lt;button class=&quot;mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon&quot;&gt;&lt;i class=&quot;material-icons&quot; role=&quot;presentation&quot;&gt;arrow_back&lt;/i&gt;&lt;/button&gt;&#39;), next_text: __(&#39;&lt;button class=&quot;mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon&quot;&gt;&lt;i class=&quot;material-icons&quot; role=&quot;presentation&quot;&gt;arrow_forward&lt;/i&gt;&lt;/button&gt;&#39;), space: &#39;&amp;hellip;&#39;, mid_size: 1 }) %&gt; &lt;/nav&gt; &lt;% } %&gt; 在生成 html 文件的时候，会自动生成相应的页码，其中，当前页面是 .page-number.current 元素， 非当前页面是 .page-number 元素，还会根据 paginator 的 space 配置生成 .space 元素。 在 material/source/css/style.min.css 中加入相应的 css 样式，考虑到目前 material 主题的 scheme 是 Paradox, 所以只贴出了 Paradox 相关的 css 样式： #scheme-Paradox .page-number { padding: 0em 0.8em; font-size: 1.3em; margin: 0em 0.2em; } @media screen and (max-width:480px) { #scheme-Paradox .page-number { padding: 0em 0.4em; font-size: 1.2em; margin: 0em 0.2em; } } #scheme-Paradox .space { color: #666; } #scheme-Paradox .material-nav .page-number.current { color: #FF4081; text-align: center; font-weight: bold; } 版权声明现在已经是大版权时代，对文章进行版权声明也是有必要的。文章类的版权声明主要通过 知识共享许可协议来进行，故声明之前有必要了解 知识共享许可协议(Wiki) 和 关于许可协议。考虑到有些网站会爬取他人博客，其实主要是针对 body 体内的内容，所以需要把版权声明部分写入 body 体中： 自定义字段：考虑到有些博文可能是不需要版权声明的，比如转载、翻译之类的，所以自定义 post_license 作为开关： 主题配置文件 _config.yml 中添加字段，作为总开关：post_license: enable: true # or false 文章的 Front-matter 中添加字段，作为独立开关：post_license: true # or false 创建 material/layout/_partial/post_license.ejs: &lt;div&gt; &lt;br/&gt; &lt;ul id=&quot;post-license&quot; class=&quot;post-license&quot;&gt; &lt;li class=&quot;post-license-author&quot;&gt; &lt;strong&gt;本文作者：&lt;/strong&gt; &lt;a href=&quot;&lt;%= config.url %&gt;&quot;&gt;&lt;%= theme.author %&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;post-license-link&quot;&gt; &lt;strong&gt;本文链接：&lt;/strong&gt; &lt;a href=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;%= page.title %&gt;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;post-license-statement&quot;&gt; &lt;strong&gt;版权声明： &lt;/strong&gt; 本文由 &lt;%= config.author %&gt; 原创，采用 &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh&quot; rel=&quot;license&quot; target=&quot;_blank&quot;&gt;署名-非商业性使用-相同方式共享（CC BY-NC-SA）4.0 国际许可协议&lt;/a&gt; &lt;/br&gt;转载请保留以上声明信息！ &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 在 material/layout/_partial/post-content.ejs 引入 post_license.ejs:&lt;% if(theme.post_license.enable &amp;&amp; page.post_license !== false){%&gt; &lt;%- partial(&#39;_partial/post_license&#39;) %&gt; &lt;% } %&gt; 在 material/source/css/style.min.css 中添加 版权声明 样式：#post-license { margin: 2em 0 0; padding: 0.5em 1em; border-left: 3px solid #ff4081; background-color: #f9f9f9; list-style: none; } 工具推荐 图片压缩：tinypng - 在压缩图片的同时尽可能保证图片质量 矢量图, 图标等：iconfont, IconFinder, material icons 图床工具：PicGo]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo-theme-material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 文字绘制中的 FontMetrics 和 drawText()]]></title>
    <url>%2Fpost%2F3678283086%2F</url>
    <content type="text"><![CDATA[在绘制文字的时候，不可避免的用到 FontMetrics 类和 Canvas#drawText() 方法，这里详细介绍下。 FontMetrics先看下面这张图：FontMetrics Lines 图中有五条线，自上而下分别是： top line: 文字可绘制区域最顶部的线； ascent line: 系统推荐的，文字可绘制区域顶部的线； baseline: 文字绘制的基线（在四线格上书写英文字母时的第三条线）； descent line: 系统推荐的，文字可绘制区域底部的线； bottom line: 文字可绘制区域最底部的线。 而 FontMetrics 类中有 [top, ascent, descent, bottom, leading] 字段，与上面 5 条线的关系是： FontMetrics对象中的字段值 = 对应线条的 Y 坐标值 - baseline的 Y 坐标值 ，如果用 Y(line A) 表示线条 A 的 Y 坐标的话，那么以下等式成立： FontMetrics::top = Y(top line) - Y(baseline); FontMetrics::ascent = Y(ascent line) - Y(baseline); FontMetrics::descent = Y(descent line) - Y(baseline); FontMetrics::bottom = Y(bottom line) - Y(baseline); 需要注意的是： 通常情况下，Android 中的 y 轴的正方向是沿屏幕向下的，也就是越往下 y 坐标越大，所以 FontMetrics 的 top 和 ascent 值是负值， descent 和 bottom 的值是正值。 余下的字段 leading 表示 系统推荐的行间距。 在实际开发中，通常使用 Paint 的 getFontMetrics() 获得其对应的 FontMetrics 对象。 drawText()绘制文字的时候，需要使用 Canvas 的 drawText(String text, float x, float y, Paint paint) 方法，其中的 text 表示 所需绘制的文字， paint 表示 画笔，这很好理解，那么 x 和 y 又是什么呢？ 这里把 x 和 y 组成的点 (x, y) 称作 基点，用于控制文字绘制的基准位置，而 Paint 中的 Align 对象指定文字对齐方式。 基点 和 Align 共同作用从而成功绘制文字。特别地是：基点的 Y 坐标（也就是 y 值）其实就是前面提到的 baseline 的 Y 坐标。 比如：上面图中 baseline 上的黄点就是基点，可以观察得出其对齐方式 Align 就是 CENTER。 Sample示例截图：FontMetrics Sample GitHub: FontMetricsSample 参考 Meaning of top, ascent, baseline, descent, bottom, and leading in Android’s FontMetrics 自定义控件之绘图篇（ 五）：drawText()详解]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>FontMetrics</tag>
        <tag>Custom View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 折腾：音乐播放]]></title>
    <url>%2Fpost%2F3998746934%2F</url>
    <content type="text"><![CDATA[最近想要在博客中插入音乐（网易云音乐），目前找到了三种解决方案： 使用音乐平台自己的插件 结合 MetingJS 使用 APlayer 使用 hexo-tag-aplayer 使用音乐平台官方插件以网易云音乐为例，在Web网页上找到 歌单/单曲/专辑 页面，点击 生成外链播放器 即可跳转到官方提供的音乐播放插件使用引导页面，比如这个 外链插件。可以在自己博客页面中嵌入插件: &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=330 src=&quot;//music.163.com/outchain/player?type=0&amp;id=827122421&amp;auto=0&amp;height=430&quot;&gt; &lt;/iframe&gt; 效果展示： 缺点： 网易音乐有些音乐因为版权保护，没办法生成外链 音乐平台众多，不同的平台可能插件规范不一样，插入不同平台来源的歌曲可能比较麻烦。 使用 APlayer + MetingJSAPlayer 是目前广泛使用的 HTML5 音乐播放器，MetingJS 用于解析歌曲链接。 以我目前的 hexo-theme-material 主题为例： 引入JS（最新的CDN请参考官网），创建 /layout/_widget/aplayer.ejs ： &lt;!-- Import APlayer --&gt; &lt;link href=&quot;https://cdn.jsdelivr.net/npm/aplayer@1.9.0/dist/APlayer.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/aplayer@1.9.0/dist/APlayer.min.js&quot;&gt;&lt;/script&gt; &lt;!-- Import meting.js --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/meting@1.1.1/dist/Meting.min.js&quot;&gt;&lt;/script&gt; 考虑到不是所有的博客页面都需要嵌入 aplayer, 所以在 /_partial/head.ejs 中加入： &lt;!-- Import APlayer.js --&gt; &lt;% if (page.aplayer === true) { %&gt; &lt;%- partial(&#39;_widget/aplayer&#39;) %&gt; &lt;% } %&gt; 使用，需要内嵌 APlayer 的页面中： 在Front-matter 中加入： aplayer: true 嵌入 APlayer： &lt;div class=&quot;aplayer&quot; data-id=&quot;id&quot; data-server=&quot;server&quot; data-type=&quot;type&quot;&gt; &lt;/div&gt; 参数： 参数 是否必须 默认值 描述&amp;可选值 data-id 是 单曲ID / 歌单ID / 专辑ID / 搜索关键词 data-server 是 音乐平台：netease,tencent,kugou,xiami,baidu data-type 是 音乐类型：song,playlist,album,search,artist data-mode 已弃用 circulation 播放模式：circulation,random,single,order 使用 data-loop data-order 字段代替 data-autoplay 否 false 是否自动播放，移动端浏览器不支持该选项 data-mutex 否 true 播放时是否暂停其他APlayer对象 data-listmaxheight 否 340px 播放列表最高高度 data-preload 否 auto 音乐预加载模式：none, metadata, auto data-theme 否 #2980b9 主题色 data-mini 否 false 是否开启迷你模式 data-loop 否 all 循环方式：all, one, none data-order 否 list 播放顺序：list, random data-lrc 否 false data-list-folded 否 false 歌单列表初始时是否折叠 data-volume 否 0.7 用户未自定义前的默认初始化音量 更多参数参考:MetingJS Options &nbsp;&nbsp;APlayer Options 效果展示： 单曲: &lt;div class=&quot;aplayer&quot; data-id=&quot;33911781&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mutex=&quot;false&quot; data-loop=&quot;none&quot;&gt; &lt;/div&gt; 歌单： &lt;div class=&quot;aplayer&quot; data-id=&quot;775701065&quot; data-server=&quot;netease&quot; data-type=&quot;playlist&quot; data-order=&quot;random&quot; data-listmaxheight=&quot;240px&quot; data-theme=&quot;#FF4081&quot;&gt; &lt;/div&gt; 使用 hexo-tag-aplayer 插件hexo-tag-aplayer 就是将 APlayer 内嵌入博客页面的 Hexo 插件。 安装 npm install --save hexo-tag-aplayer 使用 {% aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %} 还支持其他参数，同时支持歌词、歌曲列表等功能，详情参考该项目主页。 缺点： 目前不支持在线播放（其他音乐网站歌曲），具体参考这个 issue 29 2018.03.31更新：目前 3.0 版本的 hexo-tag-aplayer 已经支持了 MetingJS，因此可以解析网络平台的歌曲/歌单了。 在站点配置文件中开启 meting 模式： aplayer: meting: true 使用 meting 标签插入在线音乐，例如： {% meting "27684881" "netease" "song" "theme:#FF4081" "mode:circulation" "mutex:true" "listmaxheight:340px" "preload:auto" %} 效果如下： 需要注意： 到目前为止，meting 标签参数中必须包含 id, server, type 且有序，剩余的参数除了 autoplay 之外其他的都需要按照 参数名:xxx 的格式。更多细节具体请参考这个 issue 已经该插件的官方文档。 同一个html中不能同时出现 melting 和 aplayer 标签。如果同时使用，aplayer 标签就会失效。参见 issue 52 最后考虑到我最初的需求是 能播放在线歌单 ，再考虑到便利性，所以最终选择了 hexo-tag-aplayer 方案。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>APlayer</tag>
        <tag>hexo-tag-aplayer</tag>
        <tag>music player</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JitPack - 发布Android库]]></title>
    <url>%2Fpost%2F667499984%2F</url>
    <content type="text"><![CDATA[JitPack.io 是一个 JVM/Android 工程的包管理仓库。开发者可以在上面发布自己的库，一旦成功发布，就可以方便的在 Gradle 中引用。 当然了，Andriod 相关的包管理仓库除了 JitPack 之外，还有 jCenter 等，但 JitPack 应该发布起来是最简单的了。 发布 Android Library1. Gradle为了让 JitPack 能正确的构建 Android 工程，需要添加 android-maven-gradle-plugin 插件： 如果使用的 Gradle 版本 &gt;= 4.1 （即使用的 com.android.build.gradle 版本 &gt;= 3.0.0）: 在项目根目录的 build.gradle 中如下配置： buildscript { dependencies { classpath &#39;com.github.dcendents:android-maven-gradle-plugin:2.0&#39; // 添加这行配置 } } 在库工程的 build.gradle 中如下配置： apply plugin: &#39;com.github.dcendents.android-maven&#39; group = &#39;com.github.YourUsername&#39; 如果使用的其他版本的 Gradle 配置会有所变化，因为 android-maven-gradle-plugin 和 Gradle 版本有个对应关系。具体配置和上面的相似，只不过对应版本，详情可以戳这里 android maven gradle plugin - Note on Releases 2. GitHub在Github对应项目上发布release包或者添加一个tag，网上教程很多，略过。 3. JitPack参照下图，将项目提交到 JitPack ，让其构建对应的工程： 提交到JitPack 点击 Get it 按钮，JitPack 会给出指定库的引用配置信息： JitPack库的配置信息 使用 Android LibraryDependency 格式构成发布到 JitPack 的库的 dependency 的格式如下： Group(组) ： com.github.Username Artifact(产品) ： Repository Name (Github Repo 名) Version(版本) ：Release 的 tag 或者 commit hash 值 或者 -SNAPSHOT JitPack 中的 Snapshotsnapshot(快照) 版本在开发中很有用。snapshot 可以表示那些没有正式发布的版本。 指定的版本 和 snapshot版本 区别在于后者可能可以不断的更新版本，即可能指向最新的版本。所以snapshot版本在项目开发过程中很实用。 snapshot 版本格式如下： branch-SNAPSHOT （分支名-SNAPSHOT） 例如： compile &#39;com.github.Username:RepoName:master-SNAPSHOT&#39; // eg &#39;com.github.tianma8023:SimpleLineChart:master-SNAPSHOT&#39; 通过添加 -SNAPSHOT 字段可以每次构建 master 分支上最新的 commit。 注意： 考虑到 Gradle 会缓存 SNAPSHOT 的版本，所以当使用 snapshot 的形式，并且有新的版本更新时，需要在 Android Studio 中通过 File -&gt; Synchronize 进行更新和同步。 Gradle 中导入 Library 使用你的库，需要把 jitpack.io 添加入仓库列表中去，在 项目根目录 的 build.gradle 中添加： allprojects { repositories { jcenter() maven { url &#39;https://jitpack.io&#39; } // 添加这行 } } 注意：不要把 jitpack.io 添加到 buildscript 闭包中去。 在模块的 build.gradle 中添加库的依赖： dependencies { // 方式1. SNAPSHOT compile &#39;com.github.Username:RepoName:branch-SNAPSHOT&#39; // eg. complie &#39;com.github.tianma8023:SimpleLineChart:master-SNAPSHOT&#39; &amp;nbsp; // 方式2. Release Tag // compile &#39;com.github.Username:RepoName:ReleaseTag&#39; // eg. compile &#39;com.github.tianma8023:SimpleLineChart:0.0.2&#39; &amp;nbsp; // 方式3. Commit Hash // compile &#39;com.github.Username:RepoName:CommitHash&#39; // eg. compile &#39;com.github.tianma8023:SimpleLineChart:015b8d6aff&#39; } 踩坑 在导入 JitPack 的库工程的时候，会出现资源不能被获取的报错信息，但是 JitPack 上面的 Build 是成功的。这个时候，其实是是本地网络问题，因为 jitpack.io 走的是 https。 所以，可以添加网络代理，因为本身我用的 SS 科学上网的，所以在项目的 gradle.properties 文件中添加代理： # http systemProp.http.proxyHost=127.0.0.1 systemProp.http.proxyPort=1080 # https systemProp.https.proxyHost=127.0.0.1 systemProp.https.proxyPort=1080 按照之前的 Punlish 流程，引用 JitPack 库之后，并不能很好的阅读源码和查看注释，这是发布前的配置问题。参考 Maven 的配置，在 build 过程中执行文档化操作即可。在 library 模块下新建 javadoc-sources-build.gradle 文件： // Specify encoding - 指定编码方式 tasks.withType(JavaCompile) { options.encoding = &#39;UTF-8&#39; } &amp;nbsp; // Package source code - 打包源码 task sourcesJar(type: Jar) { from android.sourceSets.main.java.srcDirs classifier = &#39;sources&#39; } &amp;nbsp; task javadoc(type: Javadoc) { failOnError false source = android.sourceSets.main.java.sourceFiles classpath += project.files(android.getBootClasspath().join(File.pathSeparator)) classpath += configurations.compile } &amp;nbsp; // generate javadoc - 生成Javadoc task javadocJar(type: Jar, dependsOn: javadoc) { classifier = &#39;javadoc&#39; from javadoc.destinationDir } &amp;nbsp; artifacts { archives sourcesJar archives javadocJar } 然后在 library 模块下的 build.gradle 引入之前的配置： apply from: &#39;javadoc-sources-build.gradle&#39; 之后按照正常发布流程即可。 参考 GitHub - JitPack.io JitPack - Publish an Android library android-maven-gradle-plugin 用JitPack发布时附加文档和源码]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>JitPack</tag>
        <tag>Package Repository</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Goodbye 2017 Welcome 2018]]></title>
    <url>%2Fpost%2F2666287230%2F</url>
    <content type="text"><![CDATA[白驹过隙，2017已离我而去，2018也匆匆而至。 2017败犬般浑浑噩噩地过日子，浑然不觉一年过去了。 2017的主题应该就是 逃避 了吧，自己是真的蠢。 自闭，逃避，废柴，死宅，咸鱼，鶸 给2017的自己。 2018本命插旗： 要敢于面对惨淡的人生 别再囿于往事，固步自封 规律作息，好好学习，好好工作 摆脱 SAO MD 向前看 2018-02-03：在帮助前团员打完最后一场公会战之后完全弃坑。再见 SAO MD，再也不见 :) 希望2018年的总结，能像模像样，以上。]]></content>
      <categories>
        <category>漫谈</category>
      </categories>
      <tags>
        <tag>Annual Review</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度云资源加速下载]]></title>
    <url>%2Fpost%2F3444791601%2F</url>
    <content type="text"><![CDATA[基于某些特殊的原因，非会员的情况下，百度云网盘客户端在下载资源时会进行限速。据可能不准确猜测，此行为的目的是推广其vip业务。因而产生了不少的应对策略来突破其下载限制。比较简单粗暴的就是破解版的PC客户端，然而破解版一是涉及到版权问题，而是可能破解版客户端会夹带私货不够安全，就不多bb了。 在这里介绍一些其他的解决方案。 Aria2 + BaiduExporter使用 Aira2 结合 BaiduExporter 越过度娘网盘下载速度限制，具体参考之前的： 下载工具aria2 - 配置和使用 BaiduExporter 介绍与使用 TampermonkeyTampermonkey(油猴，简称TM) 是 Chrome 浏览器上的一款插件，是一款脚本管理器，用于管理 JavaScript 脚本。通过 JS 脚本可以实现特定网页/网域内容的定制化操作。 正确姿势： Chrome 浏览器安装 Tampermonkey 扩展插件； 去 GreaskyFork 安装第三方的用户脚本，当然 TM 支持的用户脚本源不止这一个了，但 GreaskyFork 是目前受众最广最受欢迎的脚本源网站了； 以 百度/云/网盘 为关键字，可以搜到很多实用扩展。然后安装 百度网盘直接下载助手改 扩展脚本。 访问自己百度云盘网页，会发现多了一个 下载助手 按钮： 点击下载助手&nbsp;选择下载方式 2018.01.18 更新：因百度网盘已经修改相关代码，故而 百度网盘直接下载助手改 目前版本已失效，最新有效的扩展脚本是 百度网盘直接下载，在网盘页面点击 下载 按钮即可直接下载。 至于外链下载的话，我用的是 迅雷极速版，有需要的可以参考前面的文章 迅雷极速版 - 时代的眼泪]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>百度云</tag>
        <tag>BaiduExporter</tag>
        <tag>Tampermonkey</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迅雷极速版 - 时代的眼泪]]></title>
    <url>%2Fpost%2F2806688193%2F</url>
    <content type="text"><![CDATA[如果说提供 高效迅捷的P2P 下载服务是迅雷的核心业务，那迅雷产品中从一而终的就是 迅雷极速版。然而，伴随着与QQ旋风 PK 的胜利，迅雷的产品理念逐渐多了些杂乱无章的东西，引发的的恶果之一就有 迅雷极速版 的下架。 迅雷极速版 下架其实已经有很长一段时间了，之所以后知后觉，是因为 PC 上“绝版”的 迅雷极速版 仍然提供着高效的下载服务。最近手抽卸载了极速版，却发现她已经下架了。知乎上也有关于此事件的讨论， 如何看待迅雷极速版下架？。然后又尝试着下载了所谓的 迅雷9，整个一 浏览器 是闹哪样呢？呜呼哀哉！ 最终还是找到了极速版的最后一版，版本号 1.0.35.366 ，也许这个版本号应该被我们所铭记，毕竟又是一滴时代的眼泪不是吗？ :( 这里我提供最后一版的百度云链接: 百度云 - ThunderSpeed-1.0.35.366.zip, 提取密码 vhxa 。 我想，极速版我会用到其服务被关停为止，嗯。]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>下载工具</tag>
        <tag>迅雷极速版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 折腾：利用 Fancybox 添加图片放大预览查看功能]]></title>
    <url>%2Fpost%2F2208308547%2F</url>
    <content type="text"><![CDATA[在之前的博客中，有的图片因为页面宽度或者高度的限制，显得比较小，不是很清晰，而我目前使用的主题是 hexo-theme-material ，版本为 1.3.0，该版本主题本身未加入图片预览功能，所以就自己折腾来加入图片点击放大预览效果。 考虑到之前使用的主题 hexo-theme-next 中已经有了图片预览功能。next 主题使用 Fancybox 库实现图片预览。Fancybox 是一个基于 jQuery 的可高度定制化的轻量级库，可以用于显示图片、视频，并可以响应很多交互操作。因为 next 主题使用的 v2 版本的 fancybox，而官方弃用了 fancybox v2 并推荐使用 fancybox v3，所以本文主要参照 fancybox 的 官方文档 并结合 material 主题结构特点折腾出图片查看功能。 折腾主题配置配置中新增 fancybox 配置项为了提高 material 主题的可扩展性和可控制性，在 主题配置 文件中加入 fancybox 字段： # Fancybox support fancybox: true 下载fancybox库点击这里 下载最新的 fancybox 库， 解压缩至 /theme/material/source/lib/ 目录下，这里贴出目录结构： lib └── fancybox ├── bower.json └── dist ├── jquery.fancybox.css ├── jquery.fancybox.js ├── jquery.fancybox.min.css └── jquery.fancybox.min.js 下载下来的 fancybox 只保留了 /dist 目录和 bower.json 文件，其他的非必需。 编写js将fancybox应用到页面中参考 next 主题的 /next/source/js/src/utils.js , 我在 /material/source/js/ 下新增了 wrapImage.js 用于在指定的 &lt;img&gt; 外裹一层 fancybox 所需要的属性（前端不熟，js写的可能很次 ORZ ）： $(document).ready(function() { wrapImageWithFancyBox(); }); /** * Wrap images with fancybox support. */ function wrapImageWithFancyBox() { $(&#39;img&#39;).not(&#39;.sidebar-image img&#39;).not(&#39;#author-avatar img&#39;).not(&quot;.mdl-menu img&quot;).each(function() { var $image = $(this); var imageCaption = $image.attr(&#39;alt&#39;); var $imageWrapLink = $image.parent(&#39;a&#39;); if ($imageWrapLink.size() &lt; 1) { var src = this.getAttribute(&#39;src&#39;); var idx = src.lastIndexOf(&#39;?&#39;); if (idx != -1) { src = src.substring(0, idx); } $imageWrapLink = $image.wrap(&#39;&lt;a href=&quot;&#39; + src + &#39;&quot;&gt;&lt;/a&gt;&#39;).parent(&#39;a&#39;); } $imageWrapLink.attr(&#39;data-fancybox&#39;, &#39;images&#39;); if (imageCaption) { $imageWrapLink.attr(&#39;data-caption&#39;, imageCaption); } }); $().fancybox({ selector : &#39;[data-fancybox=&quot;images&quot;]&#39;, thumbs : true, hash : false, loop : false, }); } 上述代码中，thumbs, hash, loop 等都是 fancybox 支持的属性，更多具体属性可参考 Fancybox Options head模版中引入 fancybox 库由于我们需要在 html 的 &lt;head&gt; 标签中引入 fancybox js库，所以我们找到 &lt;head&gt; 标签对应的模版文件 /material/layout/_partial/head.ejs, 利用之前配置的 fancybox 配置项在 head.ejs 中引入 fancybox: &lt;!-- fancybox support --&gt; &lt;% if(theme.fancybox === true) { %&gt; &lt;%- css(&#39;lib/fancybox/dist/jquery.fancybox.min&#39;) %&gt; &lt;%- js(&#39;lib/fancybox/dist/jquery.fancybox.min&#39;) %&gt; &lt;%- js(&#39;js/wrapImage.js&#39;) %&gt; &lt;% }%&gt; 以上，重新生成静态网页，会发现网页源码中会新增如下内容： &lt;head&gt; &lt;!-- ... --&gt; &lt;!-- fancybox support --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;../../lib/fancybox/source/jquery.fancybox.min.css&quot;&gt; &lt;script src=&quot;../../lib/fancybox/source/jquery.fancybox.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../../js/wrapImage.js&quot;&gt;&lt;/script&gt; &lt;!-- ... --&gt; &lt;/head&gt; 至此，图片点击放大预览效果已实现，撒花 ✿✿ヽ(ﾟ▽ﾟ)ノ✿ 展示点击图片进行浏览： 蕾姆 宫园薰 雏鹤爱 参考fancyBox3 Documentation]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo-theme-material</tag>
        <tag>Fancybox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打包导入BaiduExporter到Chrome教程（译）]]></title>
    <url>%2Fpost%2F934692094%2F</url>
    <content type="text"><![CDATA[本文主要译自 Guide on Packaging and Import Baidu Exporter to Chrome，并在一些细微之处做了补充或修改，所有解释权归属于原作者，侵删。 前言因为侵权的原因，Google 将 BaiduExporter 从 Chrome Web Store 下架。出于安全的原因， Chrome 会禁用从本地导入的未知来源的扩展。每次启动 Chrome 时，如果 Chrome 加载了已解压的扩展程序，都会出现提示禁用的弹窗。 所以本文提供了一个通过使用 Windows 组策略来加载最新版本 BaiduExporter 的解决方案。 下载BaiduExporter扩展从 这里 克隆或者下载最新的 BaiduExporter 扩展。 打包扩展如果你有编译好的版本，以下步骤不需要： 启动 Chrome, 打开 chrome://extensions， 勾选 开发者模式，在上方选择 打包扩展程序； 定位到之前下载的 BaiduExporter 源码（选择 /BaiduExporter/chrome/ 目录），点击 打包扩展程序； 源码目录下将会新生成 *.pem 文件，保留这些文件，如果以后要更新扩展将会用到 *.pem 文件； 将生成的 *.crx 文件拖到 chrome://extensions 页面来安装扩展。勾选 开发者模式 来显示和获取 扩展ID 使用组策略编辑器来应用Chrome策略 从 这里 下载 Chrome 模版的压缩文件 将以下文件或者文件夹下所有文件拷贝到以 %SystemRoot%\PolicyDefinitions（通常是 C:\Windows\PolicyDefinitions ） 为根目录的对应目录下： ./windows/admx/chrome.admx; ./windows/admx/google.admx; ./windows/admx/en-US/; ./windows/admx/zh-CN/。 按下 Win+R 组合键并运行 gpedit.msc 打开组策略编辑器，如果在 本地计算机策略 -&gt; 计算机配置 -&gt; 管理模版 下看到 Google/Google Chrome 子目录，则说明Chrome策略添加成功。（PS. 简易版和家庭版的 Windows 系统没有内置组策略编辑器。如果你使用的是这些 Windows 版本，你应该先参考这个教程来安装组策略编辑器） 将BaiduExporter的扩展ID添加至白名单通过以下步骤将扩展ID添加至白名单： 组策略编辑器中，导航至 本地计算机配置 -&gt; 管理模版 -&gt; Google -&gt; Google Chrome -&gt; 扩展程序 部分； 在右侧双击并打开 配置扩展程序安装白名单； 勾选左上角的 已启用，点击左下方的 显示，将 BaiduExporter 的扩展ID添加进去。 添加至白名单的扩展将会在 Chrome 重启之后默认加载。]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>BaiduExporter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BaiduExporter 介绍与使用]]></title>
    <url>%2Fpost%2F3364832428%2F</url>
    <content type="text"><![CDATA[介绍BaiduExporter 是一款可以方便地将百度网盘的下载地址导出为 aria2/aria2-rpc 链接的工具。 其原本是作为 Chrome 扩展而存在，但是因为某些原因而被 Google 从 Chrome Web Store 下架。所以需要自己依据 BaiduExporter 源码安装其 Chrome 扩展。 安装 将 BaiduExporter 扩展源码下载或克隆下来； 启动 Chrome, 打开 chrome://extensions 扩展页面，勾选 开发者模式，点击 加载已解压的扩展程序，导航至 /BaiduExporter/chrome/ 并选中 chrome 目录，点击确认。 上图便是 BaiduExporter(网盘助手) 加载成功的截图。 虽然上述方式安装 BaiduExporter 扩展是OK的，但是，每次重新打开 Chrome 后就会弹出警示对话框，内容如下： 停用开发者模式运行扩展的提示 为解决上述问题，可以参考 打包导入BaiduExporter到Chrome教程 使用BaiduExporter Chrome 插件安装并启用完毕后，我们在访问自己的百度网盘网页时会在上方多出 导出下载 的按钮（如下图所示），勾选需要下载的资源，点击 导出下载 -&gt; ARIA2 RPC 便可导出至 aria2 下载，当然，前提是你已经开启 aria2 并启用了 RPC 模式。百度网盘页面 至于如何查看和管理下载进度，则可参考 aria2 下载管理。 相关链接或参考 BaiduExporter 使用Aria2下载百度网盘和115的资源]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>BaiduExporter</tag>
        <tag>aria2</tag>
        <tag>百度网盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下载工具aria2 - 配置和使用]]></title>
    <url>%2Fpost%2F141514420%2F</url>
    <content type="text"><![CDATA[简介aria2 是一款支持跨平台、多源、多协议的轻量级的命令行式的下载工具。它支持 HTTP/HTTPS、FTP、SFTP、磁力链接以及 Medialink等多种下载方式。不仅如此，更值得称赞的是，aira2 还是一款开源免费的软件。 安装最新的 aria2 release版本下载地址 aria2 release。 注意：之前网上好多关于 aria2 的下载地址是在 sourceforge 上的，但是由于 aria2 已开源迁移至 GitHub，所以下载最新版本的还是需要找准地址。 aria2下载列表 通过上方官方给的下载列表可以看出，aria2支持的平台有 Windows、MacOS、Linux、Android。注意，本文只介绍 Windows 平台下的，其他平台烦请另行查阅资料。 Windows 平台只需下载对应位数的zip压缩包，解压缩即可。 解压后的目录结构如下，其体积是相当小的： aria2-1.32/ ├── aria2c.exe ├── AUTHORS ├── ChangeLog ├── COPYING ├── LICENSE.OpenSSL ├── NEWS ├── README.html └── README.mingw 配置接下来，在 aria2 目录下新建如下几个空文件来进行后续配置： aria2.conf - 配置文件 aria2.log - 日志文件 aria2.session - 下载记录文件 HideRun.vbs - 隐藏cmd窗口运行aria2所需要的文件 之后 aria2 的目录结构如下： aria2-1.32/ ├── aria2.conf ├── aria2.log ├── aria2.session ├── aria2c.exe ├── AUTHORS ├── ChangeLog ├── COPYING ├── HideRun.vbs ├── LICENSE.OpenSSL ├── NEWS ├── README.html └── README.mingw 配置 aria2.confaria2.conf 文件用于配置 aria2 运行时的相关参数，相关配置项可以参考 aria2配置示例。 aria2 有两种下载模式，一种是命令行下载模式，一种是 RPC Server 模式，前者不方便故不建议使用； RPC Server 模式就是把 aria2 当作服务端，通过 RPC 接口接受客户端的下载请求，因为是 Server 模式，aria2 下载完成并不会退出，会一直等待后续的下载请求。所以，需要在 aria2.conf 配置文件中将与 RPC 相关的配置项打开(enable)。 这里我贴出自己的配置文件： ## &#39;#&#39;开头为注释内容, 选项都有相应的注释说明, 根据需要修改 ## ## 被注释的选项填写的是默认值, 建议在需要修改时再取消注释 ## ## 文件保存相关 ## # 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置 dir=E:\Downloads # 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M #disk-cache=32M # 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc # 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc # falloc和trunc则需要文件系统和内核支持 # NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项 file-allocation=falloc # 断点续传 continue=true ## 下载连接相关 ## # 最大同时下载任务数, 运行时可修改, 默认:5 max-concurrent-downloads=4 # 同一服务器连接数, 添加时可指定, 默认:1 max-connection-per-server=5 # 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M # 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载 min-split-size=10M # 单个任务最大线程数, 添加时可指定, 默认:5 split=5 # 整体下载速度限制, 运行时可修改, 默认:0 #max-overall-download-limit=0 # 单个任务下载速度限制, 默认:0 #max-download-limit=0 # 整体上传速度限制, 运行时可修改, 默认:0 #max-overall-upload-limit=0 # 单个任务上传速度限制, 默认:0 #max-upload-limit=0 # 禁用IPv6, 默认:false disable-ipv6=true ## 进度保存相关 ## # 从会话文件中读取下载任务 input-file=D:\aria2\aria2-1.32\aria2.session # 在Aria2退出时保存`错误/未完成`的下载任务到会话文件 save-session=D:\aria2\aria2-1.32\aria2.session # 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0 save-session-interval=60 # log日志路径 默认没有log # log=D:\aria2\aria2-1.32\aria2.log ## RPC相关设置 ## # 启用RPC, 默认:false enable-rpc=true # 允许所有来源, 默认:false rpc-allow-origin-all=true # 允许非外部访问, 默认:false rpc-listen-all=true # 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同 #event-poll=select # RPC监听端口, 端口被占用时可以修改, 默认:6800 #rpc-listen-port=6800 # 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项 #rpc-secret=&lt;TOKEN&gt; # 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项 #rpc-user=&lt;USER&gt; # 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项 #rpc-passwd=&lt;PASSWD&gt; ## BT/PT下载相关 ## # 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true #follow-torrent=true # BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999 listen-port=51413 # 单个种子最大连接数, 默认:55 #bt-max-peers=55 # 打开DHT功能, PT需要禁用, 默认:true enable-dht=false # 打开IPv6 DHT功能, PT需要禁用 #enable-dht6=false # DHT网络监听端口, 默认:6881-6999 #dht-listen-port=6881-6999 # 本地节点查找, PT需要禁用, 默认:false #bt-enable-lpd=false # 种子交换, PT需要禁用, 默认:true enable-peer-exchange=false # 每个种子限速, 对少种的PT很有用, 默认:50K #bt-request-peer-speed-limit=50K # 客户端伪装, PT需要 peer-id-prefix=-TR2770- user-agent=Transmission/2.77 # 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0 seed-ratio=0 # 强制保存会话, 即使任务已经完成, 默认:false # 较新的版本开启后会在任务完成后依然保留.aria2文件 #force-save=false # BT校验相关, 默认:true #bt-hash-check-seed=true # 继续之前的BT任务时, 无需再次校验, 默认:false bt-seed-unverified=true # 保存磁力链接元数据为种子文件(.torrent文件), 默认:false bt-save-metadata=true 更多更详尽的配置项请参考官方 manual 配置 HideRun.vbsHideRun.vbs 文件的目的是就是让 aria2 隐藏 cmd 窗口运行。往 HideRun.vbs 写入如下脚本内容： CreateObject(&quot;WScript.Shell&quot;).Run &quot;aria2c.exe --conf-path=aria2.conf -D&quot;,0 通过 HideRun.vbs 内容我们可以知道， aria2c.exe 每次在运行时是要去加载 aria2.conf 配置文件的，所以需要双击 HideRun.vbs 来启动aria2，而不是双击 aria2c.exe。 下载管理aria2 是基于命令行的下载工具，本身是没有用于管理的界面的，一切都基于命令行，但有基于网页的管理界面（webui）： aria2官网提及的 webui-aria2 项目 Binux大大的 YAAW 在这里我推荐 aria2 官网提及的 webui-aria2 作为Web管理界面，因为就目前看来它更好用 XD。 webui-aria2 的使用有以下方式使用 webui-aria2： 直接访问 在线的 webui-aria2 页面 来进行 aria2 的下载管理，一般来说选用这个就行； 通过将 webui-aria2 这个repo下载下来，然后打开 index.html 来进行 aria2 的下载管理； 在使用 webui-aria2 进行 aria2 的下载管理前，可能需要在web管理页面进行相关配置：设置 -&gt; 连接设置 -&gt; Aria2 RPC 主机和端口，需要根据提示完成相应的配置（具体需要填什么内容取决于之前的 aria2.conf的配置）。 在这里贴上我的 webui-aria2 的连接设置，因为令牌等都未启用，所以都是空：webui-aria2 在 webui-aria2 管理界面上，可以点击 添加 来添加链接、种子或 Medialink，来新增 aria2 的下载任务。更多其他操作（包括暂定、删除、重新下载等），在web界面上都有相应的入口，很简单，这里就不再详细介绍了。 最后附一张 webui-aria2 管理界面截图： webui-aria2 管理界面 进阶 结合 BaiduExporter(网盘助手) 越过某(bai)度网盘下载速度限制，从而高速下载网盘文件，详情请戳 BaiduExporter 介绍与使用 相关链接或参考 用火狐我喜欢用aria2下载，写写windows下教程吧 Aria2 &amp; YAAW 使用说明 aria2 webui-aria2]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>aria2</tag>
        <tag>下载工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[炉石开包引发的血案（雾]]></title>
    <url>%2Fpost%2F1310087385%2F</url>
    <content type="text"><![CDATA[昨天星苏直播开炉石卡包，并发起对应的竞猜，竞猜内容大致是： 50包卡包中，出现橙卡数目的奇偶性。 然后就有弹幕说：“哎呀，猜单双多没意思呀，可能性一样，赔率不会悬殊，没意思。” 那么，奇偶出现的可能性是一样吗？ 模型建立暴雪爸爸前段时间发布了关于《炉石传说》卡牌包抽取概率公告，其中有两条关键信息： 平均20个炉石卡牌包，可获得一张传说品质卡牌。此外，需要说明的是：随着卡牌包抽取数量的增多，玩家实际获得高品质卡牌的概率也将同步提高。 通过官方的说明，加上对开包已有的认知，可以将 卡牌包抽取&nbsp; 行为近似抽象为 伯努利试验(或 重复独立试验)。由于卡牌包抽取数量的增大，获得传说（橙卡）的概率也会相应提高，也就是前面的试验结果会对后续的试验结果产生一定影响，故而这里的 伯努利试验&nbsp; 模型并不十分精确。但在开包数目相对较小的情况下，我们还是可以使用 伯努利试验&nbsp; 进行近似建模抽象的。毕竟，官方没有透露任何关于卡牌包出传说概率模型的消息，也只能用 伯努利试验&nbsp; 对其进行简单抽象了。 另外，这里也可以得知，单包出橙卡的概率为 1/20 即 0.05。 在 n 次重复独立试验中，用 $\xi$ 表示事件A发生的次数，用 p 表示事件A在单次试验中发生的概率，则事件A发生 k 次的概率 P 为：$$P(\xi = k) = C_n^k \cdot p^k \cdot (1-p)^{n-k}$$建立了数学模型，可以方便解决问题了。~\(≧▽≦)/~ 编码实现/** * 重复独立试验 * @author Tianma * */ public class BernoulliExperiment { /** * 重复独立试验(伯努利试验)，单次出现概率为p(0&lt;p&lt;1)的情况下，重复独立试验n次，返回命中k次的概率 * &lt;p&gt; * P(k,n,p) = C(n,k)*(p^k)*((1-p)^(n-k)),其中(k = 0,1,2,...,n) */ public double probability(int n, int k, double p) { return combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k); } /** * 计算C(n,m)组合数的值 */ public long combination(int n, int m) { long[] arr = new long[m + 1]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = 1; } for (int i = 1; i &lt;= n - m; i++) { for (int j = 1; j &lt;= m; j++) { arr[j] += arr[j - 1]; } } return arr[m]; } public static void main(String[] args) { BernoulliExperiment bernoulli = new BernoulliExperiment(); double p = 0.05; int n = 50; double oddProbability = 0, evenProbability = 0; for (int i = 0; i &lt;= n; i++) { double probability = bernoulli.probability(n, i, p); if (i % 2 == 0) { evenProbability += probability; } else { oddProbability += probability; } } System.out.println(&quot;Odd probability : &quot; + oddProbability); System.out.println(&quot;Even probability : &quot; + evenProbability); System.out.println(&quot;Odd + Even : &quot; + (evenProbability + oddProbability)); } } 上述代码中涉及到组合数的计算，详情可以看之前的博客 组合数的计算。 运行结果如下： Odd probability : 0.497423112396339 Even probability : 0.502576887603659 Odd + Even : 0.999999999999998 从运行结果我们可以看出，50个卡包开出橙卡数目的奇偶性的概率大致一样，但还是有略微差别。如果对 n 和 p 取不同的值，得到的奇偶性概率差又会不一致。也就是说，需要经过一定的计算才能判断最终结论走向。 最后的最后，想说一句，芝士就是力量（大雾） ╰(￣▽￣)╮]]></content>
      <categories>
        <category>Algorithm &amp; Data Structure</category>
      </categories>
      <tags>
        <tag>伯努利试验</tag>
        <tag>概率学</tag>
        <tag>Hearth Stone</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数的计算]]></title>
    <url>%2Fpost%2F285069090%2F</url>
    <content type="text"><![CDATA[组合数的计算虽然在一般的编程领域中不太能用到，但是在数学相关领域及ACM中还是有其用武之地的。那么，如何在程序中计算组合数呢？ 累乘计算我们知道：$$C_{n}^{m}=\frac {A_{n}^{m}}{m!}=\frac {n!}{m!\left(n-m\right)!} , (0\leq m\leq n) \tag{1}$$$$C_{n}^{m}=\frac {n\cdot(n-1)\ldots(n-m+1)}{m!}, (0\leq m\leq n) \tag{2}$$ 通过公式(1)和公式(2)，可以简单的依据公式来进行组合数的计算。但因为公式中涉及到阶乘运算（准确说是连乘运算），故而会存在数据溢出的问题，因而不推荐。 累加计算为了避免直接计算阶乘，可以对公式（1）两边取对数：$$\ln(C_{n}^{m}) = \ln(n!) - \ln(m!) - \ln((n-m)!) = \sum_{i=1}^{n}\ln(i) - \sum_{i=1}^{m}\ln(i) - \sum_{i=1}^{n-m}\ln(i) \tag{3}$$又因为：$$\sum_{i=1}^{n}\ln(i) = \sum_{i=1}^{m}\ln(i) + \sum_{i=m+1}^{n}\ln(i) \tag{4}$$将（4）代入等式右边可得：$$\ln(C_{n}^{m}) = \sum_{i=m+1}^{n}\ln(i) - \sum_{i=1}^{n-m}\ln(i) \tag{5}$$ 观察式（5）右侧，其累加的次数为 $[n-(m+1)+1]+[(n-m)-1+1]=2×(n-m)$次，在n的值一定的情况下，m越小，累加次数越多。而我们知道：$C_{n}^{m}=C_{n}^{n-m}$，当 $m&lt;n/2$ 时，直接计算 $C_n^m$ 则累加次数较多，此时，我们可以通过计算 $C_{n}^{n-m}$ 来间接得到 $C_{n}^{m}$ 的值，从而减少累加次数，提高运算效率。 最后，我们可以通过两边取e的指数幂，最终计算出组合数 $C_{n}^{m}$ 的值。 Java实现： /** * 计算C(n,m)组合数的值 */ public long combination1(int n, int m) { double result = 0; if (m &gt; n) { return 0; } if (m &lt; n / 2) { m = n - m; } for (int i = m + 1; i &lt;= n; i++) { result += Math.log(i); } for (int i = 1; i &lt;= n - m; i++) { result -= Math.log(i); } return Math.round(Math.exp(result)); } 上述方案相较于之前的累乘计算方案有明显的优化提高。值得注意的是，虽然自然常数 e 是常数，但因其为无限不循环小数，在Java代码中，实际计算时 e 取的是其近似值，所以上述代码在 n 的值较大时，会出现计算结果的偏差。n 的值较小的情况下，其准确性还是可以保障的。 精确计算组合数公式中，还有一个恒等式：$$C_{n}^{m} = C_{n-1}^{m} + C_{n-1}^{m-1}, (1&lt;m&lt;n) \tag{6}$$ 又因为：$C_{n}^{0} = C_{n}^{n} = 1$, 所以最终可以得到：$$C_{n}^{m} =\begin{cases} 1 &amp; (m = 0)\\ C_{n-1}^{m} + C_{n-1}^{m-1} &amp; (1\leq m&lt;n)\\ 1 &amp; (m = n)\end{cases}\tag{7}$$ 看到公式（7）我们很容易想到可以用递归去计算 $C_{n}^{m}$ 的值，这也不失为一种方案，然而因为在递归过程中会出现不少重复值（存在重复计算），且递归过程较为浪费栈内存，在这里就不详细介绍该方案。 我们以 $C_{5}^{3}$ 为例，建立如下矩阵：$$\begin{matrix}C_0^0 &amp; C_1^1 &amp; C_2^2 &amp; C_3^3 \\C_1^0 &amp; C_2^1 &amp; C_3^2 &amp; C_4^3 \\C_2^0 &amp; C_3^1 &amp; C_4^1 &amp; C_5^3\end{matrix}$$在这上述矩阵中，依据公式（6），我们可以看出，每个位置上的组合数的值都等于其左边和其上边的组合数之和。也就是说，只要知道第一行和第一列各组合数的值，则可以以加法的形式计算出整个矩阵其他位置的组合值。而根据公式（7），我们知道，第一行和第一列各组合数的值均为1。 我们归纳出 $C_n^m$ 对应的矩阵：$$\begin{matrix}C_0^0 &amp; C_1^1 &amp; C_2^2 &amp; \cdots &amp; C_m^m \\C_1^0 &amp; C_2^1 &amp; C_3^2 &amp; \cdots &amp; C_{m+1}^m \\C_2^0 &amp; C_3^1 &amp; C_4^2 &amp; \cdots &amp; C_{m+2}^m \\\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\C_{n-m}^0 &amp; C_{n-m+1}^1 &amp; C_{n-m+2}^2 &amp; \cdots &amp; C_n^m\end{matrix}$$第1行和第1列的值均为1，可以根据第1行计算出第2行各位置的值，再可由第2行计算出第3行各位置的值，如此循环，便可计算出 $C_n^m$ 的值。 Java实现 /** * 计算C(n,m)组合数的值 */ public long combination2(int n, int m) { long[] arr = new long[m + 1]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = 1; } for (int i = 1; i &lt;= n - m; i++) { for (int j = 1; j &lt;= m; j++) { arr[j] += arr[j - 1]; } } return arr[m]; } 上述方法，只开辟了 m+1 个长度的长整型数组，空间占有率较小，空间复杂度小。因为有两层循环，其平均时间效率不如累加的计算方案，但它是精准计算，计算出的组合数值没有偏差。综合来看，较为推荐最后这种方案来计算组合数值。 参考组合-维基百科组合数-百度百科大数量级组合数的快速计算方法基础算法学习-求组合数]]></content>
      <categories>
        <category>Algorithm &amp; Data Structure</category>
      </categories>
      <tags>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[熊猫tv竞猜引发的组合问题]]></title>
    <url>%2Fpost%2F2324484737%2F</url>
    <content type="text"><![CDATA[背景今天晚上在看秋日播炉石的时候，发现最近熊猫tv加入了竞猜活动，可以通过该活动来获取竹子（熊猫tv中货币之一），嘛~ 这就是一娱乐活动嘛。 这次秋日主要竞猜的内容有两个： 远古雕文发现的三张法术牌费用总和是否小于某一值 秘法宝典开出来的三张法术牌费用总和是否小于某一值 看到这个我就心血来潮了，这并不是以往的只能靠运气来赢得奖励的竞猜活动，而是可以通过数学分析进行量化的，因为其实这就是排列组合中的组合问题嘛： 当前版本标准模式下，法师的法术牌一共有31张（除去任务橙 “打开时空之门”） 远古雕文发现的三张法术不可重复，也就是不可重复取的组合问题：从n个元素中不可重复抽m次 秘法宝典开出的三张法术牌可重复，也就是可重复取的组合问题：从m个元素中可重复抽m次 上述问题可以用数学手段去解决，亦可以用编程去解决，因为懒得去分析各种可能的有效情况，所以直接用代码去解决了… 代码解决package tianma.exercise; public class Combination { // 总组合数 private int globalCounter = 0; // 合法组合数 private int validCounter = 0; /** * 从n个数据中选取m个的组合（不可重复取）, 小于临界值的有效 */ public void combineUnrepeatable(int[] input, int m, int threshold) { combine(input, m, threshold, false); } /** * 从n个数中选取m次的组合（可重复取），小于临界值的有效 */ public void combineRepeatable(int[] input, int m, int threshold) { combine(input, m, threshold, true); } private void combine(int[] input, int m, int threshold, boolean repeatable) { if (input == null || input.length == 0 || m &lt;= 0 || m &gt; input.length) { throw new RuntimeException(&quot;参数错误&quot;); } int[] out = new int[m]; innerCombine(input, m, 0, out, 0, threshold, repeatable); float ratio = 1.0f * validCounter / globalCounter; System.out.println(&quot;总次数 = &quot; + globalCounter + &quot;, 小于 &quot; + threshold + &quot;的命中次数 = &quot; + validCounter + &quot;, 命中率 = &quot; + ratio); globalCounter = validCounter = 0; } private void innerCombine(int[] input, int m, int beginIdx, int[] out, int index, int threshold, boolean repeatable) { if (m == 0) { int total = 0; for (int i = 0; i &lt; index; i++) { System.out.print(out[i] + &quot; &quot;); total += out[i]; } if (total &lt; threshold) { validCounter++; System.out.print(&quot;*&quot;); } globalCounter++; System.out.println(); return; } for (int i = repeatable ? 0 : beginIdx; i &lt; input.length; i++) { out[index] = input[i]; innerCombine(input, m - 1, i + 1, out, index + 1, threshold, repeatable); } } public static void main(String[] args) { // 法师31张法术法力值数组 int[] in = { 0, 0, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 6, 6, 7, 7, 7, 10 }; int m = 3; int threshold = 11; boolean repeatable = true; Combination combination = new Combination(); combination.combine(in, m, threshold, repeatable); } } 花絮在后续的竞猜中我发现一个有趣的现象：某次秘法宝典竞猜截图程序跑出的结果： 总次数 = 29791, 小于 11的命中次数 = 16193, 命中率 = 0.5435534 也就是说 “小于11” 的概率其实比 “大于10” 的概率要高，但是前者的”赔率”却比后者高。因为参加竞猜的大多数观众是凭直觉下注的，所以可以得出的结论是，有时候凭借直觉往往是错的，数学理论的支持才是王道，红红火火恍恍惚惚 ╰_╯]]></content>
      <categories>
        <category>Algorithm &amp; Data Structure</category>
      </categories>
      <tags>
        <tag>概率学</tag>
        <tag>Hearth Stone</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 跳转至微博用户个人信息页面]]></title>
    <url>%2Fpost%2F3914813049%2F</url>
    <content type="text"><![CDATA[最近需要去实现应用内跳转至微博的个人信息页面（用户个人主页），其本质就是打开并跳转至第三方App指定的页面。显然，我们可以通过调用 startActivity(intent) 来实现该功能，其关键就是 intent 中需要携带哪些信息。 反编译 AndroidManifest.xml将新浪微博的apk文件中的 AndroidManifest.xml 文件解压提取出来，然后使用 AXMLPrinter2.jar 对清单文件进行反编译： java -jar AXMLPrinter2.jar AndroidManifest.xml &gt; weibo.xml 其中 weibo.xml 即反编译成功的清单文件。 获取微博个人页 Activity因为之前 weibo.xml 中的 Activity 过多，我们需要知道微博的用户个人信息页面对应的 Activity 全称。这里有两种方法： 使用辅助App来获取当前的 Activity ，例如 当前界面(当前Activity) ，具体用法这里就不介绍了。 使用 adb 命令获取当前 Activity： adb shell dumpsys activity activities | grep mFocusedActivity 当我们把新浪微博的个人信息页面切至前台时， adb 命令的结果为： mFocusedActivity: ActivityRecord{9063f6f u0 com.sina.weibo/.page.ProfileInfoActivity t1578} 也就是说，新浪微博的个人信息页对应的 Activity 为 com.sina.weibo.page.ProfileInfoActivity, 那我们看 weibo.xml 中与该 Activity 对应的 xml 节点： &lt;activity android:theme=&quot;@7F0B0011&quot; android:name=&quot;com.sina.weibo.page.ProfileInfoActivity&quot; android:exported=&quot;true&quot; android:configChanges=&quot;0x000004A0&quot; android:windowSoftInputMode=&quot;0x00000020&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot;&gt;&lt;/action&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;&gt;&lt;/category&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;&gt;&lt;/category&gt; &lt;data android:scheme=&quot;sinaweibo&quot; android:host=&quot;userinfo&quot;&gt;&lt;/data&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot;&gt;&lt;/action&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;&gt;&lt;/category&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;&gt;&lt;/category&gt; &lt;data android:scheme=&quot;http&quot; android:host=&quot;weibo.cn&quot; android:path=&quot;/qr/userinfo&quot;&gt;&lt;/data&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot;&gt;&lt;/action&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;&gt;&lt;/category&gt; &lt;data android:mimeType=&quot;vnd.android.cursor.item/vnd.com.sina.weibo.profile&quot;&gt;&lt;/data&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 分析上面的 xml 节点中，可以看到 android:exported=&quot;true&quot;，也就是说 ProfileInfoActivity 可以被外部程序调用打开。有三个 intent-filter 节点，其中第三个 intent-filter 与 ContentProvider 有关，可以忽略第三个只考虑前两个。第一个 intent-filter 接受的 data 格式为 sinaweibo:userinfo， 第二个 intent-filter 接受的 data 格式为 http://weibo.cn/qr/userinfo。 我们通过 data 节点的数据可以判断除，第二个除了可以被新浪微博响应，也可以被浏览器之类的应用响应，但第一个只能被新浪微博响应，所以在使用第一个之前，需要判断新浪微博是否已经安装，否则会崩溃。 实现通过查阅相关文档，ProfileInfoActivity 可以接受的参数为 uid=xxx, 也就是 sinaweibo://userinfo?uid=xxx 和 http://weibo.cn/qr/userinfo?uid=xxx，所以最终代码实现： // 跳转至微博个人页 public void jumpToWeiboProfileInfo(Context context, String uid) { Intent intent = new Intent(Intent.ACTION_VIEW); intent.addCategory(Intent.CATEGORY_DEFAULT); intent.addCategory(Intent.CATEGORY_BROWSABLE); boolean weiboInstalled = PackageUtils.isSinaWeiboInstalled(context); if (weiboInstalled) { intent.setData(Uri.parse(&quot;sinaweibo://userinfo?uid=&quot; + uid)); } else { intent.setData(Uri.parse(&quot;http://weibo.cn/qr/userinfo?uid=&quot; + uid)); } context.startActivity(intent); } // PackageUtils.java public class PackageUtils { private PackageUtils(){} // 新浪微博是否安装 public static boolean isSinaWeiboInstalled(Context context) { return isPackageInstalled(context, &quot;com.sina.weibo&quot;); } // 包名对应的App是否安装 public static boolean isPackageInstalled(Context context, String packageName) { PackageManager packageManager = context.getPackageManager(); if (packageManager == null) return false; List&lt;PackageInfo&gt; packageInfoList = packageManager.getInstalledPackages(0); for(PackageInfo info : packageInfoList) { if (info.packageName.equals(packageName)) return true; } return false; } } 参考调用新浪微博显示用户信息]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Weibo</tag>
        <tag>Decompile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView添加分割线]]></title>
    <url>%2Fpost%2F1138009507%2F</url>
    <content type="text"><![CDATA[RecyclerView 并没有 divider 属性，但是我们可以通过 RecyclerView 的 addItemDecoration() 来添加分割线，该方法参数为 RecyclerView.ItemDecoration。 介绍当 RecyclerView 添加 ItemDecoration 后，RecyclerView 在绘制每个 item 的时候，会去绘制 decorator，也就是会调用 ItemDecoration 的 onDraw() 和 onDrawOver() 方法。 RecyclerView.ItemDecoration 是抽象类，主要提供三个方法： onDraw(Canvas c, RecyclerView parent, State state)： 在绘制item（drawChild） 前调用 onDrawOver(Canvas c, RecyclerView parent, State state): 在绘制item（drawChild） 后调用 getItemOffsets(Rect outRect, View view, RecyclerView parent, State state)：outRect设置 item 的偏移量，用于绘制 decorator（也就是divider） 关于 getItemOffsets 函数：RecyclerView 添加分割线，实际上就是 RecyclerView 的 item 之间添加了用作分割线的View，自然而然后续的 item 就会有偏移量，所以用 getItemOffsets 中的 outRect 来保存 item 的偏移量，从而便于绘制 decorator。 实现实际上在当前版本的 RecyclerView (25.3.1) 中已经有 ItemDecoration 关于分割线的默认实现类 DividerItemDecoration: package android.support.v7.widget; import android.annotation.SuppressLint; import android.content.Context; import android.content.res.TypedArray; import android.graphics.Canvas; import android.graphics.Rect; import android.graphics.drawable.Drawable; import android.support.annotation.NonNull; import android.support.v4.view.ViewCompat; import android.view.View; import android.widget.LinearLayout; public class DividerItemDecoration extends RecyclerView.ItemDecoration { public static final int HORIZONTAL = LinearLayout.HORIZONTAL; public static final int VERTICAL = LinearLayout.VERTICAL; // 如果不设置，则默认的分割线为 android.R.attr.listDivider 指定的 drawable private static final int[] ATTRS = new int[]{ android.R.attr.listDivider }; private Drawable mDivider; /** * Current orientation. Either {@link #HORIZONTAL} or {@link #VERTICAL}. */ private int mOrientation; private final Rect mBounds = new Rect(); /** * Creates a divider {@link RecyclerView.ItemDecoration} that can be used with a * {@link LinearLayoutManager}. * * @param context Current context, it will be used to access resources. * @param orientation Divider orientation. Should be {@link #HORIZONTAL} or {@link #VERTICAL}. */ public DividerItemDecoration(Context context, int orientation) { final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); a.recycle(); setOrientation(orientation); } /** * Sets the orientation for this divider. This should be called if * {@link RecyclerView.LayoutManager} changes orientation. * * @param orientation {@link #HORIZONTAL} or {@link #VERTICAL} */ public void setOrientation(int orientation) { if (orientation != HORIZONTAL &amp;&amp; orientation != VERTICAL) { throw new IllegalArgumentException( &quot;Invalid orientation. It should be either HORIZONTAL or VERTICAL&quot;); } mOrientation = orientation; } /** * Sets the {@link Drawable} for this divider. * * @param drawable Drawable that should be used as a divider. */ public void setDrawable(@NonNull Drawable drawable) { if (drawable == null) { throw new IllegalArgumentException(&quot;Drawable cannot be null.&quot;); } mDivider = drawable; } @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) { if (parent.getLayoutManager() == null) { return; } if (mOrientation == VERTICAL) { drawVertical(c, parent); } else { drawHorizontal(c, parent); } } // 绘制 RecyclerView 为垂直布局时的分割线，此时分割线为水平分割线 @SuppressLint(&quot;NewApi&quot;) private void drawVertical(Canvas canvas, RecyclerView parent) { canvas.save(); final int left; final int right; // 需要考虑clipToPadding的boolean值 if (parent.getClipToPadding()) { left = parent.getPaddingLeft(); right = parent.getWidth() - parent.getPaddingRight(); canvas.clipRect(left, parent.getPaddingTop(), right, parent.getHeight() - parent.getPaddingBottom()); } else { left = 0; right = parent.getWidth(); } final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); parent.getDecoratedBoundsWithMargins(child, mBounds); final int bottom = mBounds.bottom + Math.round(ViewCompat.getTranslationY(child)); final int top = bottom - mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(canvas); } canvas.restore(); } // 绘制 RecyclerView 为水平布局时的分割线，此时分割线为垂直分割线 @SuppressLint(&quot;NewApi&quot;) private void drawHorizontal(Canvas canvas, RecyclerView parent) { canvas.save(); final int top; final int bottom; // 需要考虑clipToPadding的boolean值 if (parent.getClipToPadding()) { top = parent.getPaddingTop(); bottom = parent.getHeight() - parent.getPaddingBottom(); canvas.clipRect(parent.getPaddingLeft(), top, parent.getWidth() - parent.getPaddingRight(), bottom); } else { top = 0; bottom = parent.getHeight(); } final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); parent.getLayoutManager().getDecoratedBoundsWithMargins(child, mBounds); final int right = mBounds.right + Math.round(ViewCompat.getTranslationX(child)); final int left = right - mDivider.getIntrinsicWidth(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(canvas); } canvas.restore(); } @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) { if (mOrientation == VERTICAL) { // 垂直方向的RecyclerView, item 的 bottom 偏移量 = 分割线高度 outRect.set(0, 0, 0, mDivider.getIntrinsicHeight()); } else { // 水平方向的RecyclerView， item 的 right 偏移量 = 分割线宽度 outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0); } } } 在代码中添加： recyclerView.addItemDecoration(new DividerItemDecoration(recyclerView.getContext(), mLayoutManager.getOrientation())); 就有了分割线。 默认的分割线效果是系统自带的 listDivider 的效果，我们也可以在主题配置文件中自定义全局的分割线，或者调用 setDivider 为每个 RecyclerView 设置单独的分割线。 网络流行代码存在的问题目前好多博客中关于 DividerItemDecoration 中 drawVertical() 和 drawHorizontal() 方法与官方的方法其实是有出入的： public void drawVertical(Canvas c, RecyclerView parent) { final int left = parent.getPaddingLeft(); final int right = parent.getWidth() - parent.getPaddingRight(); // 网上的方法最主要的问题是没有考虑 clipToPadding 这个参数，所以说这里缺少相应代码片段 final int childCount = parent.getChildCount(); // 下面这块没什么问题，和官方方案殊途同归 // 官方的getDecoratedBoundsWithMargins实际上也是通过 LayoutParams 来获取分割线边界的 for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int top = child.getBottom() + params.bottomMargin; final int bottom = top + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); } } public void drawHorizontal(Canvas c, RecyclerView parent) { final int top = parent.getPaddingTop(); final int bottom = parent.getHeight() - parent.getPaddingBottom(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int left = child.getRight() + params.rightMargin; final int right = left + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); } } 注释中说的比较明确了，网上好多方法主要的问题在于 没有考虑 clipToPadding 属性值 。 clipToPadding 表示控件的绘制区域是否在 padding 区域外面，其默认值为 true。比如，垂直方向的 RecyclerView，当 clipToPadding=false 时，其初始绘制区域与 padding 值有关，但向上滑动时，RecylerView 的 item 会滑到 padding 区域里面。 下面用示意图来进行解释，RecyclerView 的 paddingTop = 40dp, clipToPadding = false, 下图中白色区域为 paddingTop 区域：初始状态下向上滑动 小结总的来说，目前添加分割线只需要使用 recyclerview-v7 包下的 DividerItemDecoration 类即可，分割线可以通过 setDivider 来个性化指定，也可以通过配置主题中的 android:listDivider 来全局指定。 参考Android RecyclerView 使用完全解析 体验艺术般的控件RecyclerView系列之二：添加分隔线android:clipToPadding和android:clipChildren]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Android Studio中使用Lambda表达式]]></title>
    <url>%2Fpost%2F837474051%2F</url>
    <content type="text"><![CDATA[Lambda 表达式是 Java 8 的新特性之一，本文主要介绍如何让 Android 项目集成 Labmda 表达式功能。 已知的集成方式有两种： 使用官方的 Jack 工具链 启用Java 8 功能 使用第三方库 Retrolambda 启用 Java 8功能 在本人使用过程中发现，通过 Jack 集成的方式，存在一些问题（不仅仅是官方声明的问题），所以在这里 推荐使用 Retrolambda 来集成 Lambda 功能。 2017-06-05 更新： 通过在不同的SDK版本上测试发现，Android M (api 23)以下版本中，不论是 Jack 还是 Retrolambda 的集成方式均会偶现 NoClassDefFoundError，并都没有成型的解决方案，所以以下诸君看看便可，不太能付诸实际项目中~ :( 官方Jack集成在模块级别的 build.gradle 中配置： android { ... defaultConfig { ... jackOptions { // 开启 Jack enabled true } } compileOptions { // 使用 Java 8 进行编译 sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } } 当然你首先得有 JDK 8 的开发环境。 第三方Retrolambda集成因为 Android Studio 使用 Gradle 作为构建工具，所以我们需要在集成 gradle-retrolambda Gradle 插件： 下载安装 JDK 8 在项目级别（项目根目录）的 build.gradle 中加入： buildscript { repositories { ... mavenCentral() // 加入 mavenCentral } dependencies { ... classpath &#39;me.tatarka:gradle-retrolambda:3.6.1&#39; // 将retrolambda加入classpath } } allProjects { repositories { ... mavenCentral() // 加入 mavenCentral } } 在模块级别的 build.gradle 中加入： apply plugin: &#39;com.android.application&#39; apply plugin: &#39;me.tatarka.retrolambda&#39; // 引入 retrolambda 插件 android { ... compileOptions { // 使用 Java 8 进行编译 sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } } 在混淆文件中加入 -dontwarn java.lang.invoke.* -dontwarn **$$Lambda$* 之后就可以愉快的使用 Lambda 表达式啦~]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Lambda Expression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FloatingActionButton的滚动隐藏和显示]]></title>
    <url>%2Fpost%2F4166466910%2F</url>
    <content type="text"><![CDATA[概述FloatingActionButton（FAB）其实就是遵循了 Material Design 设计规范的并拥有特定动作行为的 ImageButton，基本用法参照 ImageButton 即可。 比如说，可以在 RecyclerView 向下滚动的时候隐藏 FAB, 向上滚动的时候显示 FAB: FAB演示动画 那么，如何实现上面 FAB 的滚动隐藏和显示动画呢？ 实现我们需要通过导入 Design Support Library 才能使用 FAB, 所以，需要在 build.gradle 中加入 compile &#39;com.android.support:design:X.X.X&#39; 其中 X 代表 Support Library 的版本。 一般来说，我们需要把 FAB 放在 CoordinatorLayout 布局中， CoordinatorLayout 可以看做为 FrameLayout，其特殊之处在于可以协调子控件的交互，其中就包括FAB的滚动隐藏和显示的动画。 那么，演示动画中的布局为： &lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recycler_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; &lt;android.support.design.widget.FloatingActionButton android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom|end&quot; android:layout_margin=&quot;16dp&quot; android:src=&quot;@drawable/ic_add_white&quot; app:layout_behavior=&quot;com.tianma.recyclerviewsample.fab.FabScrollBehavior&quot; app:elevation=&quot;4dp&quot;/&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; app:elevation 属性表示 FloatingActionButton 悬浮的高度，高度越大，投影范围越大，投影效果越淡；高度越小，投影范围越小，投影效果越明显。 app:layout_behavior 属性表示 FloatingActionButton 所实现的 CoordinatorLayout Behavior, 这个属性指定的 Behavior 用于定义 FloatingActionButton 与在同一个 CoordinatorLayout 布局下的其他控件的交互方式。如果不指定自定义的 Behavior，那么FloatingActionButton 默认的 Behavior 是为 Snackbar 留出空间，详见 演示视频 显然， FAB 默认的 Behavior 不能满足我们的需要，那么就需要自定义 Behavior 来实现 FAB 的滚动显示和隐藏动画： package com.tianma.recyclerviewsample.fab; import android.content.Context; import android.support.design.widget.CoordinatorLayout; import android.support.design.widget.FloatingActionButton; import android.support.v4.view.ViewCompat; import android.util.AttributeSet; import android.view.View; import android.view.animation.LinearInterpolator; public class FabScrollBehavior extends FloatingActionButton.Behavior { // 因为需要在布局xml中引用，所以必须实现该构造方法 public FabScrollBehavior(Context context, AttributeSet attrs) { super(context, attrs); } @Override public boolean onStartNestedScroll(final CoordinatorLayout coordinatorLayout, final FloatingActionButton child, final View directTargetChild, final View target, final int nestedScrollAxes) { // 确保滚动方向为垂直方向 return nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL; } @Override public void onNestedScroll(final CoordinatorLayout coordinatorLayout, final FloatingActionButton child, final View target, final int dxConsumed, final int dyConsumed, final int dxUnconsumed, final int dyUnconsumed) { super.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed); if (dyConsumed &gt; 0) { // 向下滑动 animateOut(child); } else if (dyConsumed &lt; 0) { // 向上滑动 animateIn(child); } } // FAB移出屏幕动画（隐藏动画） private void animateOut(FloatingActionButton fab) { CoordinatorLayout.LayoutParams layoutParams = (CoordinatorLayout.LayoutParams) fab.getLayoutParams(); int bottomMargin = layoutParams.bottomMargin; fab.animate().translationY(fab.getHeight() + bottomMargin).setInterpolator(new LinearInterpolator()).start(); } // FAB移入屏幕动画（显示动画） private void animateIn(FloatingActionButton fab) { fab.animate().translationY(0).setInterpolator(new LinearInterpolator()).start(); } } 上述代码的关键就是找到 “隐藏动画” 和 “显示动画” 触发的时机，然后利用 “属性动画” 来实现对应的动画效果即可。 参考链接：Floating Action Buttons Guides]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>FloatingActionButton</tag>
        <tag>Material Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监听RecyclerView是否滑动到底部]]></title>
    <url>%2Fpost%2F188185634%2F</url>
    <content type="text"><![CDATA[最近想动手实现 RecyclerView 的“自动加载更多”功能，即当 RecyclerView 滑动到底部时，执行加载更多操作。这里的关键在于，需要监听RecyclerView是否滑动到底部。 分析RecyclerView 有 addOnScrollListener(OnScrollListener) 方法，可以为 RecyclerView 添加滚动监听，其中 OnScrollListener 有两个回调函数： onScrollStateChanges(RecyclerView recyclerView, int newState): 在 RecyclerView 的滚动状态发生改变时回调 onScrolled(RecyclerView recyclerView, int dx, int dy): 在 RecyclerView 滚动时回调 在 OnScrollListener 回调中，可以获取RecyclerView的滚动状态，我们只需要通过继承 OnScrollListener 并复写上面的两个回调函数，便可以实现对 RecyclerView 滑动到底部的监听。 实现我们先定义一个回调接口 BottomListener 用以监听控件是否滚动到底部： public interface BottomListener { /** * 滑动到底部时回调 */ void onScrollToBottom(); } 然后，我们继承 RecyclerView.OnScrollListener 和实现 BottomListener ： import android.support.v7.widget.GridLayoutManager; import android.support.v7.widget.LinearLayoutManager; import android.support.v7.widget.RecyclerView; import android.support.v7.widget.StaggeredGridLayoutManager; /** * 实现了RecyclerView滚动到底部监听的OnScrollListener */ public class RecyclerViewScrollListener extends RecyclerView.OnScrollListener implements BottomListener { // 最后几个完全可见项的位置（瀑布式布局会出现这种情况） private int[] lastCompletelyVisiblePositions; // 最后一个完全可见项的位置 private int lastCompletelyVisibleItemPosition; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager(); // 找到最后一个完全可见项的位置 if (layoutManager instanceof StaggeredGridLayoutManager) { StaggeredGridLayoutManager manager = (StaggeredGridLayoutManager) layoutManager; if (lastCompletelyVisiblePositions == null) { lastCompletelyVisiblePositions = new int[manager.getSpanCount()]; } manager.findLastCompletelyVisibleItemPositions(lastCompletelyVisiblePositions); lastCompletelyVisibleItemPosition = getMaxPosition(lastCompletelyVisiblePositions); } else if (layoutManager instanceof GridLayoutManager) { lastCompletelyVisibleItemPosition = ((GridLayoutManager) layoutManager).findLastCompletelyVisibleItemPosition(); } else if (layoutManager instanceof LinearLayoutManager) { lastCompletelyVisibleItemPosition = ((LinearLayoutManager) layoutManager).findLastCompletelyVisibleItemPosition(); } else { throw new RuntimeException(&quot;Unsupported LayoutManager.&quot;); } } private int getMaxPosition(int[] positions) { int max = positions[0]; for (int i = 1; i &lt; positions.length; i++) { if (positions[i] &gt; max) { max = positions[i]; } } return max; } @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) { RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager(); // 通过比对 最后完全可见项位置 和 总条目数，来判断是否滑动到底部 int visibleItemCount = layoutManager.getChildCount(); int totalItemCount = layoutManager.getItemCount(); if (newState == RecyclerView.SCROLL_STATE_IDLE) { if (visibleItemCount &gt; 0 &amp;&amp; lastCompletelyVisibleItemPosition &gt;= totalItemCount - 1) { onScrollToBottom(); } } } @Override public void onScrollToBottom() { } } 上述大体思路就是： 找到 “最后完全可见项的位置(lastCompletelyVisibleItemPosition)”，通过比较 lastCompletelyVisibleItemPosition 是否是 RecyclerView 最后一项，来判断是否滑动到底部。 在 RecyclerView 上应用加载更多： recyclerView.addOnScrollListener(new RecyclerViewScrollListener() { @Override public void onScrollToBottom() { // 加载更多 doLoadMore(); } }); // ... private void doLoadMore() { // TODO load more } 参考链接：通过重写OnScrollListener来监听RecyclerView是否滑动到底部 特别注意个人认为上面的参考链接中给出的方案是有待商榷的，原博主计算的是 “最后一个可见项的位置（lastVisibleItemPosition）”，而本文中计算的是 “最后一个完全可见项的位置(lastCompletelyVisibleItemPosition)” , 很明显 RecyclerView 列表中最后一个元素可见的时候，RecyclerView 并不一定滑动到最底部了。当然了，具体采取哪种方案，需要根据实际需求来确定。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射修改final修饰的属性值]]></title>
    <url>%2Fpost%2F463108745%2F</url>
    <content type="text"><![CDATA[之前在阅读其他源码的时候，想要修改其中被 final 修饰符修饰的字段的值，可行吗？&nbsp; 解决方案使用Java反射，通过 Field#setAccessible(true) 将 private 修饰的字段变为 accessible；再将 final 修饰符去掉；最后再设置新值即可。当然，如果涉及到 Java 内联优化，则会失效。具体见示例代码： package com.tianma.sample; import java.lang.reflect.Field; import java.lang.reflect.Modifier; public class ChangeStaticFinalFieldSample { static void changeStaticFinal(Field field, Object newValue) throws Exception { field.setAccessible(true); // 如果field为private,则需要使用该方法使其可被访问 Field modifersField = Field.class.getDeclaredField(&quot;modifiers&quot;); modifersField.setAccessible(true); // 把指定的field中的final修饰符去掉 modifersField.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL); field.set(null, newValue); // 为指定field设置新值 } public static void main(String[] args) throws Exception { Sample.print(); Field canChangeField = Sample.class.getDeclaredField(&quot;CAN_CHANGE&quot;); Field cannotChangeField = Sample.class.getDeclaredField(&quot;CANNOT_CHANGE&quot;); changeStaticFinal(canChangeField, 2); changeStaticFinal(cannotChangeField, 3); Sample.print(); } } class Sample { private static final int CAN_CHANGE = new Integer(1); // 未内联优化 private static final int CANNOT_CHANGE = 1; // 内联优化 public static void print() { System.out.println(&quot;CAN_CHANGE = &quot; + CAN_CHANGE); System.out.println(&quot;CANNOT_CHANGE = &quot; + CANNOT_CHANGE); System.out.println(&quot;------------------------&quot;); } } 打印结果为： CAN_CHANGE = 1 CANNOT_CHANGE = 1 ------------------------ CAN_CHANGE = 2 CANNOT_CHANGE = 1 ------------------------ 通过以上输出结果可以看出， CAN_CHANGE 和 CANNOT_CHANGE 字段同属于 final 修饰符修饰的常量字段，但是由于 CANNOT_CHANGE 常量在 Java 编译过程中使用了内联优化，其值在编译阶段就被编译为常量值 1，故而使用内联优化的 final 字段更改其值是无效的； 而 CAN_CHANGE 字段未被内联优化，故而能通过 Java 反射对其值进行修改。 参考Change private static final field using Java reflection]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理PopupWindow在Android 7.x中兼容性问题]]></title>
    <url>%2Fpost%2F1634332613%2F</url>
    <content type="text"><![CDATA[问题描述PopupWindow 中的 showAsDropDown(View anchor) 用于在指定锚点View下方显示 PopupWindow，在Android 7.0 (api&lt;=23) 以前是没什么问题的，但是在Android 7.x系统上，会在某些情况下出现兼容问题： 如果指定 PopupWindow 的高度为 MATCH_PARENT，调用 showAsDropDown(View anchor) 时，在 7.0 之前，会在锚点 anchor 下边缘到屏幕底部之间显示 PopupWindow；而在 7.0、7.1 系统上的 PopupWindow 会占据整个屏幕（除状态栏之外）。 如果指定 PopupWindow 的高度为 WRAP_CONTENT, 调用 showAsDropDown(View anchor) 时，便不会出现兼容性的问题。 如果指定 PopupWindow 的高度为自定义的值height，调用 showAsDropDown(View anchor)时， 如果 height &gt; 锚点 anchor 下边缘与屏幕底部的距离， 则还是会出现7.0、7.1上显示异常的问题；否则，不会出现该问题。可以看出，情况1和2是情况3的特例。 解决方案如果出现上述分析中的兼容性问题，可以使用 showAtLocation() 方法替代 showAsDropDown() , 示例代码如下，详情可参见 PopupWindowCompatSample if (Build.VERSION.SDK_INT &gt;= 24) { // Android 7.x中,PopupWindow高度为match_parent时,会出现兼容性问题,需要处理兼容性 int[] location = new int[2]; // 记录anchor在屏幕中的位置 anchor.getLocationOnScreen(location); int offsetY = location[1] + anchor.getHeight(); if (Build.VERSION.SDK_INT == 25) { // Android 7.1中，PopupWindow高度为 match_parent 时，会占据整个屏幕 // 故而需要在 Android 7.1上再做特殊处理 int screenHeight = ScreenUtils.getScreenHeight(context); // 获取屏幕高度 popupWindow.setHeight(screenHeight - offsetY); // 重新设置 PopupWindow 的高度 } popupWindow.showAtLocation(anchor, Gravity.NO_GRAVITY, 0, offsetY); } else { popupWindow.showAsDropDown(anchor); }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>PopupWindow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消除Android 5.0 ~ 7.1.1原生系统中感叹号或叉号]]></title>
    <url>%2Fpost%2F2812053051%2F</url>
    <content type="text"><![CDATA[前言在使用Android5.0以上的原生系统过程中，大家会遇到明明自己网络是OK的，但是会在状态栏的移动信号或 WiFi 图标旁显示感叹号（5.0 ~ 7.0.0）或叉号（7.1.1），并且会提示“已连接，但不能接入互联网”的情况… 原因从Android 5.0开始，系统连接网络或切换网络时，系统模块 NetworkMonitor 会向一特定网址发送数据请求，根据响应的结果从而判断网络的连通性。在原生Android系统中，这一特定网址是Google的网址，不翻墙访问不了，故而会出现感叹号或叉号。 解决方案既然知晓了原理，那么解决方案也很明确了： 完全关闭网络检查服务（不可取）： adb shell settings put global captive_portal_detection_enabled 0 缺点：&nbsp; 完全屏蔽该系统功能带来明显的问题，当你使用公共 Wi-Fi 这种需要使用 portal 验证的网络时，因为网络检查被关闭，系统在访问 portal 验证页面时无法返回正确的值，最终导致无法完成验证和上网。 替换检查网络的网址（可取）： 通过ADB命令，将验证服务的网址替换为国内正常可以访问的网址 Android 5.x ~ 6.x 解决方案adb shell &quot;settings put global captive_portal_server www.v2ex.com&quot; adb shell reboot Android 7.0.0 ~ 7.1.0 解决方案adb shell &quot;settings put global captive_portal_server captive.v2ex.co&quot; adb shell reboot Android 7.1.1 解决方案adb shell &quot;settings put global captive_portal_https_url https://captive.v2ex.co/generate_204&quot; adb shell reboot 源码问题解决了，问题产生的根本源头在哪呢，在源码里面 :) Android 5.x ~ 6.x private int isCaptivePortal() { if (!mIsCaptivePortalCheckEnabled) return 204; HttpURLConnection urlConnection = null; int httpResponseCode = 599; try { URL url = new URL(&quot;http&quot;, mServer, &quot;/generate_204&quot;); if (DBG) { log(&quot;Checking &quot; + url.toString() + &quot; on &quot; + mNetworkAgentInfo.networkInfo.getExtraInfo()); } } // ... } 原来的 mServer 是 clients3.google.com，我们最终将其换为 www.v2ex.com. Android 7.0 ~ 7.1.0private static String getCaptivePortalServerUrl(Context context, boolean isHttps) { String server = Settings.Global.getString(context.getContentResolver(), Settings.Global.CAPTIVE_PORTAL_SERVER); if (server == null) server = DEFAULT_SERVER; return (isHttps ? &quot;https&quot; : &quot;http&quot;) + &quot;://&quot; + server + &quot;/generate_204&quot;; } Android 7.0 ~ 7.1.0 新增了https的验证请求，所以我们把 server 的值改为支持https的 captive.v2ex.co. Android 7.1.1private static String getCaptivePortalServerHttpsUrl(Context context) { return getSetting(context, Settings.Global.CAPTIVE_PORTAL_HTTPS_URL, DEFAULT_HTTPS_URL); } DEFAULT_HTTPS_URL 的值由原来的 https://www.google.com/generate_204 替换为 https://captive.v2ex.co/generate_204. 源码链接：5.x ~ 6.x7.0.0 ~ 7.1.07.1.1]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>玩机</tag>
        <tag>Android 5.x</tag>
        <tag>Android 6.x</tag>
        <tag>Android 7.x</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监听Android设备网络变化]]></title>
    <url>%2Fpost%2F7e2408ee%2F</url>
    <content type="text"><![CDATA[目标在实际开发中，我们不可避免地需要对请求错误进行处理，通常情况下，我们会这样去处理错误请求： 没有网络的情况下，提示用户网络连接不可用，引导用户打开网络或重新刷新等 有网络的情况下，则是客户端或服务端的错误，给用户相应的提示 如果针对第一种情况,我们需要在网络恢复的时候重新刷新数据或进行其他操作,又应该如何实现呢？以下就是我们的目标： 监听Android设备网络状态 在网络状态发生改变时,做出相应操作 在示例中，我们在网络状态发生变化时，显示当前网络变化的类型。 思路在Android系统在网络变化的情况下，会发出 action 为 ConnectivityManager.CONNECTIVITY_ACTION 的系统广播，我们只需要注册 BroadcastReceiver 去监听该广播即可监听设备的网络变化情况。 那么，注册 BroadcastReceiver 是静态注册呢，还是动态注册呢？ 静态注册：通常来讲，退出应用后，该应用仍然能够接收到相应的广播 动态注册：随着所在Context或应用被销毁后，不会收到相应的广播 注意：针对静态注册，这里是用“通常来讲”来修饰的，也就是说，存在特殊情况，即：存在即使使用静态注册，也不会收到相应的广播的情况： Android3.1之后，系统为了加强了安全性控制，应用程序安装后或是(设置)应用管理中被强制关闭后处于stopped状态，在这种状态下接收不到任何广播，除非广播带有 FLAG_INCLUDE_STOPPED_PACKAGES 标志，而默认所有系统广播都是 FLAG_EXCLUDE_STOPPED_PACKAGES 的，所以就没法通过系统广播自启动了。 这其中就包括 ConnectivityManager.CONNECTIVITY_ACTION 。关于这一块的内容，不是本篇重点，欲了解详情，请移步Android应用为何开机自启动、自启动失败原因 另外，Android 7.0 移除了三个隐式广播(Android 7.0 行为变更)，其中就包括 ConnectivityManager.CONNECTIVITY_ACTION , 这意味着通过静态注册 BroadcastReceiver 来监听该广播的方式在 targetSdkVersion &gt;= 24 版本上不再生效，如何解决这一问题请移步 Android 7.0 网络变化监听。 所以，这里采取动态注册 BroadcastReceiver 的方式。那么，应该在哪里动态注册呢？这里有两种思路： 思路1： 定义 BroadcastReceiver 监听网络状态，并提供回调接口 NetStateChangeObserver 用以回调网络状态的变化 抽象出 BaseActivity ，提供注册/取消注册 BroadcastReceiver 的方法，并实现 NetStateChangeObserver 需要监听网络状态的 Activity 调用 BaseActivity 提供的方法即可 思路2： 定义 BroadcastReceiver 监听网络状态，并提供回调接口 NetStateChangeObserver 用以回调网络状态的变化，并在 BroadcastReceiver 中维护 NetStateChangeObserver 列表，当网络发生变化则通知这些 Observer ，实现回调。 在 Application 中注册/取消注册 BroadcastReceiver 抽象 BaseActivity ，提供注册/取消注册 NetStateChangeObserver 观察者的方法， 并实现 NetStateChangeObserver 需要监听网络状态的 Activity 调用 BaseActivity 提供的方法即可 上面的两种思路，比较重要的区别在于，第1中是在 Activity 中注册 BroadcastReceiver , 后者是在 Application 中注册 BroadcastReceiver。前者需要多次注册 BroadcastReceiver 而后者只注册一次，所以在这里选择第2中思路。 实现添加权限&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; 定义网络类型public enum NetworkType { NETWORK_WIFI(&quot;WiFi&quot;), NETWORK_4G(&quot;4G&quot;), NETWORK_3G(&quot;3G&quot;), NETWORK_2G(&quot;2G&quot;), NETWORK_UNKNOWN(&quot;Unknown&quot;), NETWORK_NO(&quot;No network&quot;); private String desc; NetworkType(String desc) { this.desc = desc; } @Override public String toString() { return desc; } } 定义观察者/** * 网络状态变化观察者 */ public interface NetStateChangeObserver { void onNetDisconnected(); void onNetConnected(NetworkType networkType); } 实现 BroadcastReceiver/** * 监听网络状态变化的BroadcastReceiver */ public class NetStateChangeReceiver extends BroadcastReceiver { private static class InstanceHolder { private static final NetStateChangeReceiver INSTANCE = new NetStateChangeReceiver(); } private List&lt;NetStateChangeObserver&gt; mObservers = new ArrayList&lt;&gt;(); public NetStateChangeReceiver() { } @Override public void onReceive(Context context, Intent intent) { if (ConnectivityManager.CONNECTIVITY_ACTION.equals(intent.getAction())) { NetworkType networkType = NetworkUtils.getNetworkType(context); notifyObservers(networkType); } } /** * 注册网络监听 */ public static void registerReceiver(@NonNull Context context) { IntentFilter intentFilter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION); context.registerReceiver(InstanceHolder.INSTANCE, intentFilter); } /** * 取消网络监听 */ public static void unregisterReceiver(@NonNull Context context) { context.unregisterReceiver(InstanceHolder.INSTANCE); } /** * 注册网络变化Observer */ public static void registerObserver(NetStateChangeObserver observer) { if (observer == null) return; if (!InstanceHolder.INSTANCE.mObservers.contains(observer)) { InstanceHolder.INSTANCE.mObservers.add(observer); } } /** * 取消网络变化Observer的注册 */ public static void unregisterObserver(NetStateChangeObserver observer) { if (observer == null) return; if (InstanceHolder.INSTANCE.mObservers == null) return; InstanceHolder.INSTANCE.mObservers.remove(observer); } /** * 通知所有的Observer网络状态变化 */ private void notifyObservers(NetworkType networkType) { if (networkType == NetworkType.NETWORK_NO) { for(NetStateChangeObserver observer : mObservers) { observer.onNetDisconnected(); } } else { for(NetStateChangeObserver observer : mObservers) { observer.onNetConnected(networkType); } } } } Application 注册 BroadcastReceiverpublic class AppContext extends Application{ @Override public void onCreate() { super.onCreate(); // 注册BroadcastReceiver NetStateChangeReceiver.registerReceiver(this); } @Override public void onTerminate() { super.onTerminate(); // 取消BroadcastReceiver注册 NetStateChangeReceiver.unregisterReceiver(this); } } BaseActivity 抽取public class BaseActivity extends AppCompatActivity implements NetStateChangeObserver { @Override protected void onResume() { super.onResume(); if (needRegisterNetworkChangeObserver()) { NetStateChangeReceiver.registerObserver(this); } } @Override protected void onStop() { super.onStop(); if (needRegisterNetworkChangeObserver()) { NetStateChangeReceiver.unregisterObserver(this); } } /** * 是否需要注册网络变化的Observer,如果不需要监听网络变化,则返回false;否则返回true.默认返回false */ protected boolean needRegisterNetworkChangeObserver() { return false; } @Override public void onNetDisconnected() { } @Override public void onNetConnected(NetworkType networkType) { } } 需要实现网络监听的 Activity 只需要复写 needRegisterNetworkChangeObserver 并返回 true ，并复写相关回调函数即可。 github源码地址:NetDetector]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>网络监测</tag>
        <tag>network monitor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F4a17b156%2F</url>
    <content type="text"><![CDATA[Hello World&nbsp; :) &nbsp; Welcome to my blog, have a nice day!&nbsp; ^_^ public class HelloWorld { public static void main(String[] args) { System.out.println(&quot;Hello World.&quot;); } } Everthing will be okay in the end. If it’s not okay, it’s not the end. 有志者 事竟成 破釜沉舟 百二秦关终属楚苦心人 天不负 卧薪尝胆 三千越甲可吞吴]]></content>
      <categories>
        <category>漫谈</category>
      </categories>
      <tags>
        <tag>Hello-World</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免费ShadowSocks账号]]></title>
    <url>%2Fpost%2F402cab53%2F</url>
    <content type="text"><![CDATA[免费提供SS账号的网站在这里我列出几个免费提供SS账户的网站： 免费ShadowSocks账号 世界那么大，我想去看看 SS ISS 这里需要注意的是： 以上这些网站提供的ss账号都会不断更新的，所以如果你使用这些免费的服务的话，可能需要及时更新。当然了，如果你是Programmer，你当然可以写脚本去爬取了对吧 :) 如果这些网站访问不了，可能是换网址了 or 被墙了 or 其他不可抗力的原因… 搭建自己的梯子之前是自己在网上找的免费的SS账户，这些免费的SS账户虽然可以提供免费的科学上网服务，但是不是特别稳定。再者，如果你对网络安全性比较在意的话，可能你需要考虑自己搭梯子了。所以，我就自己自己搭建了梯子，我采取的方案是VPS+ShadowSocks，VPS需要自己购买，我用的是搬瓦工的VPS，这里给个链接Mass VPS hosting on Enterprise equipment - Bandwagon Host,按月付的话最便宜的是2.99刀，当然了如果年付的话就更便宜了。当然了，还有其他的VPS提供商供大家选择，由于我没有尝试其他的，就不在这里列出来了。具体搭梯子的教程网上有很多，在这里贴几个： 搭建自己的Shadowsocks服务器 在 Ubuntu 服务器上部署 shadowsocks 科学上网之 Shadowsocks 安装及优化加速 ss优化加速 - 需翻墙如果感觉以上链接不太适合你的话，利用搜索引擎，多找找吧 :) 免费SS账户在这里我把我搭的SS Server的账号提供出来，反正流量比较多，造福下大家咯。当然了，如果它不生效了，恕不通知哈。可能是没再续费了，也可能是换账号了，etc. 服务器地址服务器端口密码加密方式23.106.158.19055501zljw5501aes-256-cfb 2017-06-16 更新： 因为近期 SS 流量已耗至90+%，日耗流量达100+G，故上面的 SS 账号已停止使用，抱歉~]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>ShadowSocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序-快速排序及其优化]]></title>
    <url>%2Fpost%2F2917269393%2F</url>
    <content type="text"><![CDATA[概念快速排序是交换类排序，采用分治思想，其基本原理是：通过一趟排序，将待排序数组分割成独立的两部分，其中一部分的关键字均比另一部分小；然后再分别对这两部分序列递归进行快速排序，从而使整个序列有序。 具体算法步骤： 在待排序的记录序列中选取一个记录作为枢轴(pivot)； 通过一趟排序，将所有小于枢轴的记录都移到枢轴的左边，将所有大于枢轴的记录都移到枢轴的右边，其实就是将当前待排序序列分为两部分，左边部分的记录均小于右边部分的记录，这样的操作叫做partition(分割)，分割操作结束后，枢轴所处的位置就是最终排序后它所处的位置； 对枢轴左右两边的子序列重复步骤1和2，直至所有子记录序列只剩下一个记录为止。 以上步骤中，关键点是 1. 枢轴(pivot)的选取方式； 2. 对分割操作(partition)的细节处理。 未优化的快速排序 枢轴的选取：将待排序序列的第1个记录作为枢轴； 分割操作 ： 分割操作中使用到了交换； Java实现 // 定义接口 interface Sorter { /** * 将数组按升序排序 */ int[] sort(int[] arr); /** * 交换数组arr中的第i个位置和第j个位置的关键字 */ default void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } // 未优化的快速排序 class QuickSorter implements Sorter { @Override public int[] sort(int[] arr) { quickSort(arr, 0, arr.length - 1); return arr; } /** * 对数组arr[low...high]的子序列作快速排序，使之有序 */ protected void quickSort(int[] arr, int low, int high) { int pivotLoc; // 记录枢轴(pivot)所在位置 if (low &lt; high) { pivotLoc = partition(arr, low, high); // 将arr[low...high]一分为二,并返回枢轴位置 quickSort(arr, low, pivotLoc - 1);// 递归遍历arr[low...pivotLoc-1] quickSort(arr, pivotLoc + 1, high); // 递归遍历arr[pivotLoc+1...high] } } /** * 在arr[low...high]选定pivot=arr[low]作为枢轴（中间位置），将arr[low...high]分成两部分， * 前半部分的子序列的记录均小于pivot，后半部分的记录均大于pivot;最后返回pivot的位置 */ protected int partition(int[] arr, int low, int high) { int pivot; pivot = arr[low]; // 将arr[low]作为枢轴 while (low &lt; high) { // 从数组的两端向中间扫描 // A while (low &lt; high &amp;&amp; arr[high] &gt;= pivot) { // B high--; } swap(arr, low, high); // 将比枢轴pivot小的元素交换到低位 // C while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) { //D low++; } swap(arr, low, high); // 将比枢轴pivot大的元素交换到高位 // E } return low; // 返回一趟下来后枢轴pivot所在的位置 } } 演示为了方便演示，我对上面代码中的分割操作partition方法的代码进行了标注（分别标注为 A,B,C,D,E）。对于待排序序列 {5, 1, 9, 3, 7, 4, 8, 6, 2}，我们来演示其第一趟排序过程： low = 0, high = 8, pivot = arr[low] = 5; A处，low = 0, high = 8, low&lt;high，进行A循环； B处，high的值不断递减，直至arr[high] = 2 小于pivot，跳出B循环：pivot ↓ 5 1 9 3 7 4 8 6 2 ↑ ↑ low high C处，执行low和high的元素交换： pivot ↓ 2 1 9 3 7 4 8 6 5 ↑ ↑ low high D处，low的值不断递增，直至arr[low] = 9 大于 pivot，跳出D循环: pivot ↓ 2 1 9 3 7 4 8 6 5 ↑ ↑ low high E处，执行low和high的元素交换： pivot ↓ 2 1 5 3 7 4 8 6 9 ↑ ↑ low high A处，low =2, high = 8, low &lt; high，继续循环A； B处，high的值不断递减，直至arr[high] = 4 小于pivot，跳出B循环： pivot ↓ 2 1 5 3 7 4 8 6 9 ↑ ↑ low high C处，执行low和high的元素交换： pivot ↓ 2 1 4 3 7 5 8 6 9 ↑ ↑ low high D处，low的值不断递增，直至arr[low] = 7 大于 pivot，跳出D循环： pivot ↓ 2 1 4 3 7 5 8 6 9 ↑ ↑ low high E处，执行low和high的元素交换： pivot ↓ 2 1 4 3 5 7 8 6 9 ↑ ↑ low high A处，low = 4， high = 5， low &lt; high， 继续循环A： B处，high不断递减，直至high=4 等于 low，不满足 low &lt; high，跳出B循环： pivot ↓ 2 1 4 3 5 7 8 6 9 ↑ low high 因为low和high已经重合，所以在接下来的C、D、E操作中序列均未发生变化 A处，low=4, high = 4, 不满足 low &lt; high, 跳出A循环，最后返回low=4，即为pivot所在位置； 所以第1趟排序下来之后，序列会变成 {2, 1, 4, 3, 5, 7, 8, 6, 9}；然后再对子序列{2, 1, 4, 3} 和 {7, 8, 6, 9} 做同样的操作即可完成整个排序。 对于partition方法中的low和high，可以这样理解：在low左边的记录都都小于等于枢轴pivot，在high右边的记录都大于等于枢轴pivot，那么当low和high重合时，则表示已经分割完毕，重合的位置（即low的值）就是枢轴pivot的位置。 快速排序的优化(1) 枢轴的选取方式的优化：枢轴的选取方式有：(1) 固定位置选取；(2) 随机位置选取； (3) 三值取中法 等 固定位置选取：选取当前序列的第一个元素或者最后一个元素作为枢轴，上面的算法的枢轴选取方式即为固定位置选取。该方法不是一个好的选取方案，因为当整个序列有序时，每次分割(partition)操作只会将待排序序列减1，此时为最坏情况，算法复杂度沦为O(n^2)。然而，在待排序的序列中局部有序是相当常见的，所以固定位置选取枢轴不是一种好的选择。 随机位置选取：随机选取当前待排序序列的任意记录作为枢轴。由于采取随机，所以时间性能要强于固定位置选取。 三值取中法： 待排序序列的前(第一个位置)、中(中间位置)、后(最后一个位置)三个记录中的中间值(按大小排序)作为枢轴，比如: 9 1 7 5 2 8 6 3 4 ↑ ↑ ↑ low mid high 前 中 后 由于 9 &gt; 4 &gt; 2； 因此将4作为此次分割(partition)操作的枢轴。三值取中操作后，整个序列变为： 4 1 7 5 2 8 6 3 9 ↑ ↑ ↑ low mid high 前 中 后 三值取中本质上就是随机位置选取，但是由于随机位置选取过程中需要用到随机种子来产生随机数，而三值取中不需要，所以三值取中要优于随机位置选取。 所以优化枢轴的选取方式时，我们选择三值取中的方式。 (2) 优化小数组时的排序方案：当局部排序数组长度较小时，采用插入排序，而非快速排序，因为长度分割到够小后，继续分割的效率要低于直接插入排序。 (3) 略去不必要的交换略去不必要的交换，将交换操作改为替换操作。因为交换操作需要进行3次赋值操作，而替换操作只需要进行1次赋值操作。 Java实现 // 优化的快速排序 class OptimizedQuickSorter extends QuickSorter { /** * 插入排序最大数组长度值 */ private static final int MAX_LENGTH_INSERT_SORT = 7; /** * 对数组arr[low...high]的子序列作快速排序，使之有序 */ @Override protected void quickSort(int[] arr, int low, int high) { int pivotLoc; // 记录枢轴(pivot)所在位置 if ((high - low + 1) &gt; MAX_LENGTH_INSERT_SORT) { // 待排序数组长度大于临界值，则进行快速排序 pivotLoc = partition(arr, low, high); // 将arr[low...high]一分为二,并返回枢轴位置 quickSort(arr, low, pivotLoc - 1);// 递归遍历arr[low...pivotLoc-1] quickSort(arr, pivotLoc + 1, high); // 递归遍历arr[pivotLoc+1...high] } else { // 2. 优化小数组时的排序方案，将快速排序改为插入排序 insertSort(arr, low, high); // 对arr[low...high]子序列进行插入排序 } } /** * 在arr[low...high]中利用三值取中选取枢轴(pivot)，将arr[low...high]分成两部分， * 前半部分的子序列的记录均小于pivot，后半部分的记录均大于pivot;最后返回pivot的位置 */ @Override protected int partition(int[] arr, int low, int high) { int pivot; pivot = medianOfThree(arr, low, high); // 1. 优化排序基准，使用三值取中获取中值 while (low &lt; high) { // 从数组的两端向中间扫描 // A while (low &lt; high &amp;&amp; arr[high] &gt;= pivot) { // B high--; } // swap(arr, low, high); // 将比枢轴pivot小的元素交换到低位 arr[low] = arr[high]; // 3. 优化不必要的交换，使用替换而不是交换 // C while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) { // D low++; } // swap(arr, low, high); // 将比枢轴pivot大的元素交换到高位 arr[high] = arr[low]; // 3. 优化不必要的交换，使用替换而不是交换 // E } arr[low] = pivot; // F return low; // 返回一趟下来后枢轴pivot所在的位置 } /** * 通过三值取中(从arr[low...high]子序列中)获取枢轴pivot的值，让arr[low]变成中值;并返回计算的枢轴(pivot) */ private int medianOfThree(int[] arr, int low, int high) { int mid = low + ((high - low) &gt;&gt; 1); // mid = low + (high-low)/2, 中间元素下标 // 使用三值取中得到枢轴 if (arr[low] &gt; arr[high]) { // 目的：让arr[low] &lt;= arr[high] swap(arr, low, high); } if (arr[mid] &gt; arr[high]) { // 目的：让arr[mid] &lt;= arr[high] swap(arr, mid, high); } if (arr[mid] &gt; arr[low]) { // 目的： 让arr[low] &gt;= arr[mid] swap(arr, low, mid); } // 经过上述变化，最终 arr[mid]&lt;=arr[low]&lt;=arr[high]，则arr[low]为中间值 return arr[low]; } /** * 对子序列arr[low...high]进行插入排序 */ private void insertSort(int[] arr, int low, int high) { int i, j; int tmp; for (i = low + 1; i &lt;= high; i++) { // 从下标low+1开始遍历,因为下标为low的已经排好序 if (arr[i] &lt; arr[i - 1]) { // 如果当前下标对应的记录小于前一位记录,则需要插入,否则不需要插入，直接将记录数增加1 tmp = arr[i]; // 记录下标i对应的元素 for (j = i - 1; j &gt;= low &amp;&amp; arr[j] &gt; tmp; j--) { arr[j + 1] = arr[j]; // 记录后移 } arr[j + 1] = tmp; // 插入正确位置 } } } } 演示为了方便演示，我对上面代码中的分割操作partition方法的代码仍然进行了标注（分别标注为 A,B,C,D,E,F）。对于待排序序列 {5, 1, 9, 3, 7, 4, 8, 6, 2}，我们来演示其第一趟排序过程： low = 0， high = 8， high-low+1=9 &gt; MAX_LENGTH_INSERT_SORT， 所以需要进行快速排序，接下来进行分割(partition)操作； 此时待排序序列：5 1 9 3 7 4 8 6 2 ↑ ↑ low high 三值取中前：5 1 9 3 7 4 8 6 2 ↑ ↑ ↑ low mid high 三值取中后：pivot ↓ 5 1 9 3 2 4 8 6 7 ↑ ↑ ↑ low mid high pivot = 5； A处，low = 0, high = 8, low &lt; high, 进行A循环； B处，high的值不断递减，直至arr[high] = 4 小于pivot，跳出B循环：5 1 9 3 2 4 8 6 7 ↑ ↑ low high C处，arr[low] = arr[high]，将低位的值替换成高位的值：4 1 9 3 2 4 8 6 7 ↑ ↑ low high D处，low的值不断递增，直至arr[low] = 9 大于 pivot，跳出D循环:4 1 9 3 2 4 8 6 7 ↑ ↑ low high E处，arr[high] = arr[low]， 将高位的值替换成低位的值：4 1 9 3 2 9 8 6 7 ↑ ↑ low high A处，low = 2, high = 5, low &lt; high, 进行A循环； B处，high的值不断递减，直至arr[high] = 2 小于pivot，跳出B循环：4 1 9 3 2 9 8 6 7 ↑ ↑ low high C处，arr[low] = arr[high]，将低位的值替换成高位的值：4 1 2 3 2 9 8 6 7 ↑ ↑ low high D处，low的值不断递增，直至low = 4, high = 4, low == high，不满足 low&lt;high，跳出D循环:4 1 2 3 2 9 8 6 7 ↑ low high 因为low和high已经重合，所以在接下来的E操作中序列未发生变化； A处，low=4, high = 4, 不满足 low &lt; high, 跳出A循环； F处， arr[low] = pivot:4 1 2 3 5 9 8 6 7 ↑ low high 最后返回low = 4，即为pivot所在的位置。 所以这趟排序下来之后，序列会变成 {4 1 2 3 5 9 8 6 7}；然后再对子序列{4, 1, 2, 3} 和 {9, 8, 6, 7} 做同样的操作即可完成整个排序。 复杂度时间复杂度：时间复杂度为O(nlogn)，在对快速排序进行各种细节性的优化后，快速排序的性能大大提高，在一般条件下超越了其它排序方法，故得此名。 空间复杂度：就空间复杂度来说，主要是递归造成的栈空间的使用，最好情况，递归的深度为log2n，其空间复杂度也就为O(logn)，最坏情况，需要进行n‐1递归调用，其空间复杂度为O(n)，平均情况，空间复杂度也为O(logn)。 参考链接：常见排序算法 - 快速排序 (Quick Sort)三种快速排序以及快速排序的优化]]></content>
      <categories>
        <category>Algorithm &amp; Data Structure</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序-归并排序]]></title>
    <url>%2Fpost%2F3453824605%2F</url>
    <content type="text"><![CDATA[概念归并排序就是利用归并的思想实现的排序算法。归并排序的原理：假设初始序列含有n个记录，该序列可以看成n个有序的子序列，其中每个子序列的长度为1，然后两两归并，得到⌈n/2⌉（⌈x⌉表示不小于x的最小整数）个长度为2或者1的子序列，然后再两两归并，……，如此重复直到得到1个长度为n的有序序列为止。 递归式归并演示比如我们待排序的数组是 {9, 1, 5, 8, 3, 7, 4, 6, 2}，那么递归式的归并排序为流程为： [9, 1, 5, 8, 3, 7, 4, 6, 2] ↓ ↓ [9, 1, 5, 8, 3] [7, 4, 6, 2] ↓ ↓ ↓ ↓ [9, 1, 5] [8, 3] [7, 4] [6, 2] ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ [9, 1] [5] [8] [3] [7] [4] [6] [2] ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ [9] [1] [5] [8] [3] [7] [4] [6] [2] // 上面为拆分，下面为归并(合并) ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ [1, 9] [5] [8] [3] [7] [4] [6] [2] ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ [1, 5, 9] [3, 8] [4, 7] [2, 6] ↓ ↓ ↓ ↓ [1, 3, 5, 9, 8] [2, 4, 6, 7] ↓ ↓ [1, 2, 3, 4, 5, 6, 7, 8, 9] Java实现 // 定义接口 interface Sorter { /** * 将数组按升序排序 */ int[] sort(int[] arr); /** * 交换数组arr中的第i个位置和第j个位置的关键字 */ default void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } // 递归式归并排序 class MergeSorter implements Sorter { @Override public int[] sort(int[] arr) { int[] result = new int[arr.length]; mergeSort(arr, result, 0, arr.length - 1); return result; } /** * 将乱序的src[start...end]归并排序为有序的des[start...end] * * @param src * 归并前乱序数组 * @param des * 归并后的有序数组 * @param start * 归并的起始位置 * @param end * 归并的终止位置 */ private void mergeSort(int[] src, int[] des, int start, int end) { if (start == end) { des[start] = src[start]; return; } int[] tmp = new int[src.length]; // 将src[start...end]分为src[start...mid]和src[mid+1...end]两部分 int mid = (start + end) / 2; mergeSort(src, tmp, start, mid); // 递归，将src[start...mid]归并为有序的tmp[start...mid] mergeSort(src, tmp, mid + 1, end); // 递归，将src[mid+1...end]归并为有序的tmp[mid+1...end] // 将有序的tmp[start...mid]和tmp[mid+1...end]合并为des[start...end] merge(tmp, des, start, mid, end); } /** * 将有序的src[start, mid]和有序的src[mid+1, end]合并为有序的des[start,end]; * src可能为乱序数组,但是src[start, mid]和src[mid+1, end]是有序的。 * * @param src * 乱序的原数组 * @param des * 有序的目标数组 * @param start * 数组第一部分起始位置 * @param mid * 数组第一部分结束位置（两部分的分界点） * @param end * 数组第二部分结束位置 */ protected void merge(int[] src, int[] des, int start, int mid, int end) { int i; // src数组第一部分下标 int j; // src数组第二部分下标 int k; // des数组下标 // 将较小的数依次移动到目标数组中 for (i = start, k = start, j = mid + 1; i &lt;= mid &amp;&amp; j &lt;= end;) { if (src[i] &lt; src[j]) { des[k] = src[i++]; } else { des[k] = src[j++]; } k++; } // 将剩余的src[i...mid]复制到des数组中 for (; i &lt;= mid; i++) { des[k] = src[i]; k++; } // 将剩余的src[j...end]复制到des数组中 for (; j &lt;= end; j++) { des[k] = src[j]; k++; } } } 复杂度时间复杂度：因为归并的递归操作其实就是二叉树的结构，故而，最好情况 = 最坏情况 = 平均情况 = O(nlogn) 空间复杂度：因为递归式归并需要(1)与原始记录相同大小的空间来存放归并的结果以及(2)深度为logn的栈空间，所以空间复杂度为O(n+logn) 非递归式归并演示又比如我们待排序的数组是 {9, 1, 5, 8, 3, 7, 4, 6, 2}，那么非递归式的归并排序为流程为： [9] [1] [5] [8] [3] [7] [4] [6] [2] ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ [1, 9] [5, 8] [3, 7] [4, 6] [2] ↓ ↓ ↓ ↓ ↓ [1, 5, 8, 9] [3, 4, 6, 7] [2] ↓ ↓ ↓ [1, 3, 4, 5, 6, 7, 8, 9] [2] ↓ ↓ [1, 2, 3, 4, 5, 6, 7, 8, 9] Java实现 // 非递归式归并排序 class NonRecursiveMergeSorter extends MergeSorter { @Override public int[] sort(int[] arr) { mergeSort(arr); return arr; } private void mergeSort(int[] arr) { int len = arr.length; int result[] = new int[len]; int k = 1; while (k &lt; len) { mergePass(arr, result, k); // arr归并至result,此时间隔为k k = 2 * k; // 子序列长度加倍 mergePass(result, arr, k); // result归并至arr,此时间隔翻倍 k = 2 * k; // 子序列长度加倍 } } /** * 将数组src中相邻长度为interval的子序列两两归并到des数组中 * * @param src * 源数组 * @param des * 目标数组 * @param interval * 两两合并的子序列长度 */ private void mergePass(int[] src, int[] des, int interval) { int i = 0; int len = src.length; while (i + 2 * interval - 1 &lt; len) { // 两两合并 merge(src, des, i, i + interval - 1, i + 2 * interval - 1); i = i + 2 * interval; } if (i + interval - 1 &lt; len - 1) { // i+interval-1小于len-1，说明最后还剩余两个子序列，只不过最后的一个子序列长度不够interval // 那么将剩下的两个子序列进行合并 merge(src, des, i, i + interval - 1, len - 1); } else { // 否则，最后只剩下单个子序列，则直接将该子序列加入到des尾部 for (; i &lt; len; i++) { des[i] = src[i]; } } } } 复杂度时间复杂度：同递归式归并，最好情况 = 最坏情况 = 平均情况 = O(nlogn) 空间复杂度：非递归式归并不需要保存方法栈信息，所以空间复杂度为O(n) 所以非递归的递归算法性能要高于递归式归并算法。]]></content>
      <categories>
        <category>Algorithm &amp; Data Structure</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序-堆排序]]></title>
    <url>%2Fpost%2F716497058%2F</url>
    <content type="text"><![CDATA[概念堆： 堆是具有下列性质的完全二叉树：每个节点的值都大于或等于其左右孩子（如果存在的话）的值，称为最大堆；或者每个节点的值都小于或等于其左右孩子（如果存在的话）的值，称为最小堆。 完全二叉树：complete binary tree 最大堆：max heap 最小堆：min heap图片来源: 常见排序算法 - 堆排序 (Heap Sort) 堆排序：利用堆（这里使用最大堆）进行排序的方法。其基本思想是：将待排序的序列构造成一个最大堆，此时待排序序列的最大值就是堆顶的根节点，将其移走（其实就是将其与待排序序列的最后一个元素进行交换，此时待排序序列最后一个元素就是最大值），然后将剩余的序列重新构造成一个堆，如此反复，直到待排序序列只有一个元素为止，则排序完成。 性质已知arr[0…n-1]是长度为n的最大堆数组，下标从0开始，那么对于下标为 i 的节点 I ，有：(1). 如果 I 的左孩子存在的话，那么I的左孩子节点的下标为 left(i) = 2*i+1；(2). 如果 I 的右孩子存在的话，那么I的右孩子节点的下标为 right(i) = 2*i+2;(3). 如果 I 双亲节点存在的话，那么I的双亲节点的下标为 parent(i) = (i-1)/2; (向下取整) 基本操作 构建最大堆 buildMaxHeap(int[] arr)：将待排序序列arr构建成最大堆； 调整最大堆 adjustHeap(int arr[], int begin, int end): 已知arr[begin]的左子树和右子树都满足最大堆，那么调节节点arr[begin]，将以arr[begin]为根节点的二叉树调整为最大堆。 对于堆排序，最重要的就是构建最大堆和调整最大堆，其实构造初始堆事实上也是调整堆的过程，只不过构造初始堆是对所有的非叶节点都进行调整。 Java实现// 定义接口 interface Sorter { /** * 将数组按升序排序 */ int[] sort(int[] arr); /** * 交换数组arr中的第i个位置和第j个位置的关键字 */ default void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } // 堆排序 class HeapSorter implements Sorter { @Override public int[] sort(int[] arr) { heapSort(arr); return arr; } private void heapSort(int[] arr) { buildMaxHeap(arr); // 构建最大堆 // 将最大堆堆顶元素与数组末尾元素交换，并将前n-1序列重新构造成最大堆,重复n-1次 for (int i = arr.length - 1; i &gt;= 1; i--) { swap(arr, 0, i); // 将堆顶元素和当前未经排序的子序列的最后一个元素进行交换 adjustHeap(arr, 0, i - 1); // 将arr[0...i-1](前i个元素)重新调整为最大堆 } } /** * 将指定数组arr构建成最大堆 */ private void buildMaxHeap(int[] arr) { int len = arr.length; // 从最后一个非叶子节点往前遍历，将当前序列构成最大堆 for (int i = len / 2 - 1; i &gt;= 0; i--) { adjustHeap(arr, i, len - 1); } } /** * 假定arr[begin]的左子树和右子树均满足最大堆，那么调节节点arr[begin]，将以arr[begin]为根节点的二叉树调整为最大堆。 */ private void adjustHeap(int[] arr, int begin, int end) { int tmp = arr[begin]; int j; for (j = 2 * begin + 1; j &lt;= end; j = 2 * j + 1) { // j=2*begin+1表示j对应二叉树节点的左孩子 if (j + 1 &lt;= end &amp;&amp; arr[j] &lt; arr[j + 1]) { // 如果当前节点的右孩子存在且左孩子的值小于右孩子 j++; // j为左右孩子较大记录的下标 } if (tmp &gt;= arr[j]) // tmp的值已经大于arr[j]，则调整完毕，跳出循环 break; arr[begin] = arr[j]; // 当前根节点并未均大于左右节点(如果有的话)，重新给当前根节点赋值 begin = j; // begin指向新的可能需要进行最大堆调整的子树的根节点 } arr[begin] = tmp; } } 堆排序其实也是一种选择排序，是一种树形选择排序。在简单选择排序中，从arr[0…n-1]中选择最小（或最大）记录，需要比较n-1次，然后再从剩下arr[1…n-1]的n-1个元素中选择最小（或最大）记录，需要比较n-2次。然而事实上这n-2次比较中，有许多已经在前一趟n-1次的比较中做过了；而树形选择排序恰好利用树形的特点保存了部分前面的比较结果，因此可以减少比较次数，提高算法效率。 复杂度时间复杂度：对于n个关键字序列，每个节点需比较log2(n)次，因此其时间复杂度为O(nlogn)。由于堆排序对原始记录的排序状态并不敏感，所以它的最好、最坏、平均时间复杂度均为O(nlogn)由于初始构建堆所需要的比较次数较多，所以堆排序不适合待排序序列个数少的情况。 空间复杂度：最好情况=平均情况=最坏情况=O(1) 参考链接推排序常见排序算法 - 堆排序 (Heap Sort)堆排序(Heap Sort)算法学习]]></content>
      <categories>
        <category>Algorithm &amp; Data Structure</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序-希尔排序]]></title>
    <url>%2Fpost%2F3263168730%2F</url>
    <content type="text"><![CDATA[概念希尔排序是插入类排序算法，它的本质就是分组插入排序，它采取分割策略：将相距某个“增量”的记录组成一个子序列，保证在每个子序列内部分别进行插入排序后得到的结果是基本有序。 该方法的基本思想是：先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。 因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比插入排序有大幅度提高。 Java实现// 定义接口 interface Sorter { /** * 将数组按升序排序 */ int[] sort(int[] arr); /** * 交换数组arr中的第i个位置和第j个位置的关键字 */ default void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } //希尔排序 public class ShellSorter implements Sorter { @Override public int[] sort(int[] arr) { shellSort(arr); return arr; } // Shell排序的关键就是增量序列的选取： // 增量序列原则： 增量序列的最后一个增量必须等于1 private void shellSort(int[] arr) { int len = arr.length; int increment = len; for (; increment != 1;) {// 循环直至increment=1 increment = increment / 3 + 1; // 计算增量序列(将整个序列分成increment组,在组内进行插入排序) for (int i = increment; i &lt; len; i++) { if (arr[i] &lt; arr[i - increment]) { int tmp = arr[i]; // 暂存arr[i]的值 int j; for (j = i - increment; j &gt;= 0 &amp;&amp; tmp &lt; arr[j]; j -= increment) { // 组内记录后移,查找插入位置 arr[j + increment] = arr[j]; } // 找到插入位置 arr[j + increment] = tmp; } } } } } 演示比如我们待排序的数组是 {9, 1, 5, 8, 3, 7, 4, 6, 2}初始时increment=arr.length=9，increment != 1，执行第1次循环：increment = 9/3+1 = 4，将整个序列分成4组，组内进行插入排序： 第 1 组： 9 3 2 -----------&gt; 2 3 9 第 2 组： 1 7 -----------&gt; 1 7 第 3 组： 5 4 -----------&gt; 4 5 第 4 组： 8 6 -----------&gt; 6 8 此时序列为 2 1 4 6 3 7 5 8 9 increment=4，increment != 1，执行第2次循环：increment = 4/3+1 = 2，将整个序列分成2组，组内进行插入排序： 第 1 组： 2 4 3 5 9 -----------&gt; 2 3 4 5 9 第 2 组： 1 6 7 8 -----------&gt; 1 6 7 8 此时序列为 2 1 3 6 4 7 5 8 9 increment=2，increment != 1，执行第3次循环：increment = 2/3+1 = 1，将整个序列分成1组，组内进行插入排序（演变为直接插入排序）： 第 1 组 ： 2 1 3 6 4 7 5 8 9 -----------&gt; 1 2 3 4 5 6 7 8 9 increment=1，结束循环，排序完毕。]]></content>
      <categories>
        <category>Algorithm &amp; Data Structure</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序-插入排序]]></title>
    <url>%2Fpost%2F1309789713%2F</url>
    <content type="text"><![CDATA[概念插入排序是插入类的排序算法，基本原理：将一个记录插入到已经排好序的有序表中，从而得到一个新的记录数增加1的有序表。 具体算法：整个序列分为两部分，左边部分为已排序的子序列，右边部分为未排序的子序列，取出第1个未排序元素存放在临时变量tmp中，在已经排序的元素序列中从后往前遍历，逐一比较，如果遍历到的元素大于tmp，则将该元素替换下一个位置的元素，直至遍历到的元素小于或等于tmp为止。相当于将未排序的第一个元素插入到已排序的数组中，故以插入排序为名。 演示比如我们待排序的数组是 {0, 5, 3, 4, 6, 2}第1趟排序，5大于0，无需插入： 0 5 3 4 6 2第2趟排序，3小于5，需要插入： 0 3 5 4 6 2第3趟排序，4小于5，需要插入： 0 3 4 5 6 2第4趟排序，6大于5，无需插入： 0 3 4 5 6 2第5趟排序，2小于6，需要插入： 0 2 3 4 5 6 Java实现// 定义接口 interface Sorter { /** * 将数组按升序排序 */ int[] sort(int[] arr); /** * 交换数组arr中的第i个位置和第j个位置的关键字 */ default void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } //插入排序 class InsertSorter implements Sorter { @Override public int[] sort(int[] arr) { insertSort(arr); return arr; } private void insertSort(int[] arr) { int len = arr.length; int i, j; int tmp; for (i = 1; i &lt; len; i++) { // 从下标1开始遍历,因为下标0的已经排好序 if (arr[i] &lt; arr[i - 1]) { // 如果当前下标对应的记录小于前一位记录,则需要插入,否则不需要插入，直接将记录数增加1 tmp = arr[i]; // 记录下标i对应的元素 for (j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; tmp; j--) { arr[j + 1] = arr[j]; // 记录后移 } arr[j + 1] = tmp; // 插入正确位置 } } } } 复杂度时间复杂度：最好情况：当待排序的序列为顺序表时，会进行n-1次比较，0次替换，复杂度为O(n)；最坏情况：当待排序的序列为逆序表时，会进行2+3+…+n=(n+2)*(n-1)/2次比较，2+3+…+n = (n+2)*(n-1)/2次替换，复杂度为O(n^2)；平均情况：平均比较次数约为n^2/2, 平均移动次数为n^2/2，复杂度为O(n^2)。 空间复杂度：最好情况=最坏情况=平均情况=O(1)]]></content>
      <categories>
        <category>Algorithm &amp; Data Structure</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-IPv4地址和int类型数字的互相转换]]></title>
    <url>%2Fpost%2F1779625018%2F</url>
    <content type="text"><![CDATA[问题分析对于ipv4的地址来说，如果用字符串的形式存储的话，其占用字节就比较大，比如对于IPv4地址0.0.0.0的字符串，就需要7个字节，IPv4为255.255.255.255 的字符串，需要15个字节，也就是说存储一个ip需要占用7~15个字节。 那么有没有更节省空间的存储方式呢？答案是有。 方案1： 直接把字符串中的’.’去掉，不就变成一个数字了嘛，比如 “255.255.255.255” 变成 255255255255，然而我们知道int所能表示的最大值 = Integer.MAX_VALUE = 2^31-1 = 2147483647， 255255255255 &gt; 2^31-1，所以需要用长整形long来表示，长整形占用8个字节，也就是说我们将7~15个字节转换为8字节，在绝大多数情况下是节省空间了的。 方案2： 因为考虑到IPv4的地址本质上就是32位的二进制串，而一个int类型的数字刚好为4个字节32个bit位，所以刚好可以用一个int类型的数字转表示IPv4地址。所以，我们可以用4个字节的int数字表示一个ip地址，这样可以大大节省空间。 这里只讨论方案2 :) 演示对于ipv4地址： 192.168.1.3：每段都用二进制表示： 192(10) = 11000000(2) ; 168(10) = 10101000(2) ; 1(10) = 00000001(2) ; 3(10) = 00000011(2) 。所以连在一起就是：11000000101010000000000100000011，对应的int数字就是-1062731775 。 具体算法分析：192左移24位： 11000000 00000000 00000000 00000000168左移16位： 00000000 10101000 00000000 00000000001左移08位： 00000000 00000000 00000001 00000000003左移00位： 00000000 00000000 00000000 00000011按位或的结果： 11000000 10101000 00000001 00000011即 -1062731775 将int类型的数字转换成ip地址，其实就是上述过程的逆过程，这里就不再赘述。 Java实现/** * IPv4地址和int数字的互相转换 * * @author Tianma * */ public class IPv4IntTransformer { /** * IPv4地址转换为int类型数字 * */ public static int ip2Integer(String ipv4Addr) { // 判断是否是ip格式的 if (!isIPv4Address(ipv4Addr)) throw new RuntimeException(&quot;Invalid ip address&quot;); // 匹配数字 Pattern pattern = Pattern.compile(&quot;\\d+&quot;); Matcher matcher = pattern.matcher(ipv4Addr); int result = 0; int counter = 0; while (matcher.find()) { int value = Integer.parseInt(matcher.group()); result = (value &lt;&lt; 8 * (3 - counter++)) | result; } return result; } /** * 判断是否为ipv4地址 * */ private static boolean isIPv4Address(String ipv4Addr) { String lower = &quot;(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])&quot;; // 0-255的数字 String regex = lower + &quot;(\\.&quot; + lower + &quot;){3}&quot;; Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(ipv4Addr); return matcher.matches(); } /** * 将int数字转换成ipv4地址 * */ public static String integer2Ip(int ip) { StringBuilder sb = new StringBuilder(); int num = 0; boolean needPoint = false; // 是否需要加入&#39;.&#39; for (int i = 0; i &lt; 4; i++) { if (needPoint) { sb.append(&#39;.&#39;); } needPoint = true; int offset = 8 * (3 - i); num = (ip &gt;&gt; offset) &amp; 0xff; sb.append(num); } return sb.toString(); } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序-选择排序]]></title>
    <url>%2Fpost%2F2610207546%2F</url>
    <content type="text"><![CDATA[概念简单选择排序是选择类的排序，算法原理：第i次排序（1≤ i ≤n-1），从待排序的n-i+1个记录中， 进行n-i次关键字比较，从n-i+1个记录中选出最小的，并和第i-1个记录进行交换。 演示比如我们待排序的数组是 {9, 1, 5, 8, 3, 7, 4, 6, 2}第1趟排序，1最小，与第0个位置9进行交换： 1 9 5 8 3 7 4 6 2第2趟排序，2最小，与第1个位置9进行交换： 1 2 5 8 3 7 4 6 9第3趟排序，3最小，与第2个位置5进行交换： 1 2 3 8 5 7 4 6 9第4趟排序，4最小，与第3个位置8进行交换： 1 2 3 4 5 7 8 6 9第5趟排序，5最小，第4个位置是5无须交换： 1 2 3 4 5 7 8 6 9第6趟排序，6最小，与第5个位置7进行交换： 1 2 3 4 5 6 8 7 9第7趟排序，7最小，与第6个位置8进行交换： 1 2 3 4 5 6 7 8 9第8趟排序，8最小，第7个位置是8无须交换： 1 2 3 4 5 6 7 8 9 其实就是每一趟排序将当前未排序序列中的最小的记录与未排序序列的最前端的位置进行交换。 Java实现// 定义接口 interface Sorter { /** * 将数组按升序排序 */ int[] sort(int[] arr); /** * 交换数组arr中的第i个位置和第j个位置的关键字 */ default void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } //选择排序 class SelectionSorter implements Sorter { @Override public int[] sort(int[] arr) { selectSort(arr); return arr; } private void selectSort(int[] arr) { int i, j, min; int len = arr.length; for (i = 0; i &lt; len - 1; i++) { min = i; // min记录最小值的下标 for (j = i + 1; j &lt; len; j++) { // 循环i之后的数据 if (arr[j] &lt; arr[min]) // 发现有小于当前最小值的关键字 min = j; // 将该下标赋值给min } if (i != min) // 如果i和min不等，在i之后的数据中找到了最小值，则需要arr[i]于arr[min]进行交换 swap(arr, i, min); } } } 复杂度时间复杂度：对于比较次数而言，无论最好最差情况，其比较次数都是一样的：第i趟排序需要进行n-i次比较，此时比较次数=(n-1)+(n-2)+…+1 = n*(n-1)/2；对于交换次数而言，其最好情况为顺序表，交换次数为0次；最差情况为逆序表，交换次数为n-1次，那么平均情况则为(n-1)/2次交换；由于时间复杂度取决于比较次数和交换次数总和，故而交换排序的时间复杂度为O(n^2)。因为相较于冒泡排序，选择排序的交换次数要少，所以选择排序的性能要优于冒泡排序。 空间复杂度：最好情况=最坏情况=平均情况=O(1)]]></content>
      <categories>
        <category>Algorithm &amp; Data Structure</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序-冒泡排序及其优化]]></title>
    <url>%2Fpost%2F42083511%2F</url>
    <content type="text"><![CDATA[概念冒泡排序是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直至没有反序的记录为止。因为按照该算法，每次比较会将当前未排序的记录序列中最小的关键字移至未排序的记录序列最前（或者将当前未排序的记录序列中最大的关键字移至未排序的记录序列最后），就像冒泡一样，故以此为名。 演示比如我们待排序的数组是 {9, 1, 5, 8, 3, 7, 4, 6, 2}第1趟排序：第1次比较，2和6比较，2小于6，反序，进行交换： 9 1 5 8 3 7 4 2 6第2次比较，2和4比较，2小于4，反序，进行交换： 9 1 5 8 3 7 2 4 6第3次比较，2和7比较，2小于7，反序，进行交换： 9 1 5 8 3 2 7 4 6第4次比较，2和3比较，2小于3，反序，进行交换： 9 1 5 8 2 3 7 4 6第5次比较，2和8比较，2小于8，反序，进行交换： 9 1 5 2 8 3 7 4 6第6次比较，2和5比较，2小于5，反序，进行交换： 9 1 2 5 8 3 7 4 6第7次比较，2和1比较，2大于1，正序，不用交换： 9 1 2 5 8 3 7 4 6第8次比较，1和9比较，1小于1，反序，进行交换： 1 9 2 5 8 3 7 4 6可以看出，第一趟排序将当前序列最小值移动至未排序的序列最前面的位置。 第2趟排序： 因为第一趟已经排好1的位置，所以只需要对剩下的{9, 2, 5, 8, 3, 7, 4, 6}再进行冒泡排序… 重复以上操作，直至排序完毕 Java实现// 定义接口 interface Sorter { /** * 将数组按升序排序 */ int[] sort(int[] arr); /** * 交换数组arr中的第i个位置和第j个位置的关键字 */ default void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } // 冒泡排序 class BubbleSorter implements Sorter { @Override public int[] sort(int[] arr) { bubbleSort(arr); return arr; } private void bubbleSort(int[] arr) { int i, j; int len = arr.length; for (i = 0; i &lt; len - 1; i++) { for (j = len - 1; j &gt; i; j--) { if (arr[j - 1] &gt; arr[j]) { swap(arr, j - 1, j); } } } } } 优化当待排序数组为{1, 3, 4, 5, 6, 7, 8, 9, 2}时：第1趟排序的结果为： 1 2 3 4 5 6 7 8 9此时其实序列已经完成，但是根据上述代码仍得继续遍历，直至第9趟排序。这显然是不合理的，如果我们能在代码中加入一个flag标记上一趟排序中是否进行过交换，如果进行过未进行交换，说明当前数组已经有序。优化代码： // 优化的冒泡排序 class OptimizedBubbleSorter extends BubbleSorter { @Override protected void bubbleSort(int[] arr) { int i, j; int len = arr.length; boolean swapped = true; // 标记：上一趟循环是否进行过交换 for (i = 0; i &lt; len - 1 &amp;&amp; swapped; i++) { swapped = false; // 在某一趟遍历中,如果没有可交换的,那么swapped = false,跳出外层循环; // 如果一旦进行了交换,则swapped = true,需要进行下一趟遍历 for (j = len - 1; j &gt; i; j--) { if (arr[j - 1] &gt; arr[j]) { swap(arr, j - 1, j); swapped = true; } } } } } 复杂度时间复杂度：最好情况： 排序表本身是顺序的，根据优化后的代码，则只需要进行n-1次比较，故时间复杂度为O(n)；最差情况： 排序表本身是逆序的，则比较次数为 1+2+…+(n-1) = n*(n-1)/2 , 并作等数量级的移动操作；平均情况： 时间复杂度为 O(n^2) 空间复杂度：最好情况=最坏情况=平均情况=O(1)]]></content>
      <categories>
        <category>Algorithm &amp; Data Structure</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找-二叉搜索树（Java实现）]]></title>
    <url>%2Fpost%2F1367710076%2F</url>
    <content type="text"><![CDATA[前言如果查找的数据集是有序的线性表，并且是顺序存储的，查找可以用折半查找、插值查找、斐波那契查找算法（详细算法见：有序表查找（折半、插值、斐波那契查找））等实现。但是正是因为他们是顺序的，所以在插入和删除操作中需要耗费大量时间，也就是说这些算法适合静态查找（只有查找操作），不适合动态查找（不仅有查找操作还有插入删除等操作）。而二叉搜索树正适合动态查找。 定义二叉搜索树又称为二叉排序树，它或者是空树，或者是具有下列性质的二叉树： 如果它的左子树不为空，那么左子树的所有节点都小于根节点的值； 如果它的右子树不为空，那么右子树的所有节点都大于根节点的； 它的左、右子树也分别是二叉搜索树. 二叉树是递归定义的数据结构，其中序遍历是递增的有序序列。 操作1. 插入插入节点的过程是：若原二叉查找树为空，则直接插入；否则，若关键字 k 小于根节点关键字，则插入到左子树中，若关键字 k 大于根节点关键字，则插入到右子树中。注意每次插入的节点必是叶节点。 2. 删除二叉查找树的删除操作是相对复杂一点，它要按 3 种情况来处理： 若被删除节点 t 是叶子节点，则直接删除，不会破坏二叉排序树的性质； 若节点 t 只有左子树或只有右子树，则让 t 的子树成为 t 父节点的子树，替代 t 的位置； 若节点 t 既有左子树，又有右子树，则用 t 的直接前驱或者直接后继代替 t，然后从二叉查找树中删除这个后继，这样就转换成了第一或第二种情况。 3. 查找查找是从根节点开始，若二叉树非空，将给定值与根节点的关键字比较，若相等，则查找成功；若不等，则当给定值小于根节点关键字时，在根节点的左子树中查找，否则在根节点的右子树中查找。其查找平均时间复杂度为O(logn)，但是最差情况为插入的节点是有序的，则该二叉搜索树会变成左斜树(或者右斜树或者可以理解为“链表”)，即最差时间复杂度为O(n)，故而查找性能不是严格意义上的O(logn)，不稳定。 Java实现public class SortedBinaryTree&lt;E&gt; { private Node&lt;E&gt; root; // 根节点 private int size; // 二叉树元素个数 /** * 二叉树节点 */ private static class Node&lt;E&gt; { E element; // 节点元素 Node&lt;E&gt; lChild; // 左孩子 Node&lt;E&gt; rChild; // 右孩子 public Node(E element) { this(element, null, null); } public Node(E element, Node&lt;E&gt; lChild, Node&lt;E&gt; rChild) { this.element = element; this.lChild = lChild; this.rChild = rChild; } } public SortedBinaryTree(List&lt;E&gt; elements) { for (E e : elements) { add(e); } } public SortedBinaryTree(E[] elements) { for (E e : elements) { add(e); } } public SortedBinaryTree() { } /** * 判断当前元素是否存在于树中 * * @param element * @return */ public boolean contains(E element) { return search(root, element); } /** * 递归搜索,查找当前以curRoot为根节点的树中element存在与否 * * @param curRoot * @param element * @return */ @SuppressWarnings(&quot;unchecked&quot;) private boolean search(Node&lt;E&gt; curRoot, E element) { if (curRoot == null) return false; Comparable&lt;? super E&gt; e = (Comparable&lt;? super E&gt;) element; int cmp = e.compareTo(curRoot.element); if (cmp &gt; 0) { // 查找的元素大于当前根节点对应的元素,向右走 return search(curRoot.rChild, element); } else if (cmp &lt; 0) { // 查找的元素小于当前根节点对应的元素,向左走 return search(curRoot.lChild, element); } else { // 查找的元素等于当前根节点对应的元素,返回true return true; } } /** * 非递归搜索,查找当前以curRoot为根节点的树中的element是否存在 * * @param curRoot * 二叉排序树的根节点 * @param element * 被搜索的元素 * @param target * target[0]指向查找路径上最后一个节点: 如果当前查找的元素存在,则target[0]指向该节点 * @return */ @SuppressWarnings(&quot;unchecked&quot;) private boolean find(Node&lt;E&gt; curRoot, E element, Node&lt;E&gt;[] target) { if (curRoot == null) return false; Node&lt;E&gt; tmp = curRoot; Comparable&lt;? super E&gt; e = (Comparable&lt;? super E&gt;) element; while (tmp != null) { int cmp = e.compareTo(tmp.element); target[0] = tmp; if (cmp &gt; 0) { // 查找的元素大于当前节点对应的元素,向右走 tmp = tmp.rChild; } else if (cmp &lt; 0) { // 查找的元素小于当前节点对应的元素,向左走 tmp = tmp.lChild; } else { // 查找的元素等于当前根节点对应的元素,返回true return true; } } return false; } /** * 向二叉排序树中添加元素,如果当前元素已经存在,则添加失败,返回false,如果当前元素不存在,则添加成功,返回true * */ @SuppressWarnings(&quot;unchecked&quot;) public boolean add(E element) { if (root == null) { root = new Node&lt;E&gt;(element); size++; return true; } Node&lt;E&gt;[] target = new Node[1]; if (!find(root, element, target)) { // 当前元素不存在,插入元素 // 此时target节点即为需要插入的节点的父节点 Comparable&lt;? super E&gt; e = (Comparable&lt;? super E&gt;) element; int cmp = e.compareTo(target[0].element); Node&lt;E&gt; newNode = new Node&lt;E&gt;(element); if (cmp &gt; 0) { // 插入的元素大于target指向的节点元素 target[0].rChild = newNode; } else { // 插入的元素小于target指向的节点元素 target[0].lChild = newNode; } size++; return true; } return false; } /** * 删除二叉排序树中的元素,如果当前元素不存在,则删除失败,返回false;如果当前元素存在,则删除该元素,重构二叉树,返回true * * @param element * @return */ @SuppressWarnings(&quot;unchecked&quot;) public boolean remove(E element) { Node&lt;E&gt;[] target = new Node[1]; if (find(root, element, target)) { // 被删除的元素存在,则继续执行删除操作 remove(target[0]); return true; } return false; } /** * 释放当前节点 * * @param node */ private void free(Node&lt;E&gt; node) { node.element = null; node.lChild = null; node.rChild = null; node = null; } /** * 删除二叉排序树中指定的节点 * * @param node */ private void remove(Node&lt;E&gt; node) { Node&lt;E&gt; tmp; if (node.lChild == null &amp;&amp; node.rChild == null) { // 当前node为叶子节点,删除当前节点,则node = null; node = null; } else if (node.lChild == null &amp;&amp; node.rChild != null) { // 如果被删除的节点左子树为空,则只需要重新连接其右子树 tmp = node; node = node.rChild; free(tmp); } else if (node.lChild != null &amp;&amp; node.rChild == null) { // 如果被删除的节点右子树为空,则只需要重新连接其左子树 tmp = node; node = node.lChild; free(tmp); } else { // 当前被删除的节点左右子树均存在,不为空 // 找到离当前node节点对应元素且最近的节点target(左子树的最右边节点 或者 右子树最左边节点) // 将node节点元素替换成target节点的元素,将target节点删除 tmp = node; // tmp是target的父节点 Node&lt;E&gt; target = node.lChild; // 找到左子树最大子树 while (target.rChild != null) { // 在左子树中进行右拐 tmp = target; target = target.rChild; } node.element = target.element; // node.element元素替换为target.element if (tmp == node) { // tmp == node 说明没有在左子树中进行右拐,也就是node节点的左孩子没有右孩子, // 需要重新连接tmp节点左孩子 tmp.lChild = target.lChild; } else { // tmp != node, 进行了右拐,那么将重新连接tmp的右子树,将target.lChild赋值给tmp.rChild tmp.rChild = target.lChild; } // 释放节点 free(target); } // 删除成功,size--; size--; } public int size() { return size; } public boolean isEmpty() { return size() == 0; } public List&lt;E&gt; preOrderTraverse() { List&lt;E&gt; list = new ArrayList&lt;E&gt;(); preOrderTraverse(root, list); return list; } private void preOrderTraverse(Node&lt;E&gt; curRoot, List&lt;E&gt; list) { if (curRoot == null) return; E e = curRoot.element; list.add(e); preOrderTraverse(curRoot.lChild, list); preOrderTraverse(curRoot.rChild, list); } public List&lt;E&gt; inOrderTraverse() { List&lt;E&gt; list = new ArrayList&lt;E&gt;(); inOrderTraverse(root, list); return list; } private void inOrderTraverse(Node&lt;E&gt; curRoot, List&lt;E&gt; list) { if (curRoot == null) return; inOrderTraverse(curRoot.lChild, list); list.add(curRoot.element); inOrderTraverse(curRoot.rChild, list); } public List&lt;E&gt; postOrderTraverse() { List&lt;E&gt; list = new ArrayList&lt;E&gt;(); postOrderTraverse(root, list); return list; } private void postOrderTraverse(Node&lt;E&gt; curRoot, List&lt;E&gt; list) { if (curRoot == null) return; inOrderTraverse(curRoot.lChild, list); inOrderTraverse(curRoot.rChild, list); list.add(curRoot.element); } /** * 返回中序遍历结果 */ @Override public String toString() { return inOrderTraverse().toString(); } public static void main(String[] args) { Integer[] elements = new Integer[] { 62, 88, 58, 47, 73, 99, 35, 51, 93, 29, 37, 49, 56, 36, 48, 50 }; SortedBinaryTree&lt;Integer&gt; tree = new SortedBinaryTree&lt;Integer&gt;(elements); System.out.println(tree); System.out.println(tree.contains(93)); System.out.println(tree.size()); System.out.println(tree.remove(47)); System.out.println(tree.preOrderTraverse()); System.out.println(tree.size()); } } Github地址SortedBinaryTree]]></content>
      <categories>
        <category>Algorithm &amp; Data Structure</category>
      </categories>
      <tags>
        <tag>查找</tag>
        <tag>二叉搜索树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找-有序表查找(折半查找，插值查找，斐波拉契查找)]]></title>
    <url>%2Fpost%2F243331195%2F</url>
    <content type="text"><![CDATA[引言如果待查找的数组是有序的，那么此时的查找就是有序表查找，这对于查找的帮助是很大的。属于有序表查找的有：折半查找（二分查找）、插值查找以及斐波那契查找。 1. 折半查找折半查找又称为二分查找，是一种效率较高的查找算法。折半查找的先决条件是查找表中的数据元素排列必须是有序的。折半查找先以有序数列的中点位置为比较对象，如果要找的元素值小于中点位置元素，则将待查序列缩小为左半部分，否则为右半部分。通过一次比较，可以将查找的区间缩小一半，每次比较，都可以将当前查找范围缩小至一般，可以明显的减少比较的次数，提高查找效率。时间复杂度：O(logn)算法实现： // 定义接口 interface Searcher { /** * 从数组array中查找关键字key,如果存在则返回该关键字在数组中任意出现的位置(不局限于首次或者末次之类的),否则返回-1 */ int search(int[] array, int key); } /** * 二分法查找,时间复杂度O(logn) */ class BinarySearcher implements Searcher { // 二分法查找前提,查找表array是顺序(这里要求递增)排列的 @Override public int search(int[] array, int key) { int low, high, mid; low = 0; // 定义最低下标为array首位 high = array.length - 1; // 定义最高下标为array末位 while (low &lt;= high) { mid = (low + high) / 2; // 折半 if (array[mid] &gt; key) { // 中值比key大,则high=mid-1 high = mid - 1; } else if (array[mid] &lt; key) { // 中值比key小,则low=mid+1 low = mid + 1; } else { // 相等说明mid即为key在array中所在位置 return mid; } } return -1; } } 2. 插值查找插值查找是二分查找演化而来，相比于二分查找(折半),该算法考虑的是每次折的时候折多少,即不一定是1/2;如在一本字典中找”abstract”这个单词,我们自己来操作肯定是先翻到字典开始的那一小部分,而不是从字典的中间开始进行折半查找。 在二分查找中mid=(low+high)/2=low+1/2*(high-low),插值查找就是对1/2(系数,或者说比例)进行改变，它将1/2变成 (key - array[low])/(array[high] - array[low]),其实就是计算线性比例。 时间复杂度：O(logn)因为插值查找是依赖线性比例的，如果当前数组分布不是均匀的，那么该算法就不合适。 算法实现： class InterpolateSearcher implements Searcher { @Override public int search(int[] array, int key) { int low, high, mid; low = 0; // 定义最低下标为array首位 high = array.length - 1; // 定义最高下标为array末位 while (low &lt;= high) { // 相比二分法查找的更改处 mid = low + (int) (1.0 * (key - array[low]) / (array[high] - array[low]) * (high - low)); if (array[mid] &gt; key) { // 中值比key大,则high=mid-1 high = mid - 1; } else if (array[mid] &lt; key) { // 中值比key小,则low=mid+1 low = mid + 1; } else { // 相等说明mid即为key在array中所在位置 return mid; } } return -1; } } 3. 斐波那契查找根据前面二分查找以及插值查找来看，有序表上的查找的关键就是如何分割当前查找的区域（二分查找对半分割，差值查找按线性比例分割），说到分割，还有一个著名的分割方式就是黄金分割。 斐波那契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、····，在数学上，斐波那契被递归方法如下定义：F(1)=1，F(2)=1，F(n)=f(n-1)+F(n-2) （n&gt;=2）。该数列越往后相邻的两个数的比值越趋向于黄金比例值（0.618） 所以我们可以根据斐波那契数列对当前区域进行分割 :) 查找算法：在斐波那契数列找一个等于略大于查找表中元素个数的数F(n)，将原查找表扩展为长度为F(n)(如果要补充元素，则补充重复最后一个元素，直到满足数组元素个数为F(n)个元素)，完成后进行斐波那契分割，即F(n)个元素分割为前半部分F(n-1)个元素，后半部分F(n-2)个元素，找出要查找的元素在那一部分并递归，直到找到。时间复杂度：O(logn)，平均性能优于二分查找。算法实现： class FibonacciSearcher implements Searcher { private static final int MAX_ARRAY_SIZE = 30; /** * 得到长度为len的斐波那契数列 * * @return */ private int[] fibonacci(int len) { if (len &lt; 0) throw new IllegalArgumentException(&quot;length must bigger than 0&quot;); int[] fibonacci = new int[len]; fibonacci[0] = 1; fibonacci[1] = 1; for (int i = 2; i &lt; len; i++) { fibonacci[i] = fibonacci[i - 1] + fibonacci[i - 2]; } return fibonacci; } @Override public int search(int[] array, int key) { int low = 0; // 低位 int len = array.length; int high = len - 1; // 高位 int mid; // 中间位 int k = 0; // 斐波那契数列下标(用于进行分割) // 获取斐波那契数列 int[] fib = fibonacci(MAX_ARRAY_SIZE); // 获取斐波那契数列分割点位置 while (len &gt; fib[k] - 1) { k++; } // 创建临时数组(数组长度为fib[k] - 1) int[] tmp = new int[fib[k] - 1]; // 拷贝原数组到tmp数组中 System.arraycopy(array, 0, tmp, 0, len); // 填充tmp数组中剩余的位置,补充的元素值为最后一个元素值 for (int i = len; i &lt; fib[k] - 1; i++) { tmp[i] = array[high]; } // 开始进行类似于二分查找的查找 while (low &lt;= high) { // 对于tmp数组,整个数组的长度为fib[k]-1 // 而 fib[k]-1 = (fib[k-1]-1) + 1 + (fib[k-2]-1); // 所以可以这样理解： mid下标对应元素可以将整个数组拆分为两部分,第1部分有fib[k-1]-1个元素,第2部分有fib[k-2]-1个元素 // mid=low+fib[k-1]-1; 正是将 数组的[low, max(high,tmp.length-1)] // 部分按照斐波那契规则分为两部分 mid = low + fib[k - 1] - 1; if (tmp[mid] &gt; key) { // 需要查找第1部分 high = mid - 1; // fib[k] = fib[k-1] + fib[k-2] // 第一部分有fib[k-1]个元素,所以将k-1赋值为k k = k - 1; } else if (tmp[mid] &lt; key) { // 需要查找第2部分 low = mid + 1; // fib[k] = fib[k-1] + fib[k-2] // 第二部分有fib[k-2]个元素,所以将k-2赋值给k k = k - 2; } else { // 查找成功 // 以下代码其实就是返回 min(mid, high); // return Math.min(mid, high); if (mid &lt;= high) return mid; else return high; // 因为mid可能大于high,即查找到了补充的元素,那么还是应该返回high } } return -1; } } 结束语以上三种查找算法中，都依赖于顺序表，三者的区别本质上就是分割点选的不同。在分割点的选择中，折半查找 mid=(low+high)/2是加法与除法运算；插值查找mid = low+(key-array[low])/(array[high]-array[low])*(high-low)是复杂的四则运算；斐波那契查找mid=low+fib[k-1]-1是简单的加减运算。在海量数据查找过程中细微的差别会影响最终的效率。 三种查找算法，各有优劣，实际开发可以根据数据的特点综合考虑再做出选择。]]></content>
      <categories>
        <category>Algorithm &amp; Data Structure</category>
      </categories>
      <tags>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找-顺序查找]]></title>
    <url>%2Fpost%2F235983682%2F</url>
    <content type="text"><![CDATA[定义顺序查找又称为线性查找，其算法思路是从数组中的第一个（或最后一个）记录开始，将数组中元素逐个与需要查找的关键字进行比对，若发现有相等的，则查找成功；若始终未能相等，则查找失败。 Java实现// 定义接口 interface Searcher { /** * 从数组array中查找关键字key,如果存在则返回该关键字在数组中任意出现的位置(不局限于首次或者末次之类的),否则返回-1 */ int search(int[] array, int key); } /** * 顺序表查找,时间复杂度为O(n) */ class LinearSearcher implements Searcher { @Override public int search(int[] array, int key) { int len = array.length; for (int i = 0; i &lt; len; i++) { if (array[i] == key) return i; } return -1; } } LinearSearcher是标准的线性查找，这里有缺陷：在循环中每个循环实际上需要判断两次(一次是否相等,一次是否越界)，如何改进呢？其实就是设置“哨兵”： /** * 优化的顺序表查找,时间复杂度O(n),但是比普通顺序表查找效率高 */ class OptimizedLinearSearcher implements Searcher { // 相比单纯的线性查找每次for循环需要判断两次,这里设置关键字值(即哨兵)，可以让每次for循环只判断一次 // 当数据量比较大时,如果单纯从线性查找角度看,优化后的线性搜索优势明显 @Override public int search(int[] array, int key) { int len = array.length; if (len == 0) // array为空,返回-1 return -1; if (array[0] == key) return 0; array[0] = key; // array[0]不是key,那么将key赋值给array[0],将array[0]作为哨兵 // 这里&quot;哨兵&quot;也可以放在数组尾部 int i = len - 1; while (array[i] != key) { // 每次循环少判断一个 i--; } if (i == 0) // 从数组尾部一直查找到array[0]才找到,说明不存在 return -1; return i; } } 不论是线性查找还是改进后的线性查找，其时间复杂度都为O(n)]]></content>
      <categories>
        <category>Algorithm &amp; Data Structure</category>
      </categories>
      <tags>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP字符串模式匹配算法Java实现]]></title>
    <url>%2Fpost%2F3825161135%2F</url>
    <content type="text"><![CDATA[本文灵感来自于July的博客从头到尾彻底理解KMP，并着重于Java实现 :)。 现有字符串匹配算法有不少，如简单暴力的朴素算法(暴力匹配算法)、KMP算法、BM算法以及Sunday算法等，在这里仅介绍前两种算法。 1. 朴素算法朴素算法即暴力匹配算法，对于长度为n的文本串S和长度为m模式串P，在文本串S中是否存在一个有效偏移i，其中 0≤ i &lt; n - m + 1，使得 S[i… i+m - 1] = P[0 … m-1]（注：下标从0开始），如果存在则匹配成功，否则匹配失败。由于在匹配过程中一旦不匹配，就要让模式串P相对于文本串S右移1，即i需要进行回溯，其时间复杂度为O(n*m)。Java实现： // 定义接口 interface StringMatcher { /** * 从原字符串中查找模式字符串的位置,如果模式字符串存在,则返回模式字符串第一次出现的位置,否则返回-1 * * @param source * 原字符串 * @param pattern * 模式字符串 * @return if substring exists, return the first occurrence of pattern * substring, return -1 if not. */ int indexOf(String source, String pattern); } /** * 暴力匹配 * &lt;p&gt; * 时间复杂度: O(m*n), m = pattern.length, n = source.length */ class ViolentStringMatcher implements StringMatcher { @Override public int indexOf(String source, String pattern) { int i = 0, j = 0; int sLen = source.length(), pLen = pattern.length(); char[] src = source.toCharArray(); char[] ptn = pattern.toCharArray(); while (i &lt; sLen &amp;&amp; j &lt; pLen) { if (src[i] == ptn[j]) { // 如果当前字符匹配成功,则将两者各自增1,继续比较后面的字符 i++; j++; } else { // 如果当前字符匹配不成功,则i回溯到此次匹配最开始的位置+1处,也就是i = i - j + 1 // (因为i,j是同步增长的), j = 0; i = i - j + 1; j = 0; } } // 匹配成功,则返回模式字符串在原字符串中首次出现的位置;否则返回-1 if (j == pLen) return i - j; else return -1; } } 2. KMP算法与朴素算法不同，朴素算法是当遇到不匹配字符时，向后移动一位继续匹配，而KMP算法是当遇到不匹配字符时，不是简单的向后移一位字符，而是根据前面已匹配的字符数和模式串前缀和后缀的最大相同字符串长度数组next的元素来确定向后移动的位数，所以KMP算法的时间复杂度比朴素算法的要少，并且是线性时间复杂度，即预处理时间复杂度是O(m)，匹配时间复杂度是O(n)。 next数组含义：代表在模式串P中，当前下标对应的字符之前的字符串中，有多大长度的相同前缀后缀。例如如果next [j] = k，代表在模式串P中，下标为j的字符之前的字符串中有最大长度为k 的相同前缀后缀。 KMP算法的核心就是求next数组，在字符串匹配的过程中，一旦某个字符匹配不成功，next数组就会指导模式串P到底该相对于S右移多少位再进行下一次匹配，从而避免无效的匹配。 next数组求解方法： next[0] = -1。 如果已知next[j] = k,如何求出next[j+1]呢?具体算法如下: 如果p[j] = p[k], 则next[j+1] = next[k] + 1; 如果p[j] != p[k], 则令k=next[k],如果此时p[j]==p[k],则next[j+1]=k+1,如果不相等,则继续递归前缀索引,令 k=next[k],继续判断,直至k=-1(即k=next[0])或者p[j]=p[k]为止 详细的介绍及分析还请移步从头到尾彻底理解KMP，在下语拙 :(Java实现： /** * KMP模式匹配 * @author Tianma * */ class KMPStringMatcher implements StringMatcher { /** * 获取KMP算法中pattern字符串对应的next数组 * * @param p * 模式字符串对应的字符数组 * @return */ protected int[] getNext(char[] p) { // 已知next[j] = k,利用递归的思想求出next[j+1]的值 // 如果已知next[j] = k,如何求出next[j+1]呢?具体算法如下: // 1. 如果p[j] = p[k], 则next[j+1] = next[k] + 1; // 2. 如果p[j] != p[k], 则令k=next[k],如果此时p[j]==p[k],则next[j+1]=k+1, // 如果不相等,则继续递归前缀索引,令 k=next[k],继续判断,直至k=-1(即k=next[0])或者p[j]=p[k]为止 int pLen = p.length; int[] next = new int[pLen]; int k = -1; int j = 0; next[0] = -1; // next数组中next[0]为-1 while (j &lt; pLen - 1) { if (k == -1 || p[j] == p[k]) { k++; j++; next[j] = k; } else { k = next[k]; } } return next; } @Override public int indexOf(String source, String pattern) { int i = 0, j = 0; char[] src = source.toCharArray(); char[] ptn = pattern.toCharArray(); int sLen = src.length; int pLen = ptn.length; int[] next = getNext(ptn); while (i &lt; sLen &amp;&amp; j &lt; pLen) { // 如果j = -1,或者当前字符匹配成功(src[i] = ptn[j]),都让i++,j++ if (j == -1 || src[i] == ptn[j]) { i++; j++; } else { // 如果j!=-1且当前字符匹配失败,则令i不变,j=next[j],即让pattern模式串右移j-next[j]个单位 j = next[j]; } } if (j == pLen) return i - j; return -1; } } 3. 优化的KMP算法（改进next数组）具体过程移步从头到尾彻底理解KMP的3.3.8 Next 数组的优化在这里给出Java实现： /** * 优化的KMP算法(对next数组的获取进行优化) * * @author Tianma * */ class OptimizedKMPStringMatcher extends KMPStringMatcher { @Override protected int[] getNext(char[] p) { // 已知next[j] = k,利用递归的思想求出next[j+1]的值 // 如果已知next[j] = k,如何求出next[j+1]呢?具体算法如下: // 1. 如果p[j] = p[k], 则next[j+1] = next[k] + 1; // 2. 如果p[j] != p[k], 则令k=next[k],如果此时p[j]==p[k],则next[j+1]=k+1, // 如果不相等,则继续递归前缀索引,令 k=next[k],继续判断,直至k=-1(即k=next[0])或者p[j]=p[k]为止 int pLen = p.length; int[] next = new int[pLen]; int k = -1; int j = 0; next[0] = -1; // next数组中next[0]为-1 while (j &lt; pLen - 1) { if (k == -1 || p[j] == p[k]) { k++; j++; // 修改next数组求法 if (p[j] != p[k]) { next[j] = k;// KMPStringMatcher中只有这一行 } else { // 不能出现p[j] = p[next[j]],所以如果出现这种情况则继续递归,如 k = next[k], // k = next[[next[k]] next[j] = next[k]; } } else { k = next[k]; } } return next; } } 4. 花絮提到字符串匹配，或者说字符串查找，我们会想到Java中的String类就有一个String.indexOf(String str);方法，那它使用的是什么算法呢？在这里截取JavaSE-1.8的源码： // String.indexOf(String str); 最终会调用该方法 /** * Code shared by String and StringBuffer to do searches. The * source is the character array being searched, and the target * is the string being searched for. * * @param source the characters being searched.(源字符数组) * @param sourceOffset offset of the source string.(源字符数组偏移量) * @param sourceCount count of the source string.(源字符数组长度) * @param target the characters being searched for.(待搜索的模式字符数组) * @param targetOffset offset of the target string.(模式字符数组偏移量) * @param targetCount count of the target string.(模式数组长度) * @param fromIndex the index to begin searching from.(从原字符数组的哪个下标开始查询) */ static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) { if (fromIndex &gt;= sourceCount) { return (targetCount == 0 ? sourceCount : -1); } if (fromIndex &lt; 0) { fromIndex = 0; } if (targetCount == 0) { return fromIndex; } char first = target[targetOffset]; int max = sourceOffset + (sourceCount - targetCount); for (int i = sourceOffset + fromIndex; i &lt;= max; i++) { /* Look for first character. */ // 找到第一个匹配的字符的位置 if (source[i] != first) { while (++i &lt;= max &amp;&amp; source[i] != first); } /* Found first character, now look at the rest of v2 * if (i &lt;= max) { // 找到了第一个匹配的字符，看余下的是否完全匹配 int j = i + 1; int end = j + targetCount - 1; for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++); if (j == end) { /* Found whole string. */ return i - sourceOffset; } // 如果不完全匹配，因为外层for循环中有i++，即i+1继续匹配 // 故而该方法本质上就是字符串匹配的朴素算法 } } return -1; } 通过对代码片段的注释和分析可以看出，Java源码中的String.indexOf(String str); 内部所使用的算法其实就是字符串匹配的朴素算法… 源码github地址:StringMatchSample 重要参考:从头到尾彻底理解KMP]]></content>
      <categories>
        <category>Algorithm &amp; Data Structure</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>字符串模式匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈的应用之中缀表达式和后缀表达式]]></title>
    <url>%2Fpost%2F1484310523%2F</url>
    <content type="text"><![CDATA[中缀表达式： 是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于的中间（例：3 + 4），中缀表达式是人们常用的算术表示方法，但是不易被计算机所解析。 后缀表达式：是一个通用的算术或逻辑公式表示方法， 操作符是后缀形式处于操作数的后面（例：3 4 +），后缀表达式虽然不是人们所习惯的运算表示方法，但是易被计算机解析。例如：对于中缀表达式 9+(3-1)*2+10/2 , 其后缀表达式是 9 3 1 - 3 * + 10 2 / + , 那么为了方便计算机解析计算，我们需要将中缀表达式转换成后缀表达式，然后再对后缀表达式进行解析。 1. 中缀表达式转后缀表达式： 当读到一个操作数时，立即将它放到输出中。读到的是操作符则需要接着判断是否该入栈。读到的是左圆括号则入栈。 在读到操作符时，如果栈为空或者栈顶操作符为（，则入栈。如果栈顶操作符不为（，且此操作符优先级小于或等于此时栈顶操作符，则将栈中元素弹出直至 ①遇到左括号 或者 ②栈顶元素为更低优先级 或者 ③栈为空为止，并将当前操作符入栈；否则当前操作符继续入栈。操作符中，+-优先级低，*/优先级高。 如果遇到一个右括号，那么就将栈中元素弹出并输出直至遇到左括号为止。但是这个左括号只被弹出，并不输出。 如果读到输入的末尾，若栈不为空则将栈元素弹出直到该栈变成空栈，并将弹出的符号写到输出中。 “9+(3-1)*2+10/2” 转换过程： 操作过程 栈中元素 输出 读入 9，输出 9 读入 +，栈为空，规则2，入栈 + 9 读入 ( ，左括号，规则1，入栈 + ( 9 读入 3，输出 + ( 9 3 读入 -，栈顶为（，规则2，入栈 + ( - 9 3 读入 1，输出 + ( - 9 3 1 读入 ) ，右括号，规则3，出栈并输出 + 9 3 1 - 读入 *，*优先级高于栈顶+，规则,2，入栈 + * 9 3 1 - 读入 3，输出 + * 9 3 1 - 3 读入 +，+优先级低于栈顶*，规则2，栈中元素出栈，当前操作符入栈 + 9 3 1 - 3 * + 读入 10， 输出 + 9 3 1 - 3 * + 10 读入 / ， /优先级高于+，入栈 + / 9 3 1 - 3 * + 10 读入 2， 输出 + / 9 3 1 - 3 * + 10 读至末尾，规则4，栈不为空，栈中元素出栈并输出 9 3 1 - 3 * + 10 / + 2. 后缀表达式计算最终结果： 从左到右遍历表达式的每个数字和符号,遇到是数字则进栈,遇到是运算符则将栈顶两个元素出栈,进行运算并将运算结果进栈； 遍历完后缀表达式,此时栈中剩余的数字就是运算结果。 “9 3 1 - 3 * + 10 2 / +” 计算过程： 操作过程 栈中元素 读入 9，入栈 9 读入 3，入栈 9 3 读入 1，入栈 9 3 1 读入 -，运算并将结果入栈 9 2 读入 3，入栈 9 2 3 读入 *，运算并将结果入栈 9 6 读入 +，运算并将结果入栈 15 读入 10，入栈 15 10 读入 2，入栈 15 10 2 读入 /，运算并将结果入栈 15 5 读入 +，运算并将结果入栈 20 读入完毕，栈中元素即为结果 20 简单中缀表达式计算的java实现： public class SimpleCalcutor { private class Item { private String value; private Integer number; public Item(String value) { this.value = value; try { number = Integer.parseInt(value); } catch (Exception ignore) { } } public boolean isNumber() { return number != null; } public int getNumber() { if (isNumber()) return number; throw new NumberFormatException(); } public boolean isAdd() { return &quot;+&quot;.equals(value); } public boolean isSub() { return &quot;-&quot;.equals(value); } public boolean isMul() { return &quot;*&quot;.equals(value); } public boolean isDiv() { return &quot;/&quot;.equals(value); } public boolean isLeftBracket() { return &quot;(&quot;.equals(value); } public boolean isRightBracket() { return &quot;)&quot;.equals(value); } public int getPriority() { if (isAdd() || isSub()) return 0; if (isMul() || isDiv()) return 1; throw new RuntimeException(&quot;This is not +, -, *, /&quot;); } @Override public String toString() { return value != null ? value.toString() : null; } } /** * 计算结果 * * @param calStr * @return */ public int calculate(String calStr) { List&lt;Item&gt; infixes = parse(calStr); List&lt;Item&gt; postfixes = infix2postfix(infixes); return calculateByPostfix(postfixes); } /** * 利用正则表达式将待计算的字符串转化为List&lt;Item&gt;形式 ,如 10/2 -&gt; [10, /, 2] * * @param calStr * @return */ private List&lt;Item&gt; parse(String calStr) { Pattern pattern = Pattern.compile(&quot;\\D|\\d+&quot;); Matcher m = pattern.matcher(calStr); List&lt;Item&gt; items = new ArrayList&lt;Item&gt;(); while (m.find()) { items.add(new Item(m.group(0))); } return items; } /** * 中缀表达式转换为后缀表达式 * &lt;p&gt; * 1.当读到一个操作数时，立即将它放到输出中。读到的是操作符则需要接着判断是否该入栈。读到的是左圆括号则入栈。&lt;br&gt; * 2.如果遇到一个右括号，那么就将栈中元素弹出并输出直至遇到左括号为止。但是这个左括号只被弹出，并不输出。&lt;br&gt; * 3.在读到操作符时，如果此操作符优先级小于或等于此时栈顶操作符，则将栈中元素弹出直至(1)遇到左括号或者(2)栈顶元素为更低优先级或者(3) * 栈为空为止。操作符中，&#39;+&#39;&#39;-&#39;优先级最低，&#39;(&#39;&#39;)&#39;优先级最高。 &lt;br&gt; * 4.如果读到输入的末尾，将栈元素弹出直到该栈变成空栈，将符号写到输出中。 * * @return */ private List&lt;Item&gt; infix2postfix(List&lt;Item&gt; infixes) { List&lt;Item&gt; postfixes = new ArrayList&lt;Item&gt;(); Stack&lt;Item&gt; stack = new Stack&lt;Item&gt;(); for (Item item : infixes) { if (item.isNumber()) { postfixes.add(item); } else if (item.isRightBracket()) { // ) 右括号,将栈中元素弹出直至左括号,且左括号和右括号不加入到后缀表达式中 while (true) { Item tmp = stack.pop(); if (tmp.isLeftBracket()) break; postfixes.add(tmp); } } else if (item.isLeftBracket()) { // ( 左括号,将左括号入栈 stack.push(item); } else { // 当前操作符为 +, -, *, /, if (stack.isEmpty()) { // 操作符栈为空,则将当前操作符压入栈 stack.push(item); continue; } Item top = stack.peek(); if (top.isLeftBracket()) { // 操作符栈顶为左括号(,则将当前操作符压入栈 stack.push(item); continue; } if (item.getPriority() &lt;= top.getPriority()) { // 如果此操作符(+,-,*,/)优先级小于或等于此时栈顶操作符 // 则将栈中元素弹出直至(1)遇到左括号或者(2)栈顶元素为更低优先级或者(3)栈为空为止 // 并将弹出的元素加入后缀表达式中,将当前操作符压入栈中 while (true) { Item tmp = stack.peek(); if (tmp.isLeftBracket() || tmp.getPriority() &lt; item.getPriority()) { break; } postfixes.add(tmp); stack.pop(); if (stack.isEmpty()) break; } stack.push(item); } else { // 如果当前操作符(+,-,*,/)优先级大于此时栈顶操作符,则将当前操作符压入栈 stack.push(item); } } } // 如果栈中元素不为空,则将栈中元素全部弹出,加入后缀表达式中 while (!stack.isEmpty()) { postfixes.add(stack.pop()); } return postfixes; } /** * 通过后缀表达式计算数值 * &lt;p&gt; * 1. 从左到右遍历表达式的每个数字和符号,遇到是数字则进栈,遇到是运算符则将栈顶两个元素出栈,进行运算并将运算结果进栈&lt;br&gt; * 2. 遍历完后缀表达式,此时栈中剩余的数字就是运算结果 * * @param postfixes * @return */ private int calculateByPostfix(List&lt;Item&gt; postfixes) { Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for (Item item : postfixes) { if (item.isNumber()) { stack.push(item.getNumber()); } else { // 运算符 int num1 = stack.pop(); int num2 = stack.pop(); int result; if (item.isAdd()) { result = num2 + num1; } else if (item.isSub()) { result = num2 - num1; } else if (item.isMul()) { result = num2 * num1; } else if (item.isDiv()) { result = num2 / num1; } else { throw new IllegalArgumentException(&quot;Operator invalid : &quot; + item.value); } stack.push(result); } } return stack.pop(); } public static void main(String[] args) { SimpleCalcutor calcutor = new SimpleCalcutor(); String calStr = &quot;9+(3-1)*3+10/2&quot;; int result = calcutor.calculate(calStr); System.out.println(result); } } 源码github地址：SimpleCalculator 参考链接：利用栈将中缀表达式转换成后缀表达式]]></content>
      <categories>
        <category>Algorithm &amp; Data Structure</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android根据图片Uri获取图片绝对路径]]></title>
    <url>%2Fpost%2F3401996021%2F</url>
    <content type="text"><![CDATA[当我们需要选择并获取图片将其展示出来时，一般会这样处理： // 进入选择图片的界面 private void selectImage(){ Intent intent = new Intent(Intent.ACTION_GET_CONTENT); intent.setType(&quot;image/*&quot;); startActivityForResult(intent, YOUR_CHOOSE_IMAGE_REQUEST_CODE); } // 在onActivityResult()回调方法中进行数据获取 protected void onActivityResult(int requestCode, int resultCode, Intent data) { // ... 进行一些判断处理 Uri uri = data.getData(); // ... 接下来进行图片显示 } 以上可以看出我们获取的是Uri类型的数据，要显示图片可以先根据Uri获取图片的位置，然后再显示在界面上，那么如何根据Uri来获取图片的绝对路径呢？ 这涉及到Android版本适配问题，因为Android Api版本不同，获取Uri对应的图片绝对路径也不一样，那么需要对不同的Api进行适配： 2017-7-14 更新：感谢朋友们的反馈，之前的写法因为没有考虑全面，会在 api&gt;=19 时出现空指针异常，这里将代码更新。如遇问题，烦请留言反馈。 /** * 根据Uri获取图片的绝对路径 * * @param context 上下文对象 * @param uri 图片的Uri * @return 如果Uri对应的图片存在, 那么返回该图片的绝对路径, 否则返回null */ public static String getRealPathFromUri(Context context, Uri uri) { int sdkVersion = Build.VERSION.SDK_INT; if (sdkVersion &gt;= 19) { // api &gt;= 19 return getRealPathFromUriAboveApi19(context, uri); } else { // api &lt; 19 return getRealPathFromUriBelowAPI19(context, uri); } } /** * 适配api19以下(不包括api19),根据uri获取图片的绝对路径 * * @param context 上下文对象 * @param uri 图片的Uri * @return 如果Uri对应的图片存在, 那么返回该图片的绝对路径, 否则返回null */ private static String getRealPathFromUriBelowAPI19(Context context, Uri uri) { return getDataColumn(context, uri, null, null); } /** * 适配api19及以上,根据uri获取图片的绝对路径 * * @param context 上下文对象 * @param uri 图片的Uri * @return 如果Uri对应的图片存在, 那么返回该图片的绝对路径, 否则返回null */ @SuppressLint(&quot;NewApi&quot;) private static String getRealPathFromUriAboveApi19(Context context, Uri uri) { String filePath = null; if (DocumentsContract.isDocumentUri(context, uri)) { // 如果是document类型的 uri, 则通过document id来进行处理 String documentId = DocumentsContract.getDocumentId(uri); if (isMediaDocument(uri)) { // MediaProvider // 使用&#39;:&#39;分割 String id = documentId.split(&quot;:&quot;)[1]; String selection = MediaStore.Images.Media._ID + &quot;=?&quot;; String[] selectionArgs = {id}; filePath = getDataColumn(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection, selectionArgs); } else if (isDownloadsDocument(uri)) { // DownloadsProvider Uri contentUri = ContentUris.withAppendedId(Uri.parse(&quot;content://downloads/public_downloads&quot;), Long.valueOf(documentId)); filePath = getDataColumn(context, contentUri, null, null); } } else if (&quot;content&quot;.equalsIgnoreCase(uri.getScheme())){ // 如果是 content 类型的 Uri filePath = getDataColumn(context, uri, null, null); } else if (&quot;file&quot;.equals(uri.getScheme())) { // 如果是 file 类型的 Uri,直接获取图片对应的路径 filePath = uri.getPath(); } return filePath; } /** * 获取数据库表中的 _data 列，即返回Uri对应的文件路径 * @return */ private static String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) { String path = null; String[] projection = new String[]{MediaStore.Images.Media.DATA}; Cursor cursor = null; try { cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs, null); if (cursor != null &amp;&amp; cursor.moveToFirst()) { int columnIndex = cursor.getColumnIndexOrThrow(projection[0]); path = cursor.getString(columnIndex); } } catch (Exception e) { if (cursor != null) { cursor.close(); } } return path; } /** * @param uri the Uri to check * @return Whether the Uri authority is MediaProvider */ private static boolean isMediaDocument(Uri uri) { return &quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority()); } /** * @param uri the Uri to check * @return Whether the Uri authority is DownloadsProvider */ private static boolean isDownloadsDocument(Uri uri) { return &quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority()); } 以上便可以获取Uri对应的图片的绝对路径，然后就可以愉快的做我们想做的事情咯~ 最后，附上一个小demo，可以戳 这里 参考链接:Android Gallery on KitKat returns different Uri for Intent.ACTION_GET_CONTENT]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Real Path</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android获取图片压缩后的Bitmap避免OOM]]></title>
    <url>%2Fpost%2F3401996020%2F</url>
    <content type="text"><![CDATA[OOM即Out Of Memory的简称，Android平台避免OOM异常的发生是非常有必要的。而在Android中加载大量大图便可能会导致OOM异常的出现，解决的办法之一就是加载图片之前对图片进行压缩然后再获取图片对应的Bitmap对象，那么应该如何操作呢？ 如下： /** * 通过图片的绝对路径来获取对应的压缩后的Bitmap对象 */ public static Bitmap getCompressedBitmap(String filePath, int requireWidth, int requireHeight) { // 第一次解析将inJustDecodeBounds设置为true,用以获取图片大小,并且不需要将Bitmap对象加载到内存中 BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeFile(filePath, options); // 第一次解析 // 计算inSampleSize的值,并且赋值给Options.inSampleSize options.inSampleSize = calculateInSampleSize(options, requireWidth, requireHeight); // 使用获取到的inSampleSize再次解析图片 options.inJustDecodeBounds = false; return BitmapFactory.decodeFile(filePath, options); } /** * 通过图片资源id获取图片对应的压缩后的Bitmap对象 */ public static Bitmap getCompressedBitmap(Resources res, int resId, int requiredWidth, int requiredHeight) { BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeResource(res, resId, options);// 第一次解析 options.inSampleSize = calculateInSampleSize(options, requiredWidth, requiredHeight); options.inJustDecodeBounds = false; return BitmapFactory.decodeResource(res, resId, options);// 第一次解析 } /** * 计算压缩的inSampleSize的值,该值会在宽高上都进行压缩(也就是压缩前后比例是inSampleSize的平方倍) */ private static int calculateInSampleSize(BitmapFactory.Options options, int requireWidth, int requireHeight) { // 获取源图片的实际的宽度和高度 int realWidth = options.outWidth; int realHeight = options.outHeight; int inSampleSize = 1; if (realWidth &gt; requireWidth || realHeight &gt; requireHeight) { // 计算出实际的宽高与目标宽高的比例 int widthRatio = Math.round((float) realWidth / (float) requireWidth); int heightRatio = Math.round((float) realHeight / (float) requireHeight); // 选择宽高比例最小的值赋值给inSampleSize,这样可以保证最终图片的宽高一定会大于或等于目标的宽高 inSampleSize = widthRatio &lt; heightRatio ? widthRatio : heightRatio; } return inSampleSize; } 以上代码中，有一点值得商榷：到底是要让图片显示完全还是让图片宽高和需要的宽高一致呢？如果需要让图片宽高和需要的宽高一致的话，就选择比率小的: inSampleSize = widthRatio &lt; heightRatio ? widthRatio : heightRatio; 如果需要让图片显示完全的话，就选择比率大的： inSampleSize = widthRatio &gt; heightRatio ? widthRatio : heightRatio; 如果两者都要兼顾的话，就让方法多设置参数，让调用者决定去吧！ :) 参考链接：Displaying Bitmaps EfficientlyAndroid高效加载大图、多图解决方案，有效避免程序OOM]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Bitmap</tag>
        <tag>OOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android获取Bitmap在其ImageView中的偏移量]]></title>
    <url>%2Fpost%2F4080066433%2F</url>
    <content type="text"><![CDATA[在ImageView中设置不同的scaleType(包括center, centerInside, centerCrop, fitXY, fitCenter, fitStart, fitEnd, matrix)属性时，ImageView中实际的图片(也就是Bitmap)会根据不同的scaleType属性来确定自己相对于ImageView的位置。 例如： fitCenter: fitStart:图片中的天蓝色是我给ImageView设置的backgroud属性，可以看出Bitmap相对于ImageView的位置与scaleType属性是相关的。那么，如何获取Bitmap在其ImageView中的偏移量（也就是在x和y方向上的像素偏移量）呢？代码片段如下： /** * 获取Bitmap在ImageView中的偏移量数组,其中第0个值表示在水平方向上的偏移值,第1个值表示在垂直方向上的偏移值 * * @param imageView * @param includeLayout 在计算偏移的时候是否要考虑到布局的因素,如果要考虑该因素则为true,否则为false * @return the offsets of the bitmap inside the imageview, offset[0] means horizontal offset, offset[1] means vertical offset */ private int[] getBitmapOffset(ImageView imageView, boolean includeLayout) { int[] offset = new int[2]; float[] values = new float[9]; Matrix matrix = imageView.getImageMatrix(); matrix.getValues(values); // x方向上的偏移量(单位px) offset[0] = (int) values[2]; // y方向上的偏移量(单位px) offset[1] = (int) values[5]; if (includeLayout) { ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams) imageView.getLayoutParams(); int paddingTop = imageView.getPaddingTop(); int paddingLeft = imageView.getPaddingLeft(); offset[0] += paddingLeft + params.leftMargin; offset[1] += paddingTop + params.topMargin; } return offset; } 上面的代码中Matrix类实际上是一个3*3的矩阵，看Android源码： public class Matrix { public static final int MSCALE_X = 0; public static final int MSKEW_X = 1; public static final int MTRANS_X = 2; public static final int MSKEW_Y = 3; public static final int MSCALE_Y = 4; public static final int MTRANS_Y = 5; public static final int MPERSP_0 = 6; public static final int MPERSP_1 = 7; public static final int MPERSP_2 = 8; ... } 其中MTRANS_X，MTRANS_Y字段分别表示x和y方向上的平移量。所以在代码片段中会出现： offset[0] = (int) values[2]; offset[1] = (int) values[5]; 参考链接：android - how to get the image edge x/y position inside imageviewAndroid中图像变换Matrix的原理、代码验证和应用]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Bitmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3.4在内存中生成zip压缩文件]]></title>
    <url>%2Fpost%2F4080066432%2F</url>
    <content type="text"><![CDATA[最近使用Django1.8.5搭建了一个Web项目，用来生成Android客户端的皮肤apk，相当于一个在线的皮肤apk生成工具，于是就理所当然的需要进行在线的下载apk的操作。由于Android项目比较大，一种主题皮肤对应的apk不止一个，一次性下载多个文件的话，于是选择打包下载。 本文在使用Python在内存中生成zip文件的基础上也进行了小的修改。主要是原文的生产环境是Python2.x，而我使用的是Python3.4，在语法上有些小的变动。 # !user/bin/env python3 # -*-coding : utf-8 -*- import zipfile from io import BytesIO import os u&#39;&#39;&#39; Create zip file in memory. &#39;&#39;&#39; class InMemoryZIP(object): def __init__(self): # create the in-memory file-like object self.in_memory_zip = BytesIO() def append(self, filename_in_zip, file_contents): &quot;&quot;&quot; Appends a file with name filename_in_zip \ and contents of file_contents to the in-memory zip. &quot;&quot;&quot; # create a handle to the in-memory zip in append mode zf = zipfile.ZipFile(self.in_memory_zip, &#39;a&#39;, zipfile.ZIP_DEFLATED, False) # write the file to the in-memory zip zf.writestr(filename_in_zip, file_contents) # mark the files as having been created on Windows # so that Unix permissions are not inferred as 0000 for zfile in zf.filelist: zfile.create_system = 0 return self def appendfile(self, file_path, file_name=None): &quot;&quot;&quot; Read a file with path file_path \ and append to in-memory zip with name file_name. &quot;&quot;&quot; if file_name is None: file_name = os.path.split(file_path)[1] f = open(file_path, &#39;rb&#39;) file_contents = f.read() self.append(file_name, file_contents) f.close() return self def read(self): &quot;&quot;&quot; Returns a string with the contents of the in-memory zip. &quot;&quot;&quot; self.in_memory_zip.seek(0) return self.in_memory_zip.read() def writetofile(self, filename): &quot;&quot;&quot; Write the in-memory zip to a file &quot;&quot;&quot; f = open(filename, &#39;wb&#39;) f.write(self.read()) f.close() if __name__ == &#39;__main__&#39;: imz = InMemoryZIP() imz.appendfile(&#39;a.txt&#39;).append(&#39;test.txt&#39;, &#39;This is content in test.txt&#39;) imz.writetofile(&#39;test.zip&#39;) 与原链接中的博文相比主要改动如下： 将原文的 import StringIO 改成了 from io import BytesIO，主要就是 Python2.x 和 Python3.x 的格式区别。其实也可以将 import StringIO 改成 from io import BytesIO as StringIO ，这样的话在代码中就不需要进行替换，但是可能会误导其他读这段代码的人。 在Django中简单的使用方法为: #... def downloadFiles(request): fns = [&quot;/apk/foo1.apk&quot;, &quot;/apk/foo2.apk&quot;, &quot;/apk/foo3.apk&quot;,] imz = InMemoryZip() for fn in fns: imz.appendfile(fn) data = img.read() response = HttpResponse(content_type=&quot;application/octet-stream&quot;) response[&quot;Content-Disposition&quot;] = &quot;attachment; %s&quot; % &quot;foo.zip&quot; response[&quot;Content-Length&quot;] = len(data) response.write(data) return response 与原链接的博文相比改动就是 HttpResponse 中的参数要使用 content_type 而不是 mimetype最后引用原文的一段话: 这个方法虽然很方便，不过很耗资源，我试着用它在 Django 里压缩一个 1.4G 的文本文件，差不多用了 8 分钟，期间 CPU 使用率一直是 100%，所以，如果要压缩的是大文件，或者压缩任务比较频繁，可能需要认真处理一下性能问题。 也就是说这个方法适合下载小文件，要是下载的文件较大的话，建议阅读以下文章: Django 大文件下载 Django 实现下载文件功能]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>zip压缩</tag>
      </tags>
  </entry>
</search>
