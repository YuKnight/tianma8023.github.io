<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Android 文字绘制中的 FontMetrics 和 drawText()]]></title>
      <url>post%2F3678283086%2F</url>
      <content type="text"><![CDATA[在绘制文字的时候，不可避免的用到 FontMetrics 类和 Canvas#drawText() 方法，这里详细介绍下。 FontMetrics先看下面这张图：FontMetrics Lines 图中有五条线，自上而下分别是： top line: 文字可绘制区域最顶部的线； ascent line: 系统推荐的，文字可绘制区域顶部的线； baseline: 文字绘制的基线（在四线格上书写英文字母时的第三条线）； descent line: 系统推荐的，文字可绘制区域底部的线； bottom line: 文字可绘制区域最底部的线。 而 FontMetrics 类中有 [top, ascent, descent, bottom, leading] 字段，与上面 5 条线的关系是： FontMetrics对象中的字段值 = 对应线条的 Y 坐标值 - baseline的 Y 坐标值 ，如果用 Y(line A) 表示线条 A 的 Y 坐标的话，那么以下等式成立： FontMetrics::top = Y(top line) - Y(baseline); FontMetrics::ascent = Y(ascent line) - Y(baseline); FontMetrics::descent = Y(descent line) - Y(baseline); FontMetrics::bottom = Y(bottom line) - Y(baseline); 需要注意的是： 通常情况下，Android 中的 y 轴的正方向是沿屏幕向下的，也就是越往下 y 坐标越大，所以 FontMetrics 的 top 和 ascent 值是负值， descent 和 bottom 的值是正值。 余下的字段 leading 表示 系统推荐的行间距。 在实际开发中，通常使用 Paint 的 getFontMetrics() 获得其对应的 FontMetrics 对象。 drawText()绘制文字的时候，需要使用 Canvas 的 drawText(String text, float x, float y, Paint paint) 方法，其中的 text 表示 所需绘制的文字， paint 表示 画笔，这很好理解，那么 x 和 y 又是什么呢？ 这里把 x 和 y 组成的点 (x, y) 称作 基点，用于控制文字绘制的基准位置，而 Paint 中的 Align 对象指定文字对齐方式。 基点 和 Align 共同作用从而成功绘制文字。特别地是：基点的 Y 坐标（也就是 y 值）其实就是前面提到的 baseline 的 Y 坐标。 比如：上面图中 baseline 上的黄点就是基点，可以观察得出其对齐方式 Align 就是 CENTER。 Sample示例截图：FontMetrics Sample GitHub: FontMetricsSample 参考 Meaning of top, ascent, baseline, descent, bottom, and leading in Android’s FontMetrics 自定义控件之绘图篇（ 五）：drawText()详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo 折腾：音乐播放]]></title>
      <url>post%2F3998746934%2F</url>
      <content type="text"><![CDATA[最近想要在博客中插入音乐（网易云音乐），目前找到了三种解决方案： 使用音乐平台自己的插件 使用 hexo-tag-aplayer 结合 MetingJS 使用 APlayer 1. 使用音乐平台官方插件以网易云音乐为例，在Web网页上找到 歌单/单曲/专辑 页面，点击 生成外链播放器 即可跳转到官方提供的音乐播放插件使用引导页面，比如这个 外链插件。可以在自己博客页面中嵌入插件: &lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=330 src="//music.163.com/outchain/player?type=0&amp;id=827122421&amp;auto=0&amp;height=430"> &lt;/iframe> 效果展示： 缺点： 网易音乐有些音乐因为版权保护，没办法生成外链 音乐平台众多，不同的平台可能插件规范不一样，插入不同平台来源的歌曲可能比较麻烦。 2. 使用 hexo-tag-aplayer 插件hexo-tag-player 就是将 APlayer 内嵌入博客页面的 Hexo 插件。 安装 npm install --save hexo-tag-aplayer 使用 {% aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %} 还支持其他参数，同时支持歌词、歌曲列表等功能，详情参考该项目主页。 缺点： 目前不支持在线播放（其他音乐网站歌曲），具体参考这个 issue 3. 使用 APlayer + MetingJSAplayer 是目前广泛使用的 HTML5 音乐播放器，MetingJS 用于解析歌曲链接。 以我目前的 hexo-theme-material 主题为例： 引入JS（最新的CDN请参考官网），创建 /layout/_widget/aplayer.ejs ： &lt;!-- Import APlayer --> &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.6.0/APlayer.min.js">&lt;/script> &lt;!-- Import meting.js --> &lt;script src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js">&lt;/script> 考虑到不是所有的博客页面都需要嵌入 aplayer, 所以在 /_partial/head.ejs 中加入： &lt;!-- Import APlayer.js --> &lt;% if (page.aplayer === true) { %> &lt;%- partial('_widget/aplayer') %> &lt;% } %> 使用，需要内嵌 APlayer 的页面中： 在Front-matter 中加入： aplayer: true 嵌入 APlayer： &lt;div class="aplayer" data-id="id" data-server="server" data-type="type"> &lt;/div> 参数： 参数 是否必须 默认值 描述&amp;可选值 data-id 是 单曲ID / 歌单ID / 专辑ID / 搜索关键词 data-server 是 音乐平台：netease,tencent,kugou,xiami,baidu data-type 是 音乐类型：song,playlist,album,search,artist data-mode 否 circulation 播放模式：circulation,random,single,order data-autoplay 否 false 是否自动播放，移动端浏览器不支持该选项 data-mutex 否 true 播放时是否暂停其他APlayer对象 data-listmaxheight 否 340px 播放列表最高高度 data-preload 否 auto 音乐预加载模式：none, metadata, auto data-theme 否 #ad7a86 主题色 更多参数参考:MetingJS Options &nbsp;&nbsp;APlayer Options 效果展示： 单曲: &lt;div class="aplayer data-id="33911781" data-server="netease" data-type="song" data-mutex="false"> &lt;/div> 歌单： &lt;div class="aplayer" data-id="775701065" data-server="netease" data-type="playlist" data-mode="random" data-listmaxheight="240px" data-theme="#FF4081"> &lt;/div> 最后考虑到我最初的需求是 能播放在线歌单 ，再考虑到便利性，所以最终选择了第三种方案。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JitPack - 发布Android库]]></title>
      <url>post%2F667499984%2F</url>
      <content type="text"><![CDATA[JitPack.io 是一个 JVM/Android 工程的包管理仓库。开发者可以在上面发布自己的库，一旦成功发布，就可以方便的在 Gradle 中引用。 当然了，Andriod 相关的包管理仓库除了 JitPack 之外，还有 jCenter 等，但 JitPack 应该发布起来是最简单的了。 发布 Android Library1. Gradle为了让 JitPack 能正确的构建 Android 工程，需要添加 android-maven-gradle-plugin 插件： 如果使用的 Gradle 版本 &gt;= 4.1 （即使用的 com.android.build.gradle 版本 &gt;= 3.0.0）: 在项目根目录的 build.gradle 中如下配置： buildscript { dependencies { classpath 'com.github.dcendents:android-maven-gradle-plugin:2.0' // 添加这行配置 } } 在库工程的 build.gradle 中如下配置： apply plugin: 'com.github.dcendents.android-maven' group = 'com.github.YourUsername' 如果使用的其他版本的 Gradle 配置会有所变化，因为 android-maven-gradle-plugin 和 Gradle 版本有个对应关系。具体配置和上面的相似，只不过对应版本，详情可以戳这里 android maven gradle plugin - Note on Releases 2. GitHub在Github对应项目上发布release包或者添加一个tag，网上教程很多，略过。 3. JitPack参照下图，将项目提交到 JitPack ，让其构建对应的工程： 提交到JitPack 点击 Get it 按钮，JitPack 会给出指定库的引用配置信息： JitPack库的配置信息 使用 Android LibraryDependency 格式构成发布到 JitPack 的库的 dependency 的格式如下： Group(组) ： com.github.Username Artifact(产品) ： Repository Name (Github Repo 名) Version(版本) ：Release 的 tag 或者 commit hash 值 或者 -SNAPSHOT JitPack 中的 Snapshotsnapshot(快照) 版本在开发中很有用。snapshot 可以表示那些没有正式发布的版本。 指定的版本 和 snapshot版本 区别在于后者可能可以不断的更新版本，即可能指向最新的版本。所以snapshot版本在项目开发过程中很实用。 snapshot 版本格式如下： branch-SNAPSHOT （分支名-SNAPSHOT） 例如： compile &#39;com.github.Username:RepoName:master-SNAPSHOT&#39; // eg &#39;com.github.tianma8023:SimpleLineChart:master-SNAPSHOT&#39; 通过添加 -SNAPSHOT 字段可以每次构建 master 分支上最新的 commit。 注意： 考虑到 Gradle 会缓存 SNAPSHOT 的版本，所以当使用 snapshot 的形式，并且有新的版本更新时，需要在 Android Studio 中通过 File -&gt; Synchronize 进行更新和同步。 Gradle 中导入 Library 使用你的库，需要把 jitpack.io 添加入仓库列表中去，在 项目根目录 的 build.gradle 中添加： allprojects { repositories { jcenter() maven { url 'https://jitpack.io' } // 添加这行 } } 注意：不要把 jitpack.io 添加到 buildscript 闭包中去。 在模块的 build.gradle 中添加库的依赖： dependencies { // 方式1. SNAPSHOT compile 'com.github.Username:RepoName:branch-SNAPSHOT' // eg. complie 'com.github.tianma8023:SimpleLineChart:master-SNAPSHOT' &nbsp; // 方式2. Release Tag // compile 'com.github.Username:RepoName:ReleaseTag' // eg. compile 'com.github.tianma8023:SimpleLineChart:0.0.2' &nbsp; // 方式3. Commit Hash // compile 'com.github.Username:RepoName:CommitHash' // eg. compile 'com.github.tianma8023:SimpleLineChart:015b8d6aff' } 踩坑 在导入 JitPack 的库工程的时候，会出现资源不能被获取的报错信息，但是 JitPack 上面的 Build 是成功的。这个时候，其实是是本地网络问题，因为 jitpack.io 走的是 https。 所以，可以添加网络代理，因为本身我用的 SS 科学上网的，所以在项目的 gradle.properties 文件中添加代理： # http systemProp.http.proxyHost=127.0.0.1 systemProp.http.proxyPort=1080 # https systemProp.https.proxyHost=127.0.0.1 systemProp.https.proxyPort=1080 按照之前的 Punlish 流程，引用 JitPack 库之后，并不能很好的阅读源码和查看注释，这是发布前的配置问题。参考 Maven 的配置，在 build 过程中执行文档化操作即可。在 library 模块下新建 javadoc-sources-build.gradle 文件： // Specify encoding - 指定编码方式 tasks.withType(JavaCompile) { options.encoding = 'UTF-8' } &nbsp; // Package source code - 打包源码 task sourcesJar(type: Jar) { from android.sourceSets.main.java.srcDirs classifier = 'sources' } &nbsp; task javadoc(type: Javadoc) { failOnError false source = android.sourceSets.main.java.sourceFiles classpath += project.files(android.getBootClasspath().join(File.pathSeparator)) classpath += configurations.compile } &nbsp; // generate javadoc - 生成Javadoc task javadocJar(type: Jar, dependsOn: javadoc) { classifier = 'javadoc' from javadoc.destinationDir } &nbsp; artifacts { archives sourcesJar archives javadocJar } 然后在 library 模块下的 build.gradle 引入之前的配置： apply from: 'javadoc-sources-build.gradle' 之后按照正常发布流程即可。 参考 GitHub - JitPack.io JitPack - Publish an Android library android-maven-gradle-plugin 用JitPack发布时附加文档和源码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Goodbye 2017 Welcome 2018]]></title>
      <url>post%2F2666287230%2F</url>
      <content type="text"><![CDATA[白驹过隙，2017已离我而去，2018也匆匆而至。 2017败犬般浑浑噩噩地过日子，浑然不觉一年过去了。 2017的主题应该就是 逃避 了吧，自己是真的蠢。 自闭，逃避，废柴，死宅，咸鱼，鶸 给2017的自己。 2018本命插旗 要敢于面对惨淡的人生 别再囿于往事，固步自封 规律作息，好好学习，好好工作 摆脱 SAO MD 向前看 希望2019年的总结，能像模像样，以上。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[百度云资源加速下载]]></title>
      <url>post%2F3444791601%2F</url>
      <content type="text"><![CDATA[基于某些特殊的原因，非会员的情况下，百度云网盘客户端在下载资源时会进行限速。据可能不准确猜测，此行为的目的是推广其vip业务。因而产生了不少的应对策略来突破其下载限制。比较简单粗暴的就是破解版的PC客户端，然而破解版一是涉及到版权问题，而是可能破解版客户端会夹带私货不够安全，就不多bb了。 在这里介绍一些其他的解决方案。 Aria2 + BaiduExporter使用 Aira2 结合 BaiduExporter 越过度娘网盘下载速度限制，具体参考之前的： 下载工具aria2 - 配置和使用 BaiduExporter 介绍与使用 TampermonkeyTampermonkey(油猴，简称TM) 是 Chrome 浏览器上的一款插件，是一款脚本管理器，用于管理 JavaScript 脚本。通过 JS 脚本可以实现特定网页/网域内容的定制化操作。 正确姿势： Chrome 浏览器安装 Tampermonkey 扩展插件； 去 GreaskyFork 安装第三方的用户脚本，当然 TM 支持的用户脚本源不止这一个了，但 GreaskyFork 是目前受众最广最受欢迎的脚本源网站了； 以 百度/云/网盘 为关键字，可以搜到很多实用扩展。然后安装 百度网盘直接下载助手改 扩展脚本。 访问自己百度云盘网页，会发现多了一个 下载助手 按钮： 点击下载助手&nbsp;选择下载方式 2018.01.18 更新：因百度网盘已经修改相关代码，故而 百度网盘直接下载助手改 目前版本已失效，最新有效的扩展脚本是 百度网盘直接下载，在网盘页面点击 下载 按钮即可直接下载。 至于外链下载的话，我用的是 迅雷极速版，有需要的可以参考前面的文章 迅雷极速版 - 时代的眼泪]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[迅雷极速版 - 时代的眼泪]]></title>
      <url>post%2F2806688193%2F</url>
      <content type="text"><![CDATA[如果说提供 高效迅捷的P2P 下载服务是迅雷的核心业务，那迅雷产品中从一而终的就是 迅雷极速版。然而，伴随着与QQ旋风 PK 的胜利，迅雷的产品理念逐渐多了些杂乱无章的东西，引发的的恶果之一就有 迅雷极速版 的下架。 迅雷极速版 下架其实已经有很长一段时间了，之所以后知后觉，是因为 PC 上“绝版”的 迅雷极速版 仍然提供着高效的下载服务。最近手抽卸载了极速版，却发现她已经下架了。知乎上也有关于此事件的讨论， 如何看待迅雷极速版下架？。然后又尝试着下载了所谓的 迅雷9，整个一 浏览器 是闹哪样呢？呜呼哀哉！ 最终还是找到了极速版的最后一版，版本号 1.0.35.366 ，也许这个版本号应该被我们所铭记，毕竟又是一滴时代的眼泪不是吗？ :( 这里我提供最后一版的百度云链接: 百度云 - ThunderSpeed-1.0.35.366.zip, 提取密码 vhxa 。 我想，极速版我会用到其服务被关停为止，嗯。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo 折腾：利用 Fancybox 添加图片放大预览查看功能]]></title>
      <url>post%2F2208308547%2F</url>
      <content type="text"><![CDATA[在之前的博客中，有的图片因为页面宽度或者高度的限制，显得比较小，不是很清晰，而我目前使用的主题是 hexo-theme-material ，版本为 1.3.0，该版本主题本身未加入图片预览功能，所以就自己折腾来加入图片点击放大预览效果。 考虑到之前使用的主题 hexo-theme-next 中已经有了图片预览功能。next 主题使用 Fancybox 库实现图片预览。Fancybox 是一个基于 jQuery 的可高度定制化的轻量级库，可以用于显示图片、视频，并可以响应很多交互操作。因为 next 主题使用的 v2 版本的 fancybox，而官方弃用了 fancybox v2 并推荐使用 fancybox v3，所以本文主要参照 fancybox 的 官方文档 并结合 material 主题结构特点折腾出图片查看功能。 折腾主题配置配置中新增 fancybox 配置项为了提高 material 主题的可扩展性和可控制性，在 主题配置 文件中加入 fancybox 字段： # Fancybox support fancybox: true 下载fancybox库点击这里 下载最新的 fancybox 库， 解压缩至 /theme/material/source/lib/ 目录下，这里贴出目录结构： lib └── fancybox ├── bower.json └── dist ├── jquery.fancybox.css ├── jquery.fancybox.js ├── jquery.fancybox.min.css └── jquery.fancybox.min.js 下载下来的 fancybox 只保留了 /dist 目录和 bower.json 文件，其他的非必需。 编写js将fancybox应用到页面中参考 next 主题的 /next/source/js/src/utils.js , 我在 /material/source/js/ 下新增了 wrapImage.js 用于在指定的 &lt;img&gt; 外裹一层 fancybox 所需要的属性（前端不熟，js写的可能很次 ORZ ）： $(document).ready(function() { wrapImageWithFancyBox(); }); /** * Wrap images with fancybox support. */ function wrapImageWithFancyBox() { $('img').not('.sidebar-image img').not('#author-avatar img').not(".mdl-menu img").each(function() { var $image = $(this); var imageCaption = $image.attr('alt'); var $imageWrapLink = $image.parent('a'); if ($imageWrapLink.size() &lt; 1) { $imageWrapLink = $image.wrap('&lt;a href="' + this.getAttribute('src') + '">&lt;/a>').parent('a'); } $imageWrapLink.attr('data-fancybox', 'images'); if (imageCaption) { $imageWrapLink.attr('data-caption', imageCaption); } }); $().fancybox({ selector : '[data-fancybox="images"]', thumbs : true, hash : false, loop : false, }); } 上述代码中，thumbs, hash, loop 等都是 fancybox 支持的属性，更多具体属性可参考 Fancybox Options head模版中引入 fancybox 库由于我们需要在 html 的 &lt;head&gt; 标签中引入 fancybox js库，所以我们找到 &lt;head&gt; 标签对应的模版文件 /material/layout/_partial/head.ejs, 利用之前配置的 fancybox 配置项在 head.ejs 中引入 fancybox: &lt;!-- fancybox support --> &lt;% if(theme.fancybox === true) { %> &lt;%- css('lib/fancybox/dist/jquery.fancybox.min') %> &lt;%- js('lib/fancybox/dist/jquery.fancybox.min') %> &lt;%- js('js/wrapImage.js') %> &lt;% }%> 以上，重新生成静态网页，会发现网页源码中会新增如下内容： &lt;head> &lt;!-- ... --> &lt;!-- fancybox support --> &lt;link rel="stylesheet" href="../../lib/fancybox/source/jquery.fancybox.min.css"> &lt;script src="../../lib/fancybox/source/jquery.fancybox.min.js">&lt;/script> &lt;script src="../../js/wrapImage.js">&lt;/script> &lt;!-- ... --> &lt;/head> 至此，图片点击放大预览效果已实现，撒花 ✿✿ヽ(ﾟ▽ﾟ)ノ✿ 参考fancyBox3 Documentation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[打包导入BaiduExporter到Chrome教程（译）]]></title>
      <url>post%2F934692094%2F</url>
      <content type="text"><![CDATA[本文主要译自 Guide on Packaging and Import Baidu Exporter to Chrome，并在一些细微之处做了补充或修改，所有解释权归属于原作者，侵删。 前言因为侵权的原因，Google 将 BaiduExporter 从 Chrome Web Store 下架。出于安全的原因， Chrome 会禁用从本地导入的未知来源的扩展。每次启动 Chrome 时，如果 Chrome 加载了已解压的扩展程序，都会出现提示禁用的弹窗。 所以本文提供了一个通过使用 Windows 组策略来加载最新版本 BaiduExporter 的解决方案。 下载BaiduExporter扩展从 这里 克隆或者下载最新的 BaiduExporter 扩展。 打包扩展如果你有编译好的版本，以下步骤不需要： 启动 Chrome, 打开 chrome://extensions， 勾选 开发者模式，在上方选择 打包扩展程序； 定位到之前下载的 BaiduExporter 源码（选择 /BaiduExporter/chrome/ 目录），点击 打包扩展程序； 源码目录下将会新生成 *.pem 文件，保留这些文件，如果以后要更新扩展将会用到 *.pem 文件； 将生成的 *.crx 文件拖到 chrome://extensions 页面来安装扩展。勾选 开发者模式 来显示和获取 扩展ID 使用组策略编辑器来应用Chrome策略 从 这里 下载 Chrome 模版的压缩文件 将以下文件或者文件夹下所有文件拷贝到以 %SystemRoot%\PolicyDefinitions（通常是 C:\Windows\PolicyDefinitions ） 为根目录的对应目录下： ./windows/admx/chrome.admx; ./windows/admx/google.admx; ./windows/admx/en-US/; ./windows/admx/zh-CN/。 按下 Win+R 组合键并运行 gpedit.msc 打开组策略编辑器，如果在 本地计算机策略 -&gt; 计算机配置 -&gt; 管理模版 下看到 Google/Google Chrome 子目录，则说明Chrome策略添加成功。（PS. 简易版和家庭版的 Windows 系统没有内置组策略编辑器。如果你使用的是这些 Windows 版本，你应该先参考这个教程来安装组策略编辑器） 将BaiduExporter的扩展ID添加至白名单通过以下步骤将扩展ID添加至白名单： 组策略编辑器中，导航至 本地计算机配置 -&gt; 管理模版 -&gt; Google -&gt; Google Chrome -&gt; 扩展程序 部分； 在右侧双击并打开 配置扩展程序安装白名单； 勾选左上角的 已启用，点击左下方的 显示，将 BaiduExporter 的扩展ID添加进去。 添加至白名单的扩展将会在 Chrome 重启之后默认加载。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BaiduExporter 介绍与使用]]></title>
      <url>post%2F3364832428%2F</url>
      <content type="text"><![CDATA[介绍BaiduExporter 是一款可以方便地将百度网盘的下载地址导出为 aria2/aria2-rpc 链接的工具。 其原本是作为 Chrome 扩展而存在，但是因为某些原因而被 Google 从 Chrome Web Store 下架。所以需要自己依据 BaiduExporter 源码安装其 Chrome 扩展。 安装 将 BaiduExporter 扩展源码下载或克隆下来； 启动 Chrome, 打开 chrome://extensions 扩展页面，勾选 开发者模式，点击 加载已解压的扩展程序，导航至 /BaiduExporter/chrome/ 并选中 chrome 目录，点击确认。 上图便是 BaiduExporter(网盘助手) 加载成功的截图。 虽然上述方式安装 BaiduExporter 扩展是OK的，但是，每次重新打开 Chrome 后就会弹出警示对话框，内容如下： 停用开发者模式运行扩展的提示 为解决上述问题，可以参考 打包导入BaiduExporter到Chrome教程 使用BaiduExporter Chrome 插件安装并启用完毕后，我们在访问自己的百度网盘网页时会在上方多出 导出下载 的按钮（如下图所示），勾选需要下载的资源，点击 导出下载 -&gt; ARIA2 RPC 便可导出至 aria2 下载，当然，前提是你已经开启 aria2 并启用了 RPC 模式。百度网盘页面 至于如何查看和管理下载进度，则可参考 aria2 下载管理。 相关链接或参考 BaiduExporter 使用Aria2下载百度网盘和115的资源]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[下载工具aria2 - 配置和使用]]></title>
      <url>post%2F141514420%2F</url>
      <content type="text"><![CDATA[简介aria2 是一款支持跨平台、多源、多协议的轻量级的命令行式的下载工具。它支持 HTTP/HTTPS、FTP、SFTP、磁力链接以及 Medialink等多种下载方式。不仅如此，更值得称赞的是，aira2 还是一款开源免费的软件。 安装最新的 aria2 release版本下载地址 aria2 release。 注意：之前网上好多关于 aria2 的下载地址是在 sourceforge 上的，但是由于 aria2 已开源迁移至 GitHub，所以下载最新版本的还是需要找准地址。 aria2下载列表 通过上方官方给的下载列表可以看出，aria2支持的平台有 Windows、MacOS、Linux、Android。注意，本文只介绍 Windows 平台下的，其他平台烦请另行查阅资料。 Windows 平台只需下载对应位数的zip压缩包，解压缩即可。 解压后的目录结构如下，其体积是相当小的： aria2-1.32/ ├── aria2c.exe ├── AUTHORS ├── ChangeLog ├── COPYING ├── LICENSE.OpenSSL ├── NEWS ├── README.html └── README.mingw 配置接下来，在 aria2 目录下新建如下几个空文件来进行后续配置： aria2.conf - 配置文件 aria2.log - 日志文件 aria2.session - 下载记录文件 HideRun.vbs - 隐藏cmd窗口运行aria2所需要的文件 之后 aria2 的目录结构如下： aria2-1.32/ ├── aria2.conf ├── aria2.log ├── aria2.session ├── aria2c.exe ├── AUTHORS ├── ChangeLog ├── COPYING ├── HideRun.vbs ├── LICENSE.OpenSSL ├── NEWS ├── README.html └── README.mingw 配置 aria2.confaria2.conf 文件用于配置 aria2 运行时的相关参数，相关配置项可以参考 aria2配置示例。 aria2 有两种下载模式，一种是命令行下载模式，一种是 RPC Server 模式，前者不方便故不建议使用； RPC Server 模式就是把 aria2 当作服务端，通过 RPC 接口接受客户端的下载请求，因为是 Server 模式，aria2 下载完成并不会退出，会一直等待后续的下载请求。所以，需要在 aria2.conf 配置文件中将与 RPC 相关的配置项打开(enable)。 这里我贴出自己的配置文件： ## '#'开头为注释内容, 选项都有相应的注释说明, 根据需要修改 ## ## 被注释的选项填写的是默认值, 建议在需要修改时再取消注释 ## ## 文件保存相关 ## # 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置 dir=E:\Downloads # 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M #disk-cache=32M # 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc # 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc # falloc和trunc则需要文件系统和内核支持 # NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项 file-allocation=falloc # 断点续传 continue=true ## 下载连接相关 ## # 最大同时下载任务数, 运行时可修改, 默认:5 max-concurrent-downloads=4 # 同一服务器连接数, 添加时可指定, 默认:1 max-connection-per-server=5 # 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M # 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载 min-split-size=10M # 单个任务最大线程数, 添加时可指定, 默认:5 split=5 # 整体下载速度限制, 运行时可修改, 默认:0 #max-overall-download-limit=0 # 单个任务下载速度限制, 默认:0 #max-download-limit=0 # 整体上传速度限制, 运行时可修改, 默认:0 #max-overall-upload-limit=0 # 单个任务上传速度限制, 默认:0 #max-upload-limit=0 # 禁用IPv6, 默认:false disable-ipv6=true ## 进度保存相关 ## # 从会话文件中读取下载任务 input-file=D:\aria2\aria2-1.32\aria2.session # 在Aria2退出时保存`错误/未完成`的下载任务到会话文件 save-session=D:\aria2\aria2-1.32\aria2.session # 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0 save-session-interval=60 # log日志路径 默认没有log # log=D:\aria2\aria2-1.32\aria2.log ## RPC相关设置 ## # 启用RPC, 默认:false enable-rpc=true # 允许所有来源, 默认:false rpc-allow-origin-all=true # 允许非外部访问, 默认:false rpc-listen-all=true # 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同 #event-poll=select # RPC监听端口, 端口被占用时可以修改, 默认:6800 #rpc-listen-port=6800 # 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项 #rpc-secret=&lt;TOKEN> # 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项 #rpc-user=&lt;USER> # 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项 #rpc-passwd=&lt;PASSWD> ## BT/PT下载相关 ## # 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true #follow-torrent=true # BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999 listen-port=51413 # 单个种子最大连接数, 默认:55 #bt-max-peers=55 # 打开DHT功能, PT需要禁用, 默认:true enable-dht=false # 打开IPv6 DHT功能, PT需要禁用 #enable-dht6=false # DHT网络监听端口, 默认:6881-6999 #dht-listen-port=6881-6999 # 本地节点查找, PT需要禁用, 默认:false #bt-enable-lpd=false # 种子交换, PT需要禁用, 默认:true enable-peer-exchange=false # 每个种子限速, 对少种的PT很有用, 默认:50K #bt-request-peer-speed-limit=50K # 客户端伪装, PT需要 peer-id-prefix=-TR2770- user-agent=Transmission/2.77 # 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0 seed-ratio=0 # 强制保存会话, 即使任务已经完成, 默认:false # 较新的版本开启后会在任务完成后依然保留.aria2文件 #force-save=false # BT校验相关, 默认:true #bt-hash-check-seed=true # 继续之前的BT任务时, 无需再次校验, 默认:false bt-seed-unverified=true # 保存磁力链接元数据为种子文件(.torrent文件), 默认:false bt-save-metadata=true 更多更详尽的配置项请参考官方 manual 配置 HideRun.vbsHideRun.vbs 文件的目的是就是让 aria2 隐藏 cmd 窗口运行。往 HideRun.vbs 写入如下脚本内容： CreateObject("WScript.Shell").Run "aria2c.exe --conf-path=aria2.conf -D",0 通过 HideRun.vbs 内容我们可以知道， aria2c.exe 每次在运行时是要去加载 aria2.conf 配置文件的，所以需要双击 HideRun.vbs 来启动aria2，而不是双击 aria2c.exe。 下载管理aria2 是基于命令行的下载工具，本身是没有用于管理的界面的，一切都基于命令行，但有基于网页的管理界面（webui）： aria2官网提及的 webui-aria2 项目 Binux大大的 YAAW 在这里我推荐 aria2 官网提及的 webui-aria2 作为Web管理界面，因为就目前看来它更好用 XD。 webui-aria2 的使用有以下方式使用 webui-aria2： 直接访问 在线的 webui-aria2 页面 来进行 aria2 的下载管理，一般来说选用这个就行； 通过将 webui-aria2 这个repo下载下来，然后打开 index.html 来进行 aria2 的下载管理； 在使用 webui-aria2 进行 aria2 的下载管理前，可能需要在web管理页面进行相关配置：设置 -&gt; 连接设置 -&gt; Aria2 RPC 主机和端口，需要根据提示完成相应的配置（具体需要填什么内容取决于之前的 aria2.conf的配置）。 在这里贴上我的 webui-aria2 的连接设置，因为令牌等都未启用，所以都是空：webui-aria2 在 webui-aria2 管理界面上，可以点击 添加 来添加链接、种子或 Medialink，来新增 aria2 的下载任务。更多其他操作（包括暂定、删除、重新下载等），在web界面上都有相应的入口，很简单，这里就不再详细介绍了。 最后附一张 webui-aria2 管理界面截图： webui-aria2 管理界面 进阶 结合 BaiduExporter(网盘助手) 越过某(bai)度网盘下载速度限制，从而高速下载网盘文件，详情请戳 BaiduExporter 介绍与使用 相关链接或参考 用火狐我喜欢用aria2下载，写写windows下教程吧 Aria2 &amp; YAAW 使用说明 aria2 webui-aria2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[炉石开包引发的血案（雾]]></title>
      <url>post%2F1310087385%2F</url>
      <content type="text"><![CDATA[昨天星苏直播开炉石卡包，并发起对应的竞猜，竞猜内容大致是： 50包卡包中，出现橙卡数目的奇偶性。 然后就有弹幕说：“哎呀，猜单双多没意思呀，可能性一样，赔率不会悬殊，没意思。” 那么，奇偶出现的可能性是一样吗？ 模型建立暴雪爸爸前段时间发布了关于《炉石传说》卡牌包抽取概率公告，其中有两条关键信息： 平均20个炉石卡牌包，可获得一张传说品质卡牌。此外，需要说明的是：随着卡牌包抽取数量的增多，玩家实际获得高品质卡牌的概率也将同步提高。 通过官方的说明，加上对开包已有的认知，可以将 卡牌包抽取&nbsp; 行为近似抽象为 伯努利试验(或 重复独立试验)。由于卡牌包抽取数量的增大，获得传说（橙卡）的概率也会相应提高，也就是前面的试验结果会对后续的试验结果产生一定影响，故而这里的 伯努利试验&nbsp; 模型并不十分精确。但在开包数目相对较小的情况下，我们还是可以使用 伯努利试验&nbsp; 进行近似建模抽象的。毕竟，官方没有透露任何关于卡牌包出传说概率模型的消息，也只能用 伯努利试验&nbsp; 对其进行简单抽象了。 另外，这里也可以得知，单包出橙卡的概率为 1/20 即 0.05。 在 n 次重复独立试验中，用 $\xi$ 表示事件A发生的次数，用 p 表示事件A在单次试验中发生的概率，则事件A发生 k 次的概率 P 为：$$P(\xi = k) = C_n^k \cdot p^k \cdot (1-p)^{n-k}$$建立了数学模型，可以方便解决问题了。~\(≧▽≦)/~ 编码实现/** * 重复独立试验 * @author Tianma * */ public class BernoulliExperiment { /** * 重复独立试验(伯努利试验)，单次出现概率为p(0&lt;p&lt;1)的情况下，重复独立试验n次，返回命中k次的概率 * &lt;p> * P(k,n,p) = C(n,k)*(p^k)*((1-p)^(n-k)),其中(k = 0,1,2,...,n) */ public double probability(int n, int k, double p) { return combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k); } /** * 计算C(n,m)组合数的值 */ public long combination(int n, int m) { long[] arr = new long[m + 1]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = 1; } for (int i = 1; i &lt;= n - m; i++) { for (int j = 1; j &lt;= m; j++) { arr[j] += arr[j - 1]; } } return arr[m]; } public static void main(String[] args) { BernoulliExperiment bernoulli = new BernoulliExperiment(); double p = 0.05; int n = 50; double oddProbability = 0, evenProbability = 0; for (int i = 0; i &lt;= n; i++) { double probability = bernoulli.probability(n, i, p); if (i % 2 == 0) { evenProbability += probability; } else { oddProbability += probability; } } System.out.println("Odd probability : " + oddProbability); System.out.println("Even probability : " + evenProbability); System.out.println("Odd + Even : " + (evenProbability + oddProbability)); } } 上述代码中涉及到组合数的计算，详情可以看之前的博客 组合数的计算。 运行结果如下： Odd probability : 0.497423112396339 Even probability : 0.502576887603659 Odd + Even : 0.999999999999998 从运行结果我们可以看出，50个卡包开出橙卡数目的奇偶性的概率大致一样，但还是有略微差别。如果对 n 和 p 取不同的值，得到的奇偶性概率差又会不一致。也就是说，需要经过一定的计算才能判断最终结论走向。 最后的最后，想说一句，芝士就是力量（大雾） ╰(￣▽￣)╮]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[组合数的计算]]></title>
      <url>post%2F285069090%2F</url>
      <content type="text"><![CDATA[组合数的计算虽然在一般的编程领域中不太能用到，但是在数学相关领域及ACM中还是有其用武之地的。那么，如何在程序中计算组合数呢？ 累乘计算我们知道：$$C_{n}^{m}=\frac {A_{n}^{m}}{m!}=\frac {n!}{m!\left(n-m\right)!} , (0\leq m\leq n) \tag{1}$$$$C_{n}^{m}=\frac {n\cdot(n-1)\ldots(n-m+1)}{m!}, (0\leq m\leq n) \tag{2}$$ 通过公式(1)和公式(2)，可以简单的依据公式来进行组合数的计算。但因为公式中涉及到阶乘运算（准确说是连乘运算），故而会存在数据溢出的问题，因而不推荐。 累加计算为了避免直接计算阶乘，可以对公式（1）两边取对数：$$\ln(C_{n}^{m}) = \ln(n!) - \ln(m!) - \ln((n-m)!) = \sum_{i=1}^{n}\ln(i) - \sum_{i=1}^{m}\ln(i) - \sum_{i=1}^{n-m}\ln(i) \tag{3}$$又因为：$$\sum_{i=1}^{n}\ln(i) = \sum_{i=1}^{m}\ln(i) + \sum_{i=m+1}^{n}\ln(i) \tag{4}$$将（4）代入等式右边可得：$$\ln(C_{n}^{m}) = \sum_{i=m+1}^{n}\ln(i) - \sum_{i=1}^{n-m}\ln(i) \tag{5}$$ 观察式（5）右侧，其累加的次数为 $[n-(m+1)+1]+[(n-m)-1+1]=2×(n-m)$次，在n的值一定的情况下，m越小，累加次数越多。而我们知道：$C_{n}^{m}=C_{n}^{n-m}$，当 $m&lt;n/2$ 时，直接计算 $C_n^m$ 则累加次数较多，此时，我们可以通过计算 $C_{n}^{n-m}$ 来间接得到 $C_{n}^{m}$ 的值，从而减少累加次数，提高运算效率。 最后，我们可以通过两边取e的指数幂，最终计算出组合数 $C_{n}^{m}$ 的值。 Java实现： /** * 计算C(n,m)组合数的值 */ public long combination1(int n, int m) { double result = 0; if (m > n) { return 0; } if (m &lt; n / 2) { m = n - m; } for (int i = m + 1; i &lt;= n; i++) { result += Math.log(i); } for (int i = 1; i &lt;= n - m; i++) { result -= Math.log(i); } return Math.round(Math.exp(result)); } 上述方案相较于之前的累乘计算方案有明显的优化提高。值得注意的是，虽然自然常数 e 是常数，但因其为无限不循环小数，在Java代码中，实际计算时 e 取的是其近似值，所以上述代码在 n 的值较大时，会出现计算结果的偏差。n 的值较小的情况下，其准确性还是可以保障的。 精确计算组合数公式中，还有一个恒等式：$$C_{n}^{m} = C_{n-1}^{m} + C_{n-1}^{m-1}, (1&lt;m&lt;n) \tag{6}$$ 又因为：$C_{n}^{0} = C_{n}^{n} = 1$, 所以最终可以得到：$$C_{n}^{m} =\begin{cases} 1 &amp; (m = 0)\\ C_{n-1}^{m} + C_{n-1}^{m-1} &amp; (1\leq m&lt;n)\\ 1 &amp; (m = n)\end{cases}\tag{7}$$ 看到公式（7）我们很容易想到可以用递归去计算 $C_{n}^{m}$ 的值，这也不失为一种方案，然而因为在递归过程中会出现不少重复值（存在重复计算），且递归过程较为浪费栈内存，在这里就不详细介绍该方案。 我们以 $C_{5}^{3}$ 为例，建立如下矩阵：$$\begin{matrix}C_0^0 &amp; C_1^1 &amp; C_2^2 &amp; C_3^3 \\C_1^0 &amp; C_2^1 &amp; C_3^2 &amp; C_4^3 \\C_2^0 &amp; C_3^1 &amp; C_4^1 &amp; C_5^3\end{matrix}$$在这上述矩阵中，依据公式（6），我们可以看出，每个位置上的组合数的值都等于其左边和其上边的组合数之和。也就是说，只要知道第一行和第一列各组合数的值，则可以以加法的形式计算出整个矩阵其他位置的组合值。而根据公式（7），我们知道，第一行和第一列各组合数的值均为1。 我们归纳出 $C_n^m$ 对应的矩阵：$$\begin{matrix}C_0^0 &amp; C_1^1 &amp; C_2^2 &amp; \cdots &amp; C_m^m \\C_1^0 &amp; C_2^1 &amp; C_3^2 &amp; \cdots &amp; C_{m+1}^m \\C_2^0 &amp; C_3^1 &amp; C_4^2 &amp; \cdots &amp; C_{m+2}^m \\\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\C_{n-m}^0 &amp; C_{n-m+1}^1 &amp; C_{n-m+2}^2 &amp; \cdots &amp; C_n^m\end{matrix}$$第1行和第1列的值均为1，可以根据第1行计算出第2行各位置的值，再可由第2行计算出第3行各位置的值，如此循环，便可计算出 $C_n^m$ 的值。 Java实现 /** * 计算C(n,m)组合数的值 */ public long combination2(int n, int m) { long[] arr = new long[m + 1]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = 1; } for (int i = 1; i &lt;= n - m; i++) { for (int j = 1; j &lt;= m; j++) { arr[j] += arr[j - 1]; } } return arr[m]; } 上述方法，只开辟了 m+1 个长度的长整型数组，空间占有率较小，空间复杂度小。因为有两层循环，其平均时间效率不如累加的计算方案，但它是精准计算，计算出的组合数值没有偏差。综合来看，较为推荐最后这种方案来计算组合数值。 参考组合-维基百科组合数-百度百科大数量级组合数的快速计算方法基础算法学习-求组合数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[熊猫tv竞猜引发的组合问题]]></title>
      <url>post%2F2324484737%2F</url>
      <content type="text"><![CDATA[背景今天晚上在看秋日播炉石的时候，发现最近熊猫tv加入了竞猜活动，可以通过该活动来获取竹子（熊猫tv中货币之一），嘛~ 这就是一娱乐活动嘛。 这次秋日主要竞猜的内容有两个： 远古雕文发现的三张法术牌费用总和是否小于某一值 秘法宝典开出来的三张法术牌费用总和是否小于某一值 看到这个我就心血来潮了，这并不是以往的只能靠运气来赢得奖励的竞猜活动，而是可以通过数学分析进行量化的，因为其实这就是排列组合中的组合问题嘛： 当前版本标准模式下，法师的法术牌一共有31张（除去任务橙 “打开时空之门”） 远古雕文发现的三张法术不可重复，也就是不可重复取的组合问题：从n个元素中不可重复抽m次 秘法宝典开出的三张法术牌可重复，也就是可重复取的组合问题：从m个元素中可重复抽m次 上述问题可以用数学手段去解决，亦可以用编程去解决，因为懒得去分析各种可能的有效情况，所以直接用代码去解决了… 代码解决package tianma.exercise; public class Combination { // 总组合数 private int globalCounter = 0; // 合法组合数 private int validCounter = 0; /** * 从n个数据中选取m个的组合（不可重复取）, 小于临界值的有效 */ public void combineUnrepeatable(int[] input, int m, int threshold) { combine(input, m, threshold, false); } /** * 从n个数中选取m次的组合（可重复取），小于临界值的有效 */ public void combineRepeatable(int[] input, int m, int threshold) { combine(input, m, threshold, true); } private void combine(int[] input, int m, int threshold, boolean repeatable) { if (input == null || input.length == 0 || m &lt;= 0 || m > input.length) { throw new RuntimeException("参数错误"); } int[] out = new int[m]; innerCombine(input, m, 0, out, 0, threshold, repeatable); float ratio = 1.0f * validCounter / globalCounter; System.out.println("总次数 = " + globalCounter + ", 小于 " + threshold + "的命中次数 = " + validCounter + ", 命中率 = " + ratio); globalCounter = validCounter = 0; } private void innerCombine(int[] input, int m, int beginIdx, int[] out, int index, int threshold, boolean repeatable) { if (m == 0) { int total = 0; for (int i = 0; i &lt; index; i++) { System.out.print(out[i] + " "); total += out[i]; } if (total &lt; threshold) { validCounter++; System.out.print("*"); } globalCounter++; System.out.println(); return; } for (int i = repeatable ? 0 : beginIdx; i &lt; input.length; i++) { out[index] = input[i]; innerCombine(input, m - 1, i + 1, out, index + 1, threshold, repeatable); } } public static void main(String[] args) { // 法师31张法术法力值数组 int[] in = { 0, 0, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 6, 6, 7, 7, 7, 10 }; int m = 3; int threshold = 11; boolean repeatable = true; Combination combination = new Combination(); combination.combine(in, m, threshold, repeatable); } } 花絮在后续的竞猜中我发现一个有趣的现象：某次秘法宝典竞猜截图程序跑出的结果： 总次数 = 29791, 小于 11的命中次数 = 16193, 命中率 = 0.5435534 也就是说 “小于11” 的概率其实比 “大于10” 的概率要高，但是前者的”赔率”却比后者高。因为参加竞猜的大多数观众是凭直觉下注的，所以可以得出的结论是，有时候凭借直觉往往是错的，数学理论的支持才是王道，红红火火恍恍惚惚 ╰_╯]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 跳转至微博用户个人信息页面]]></title>
      <url>post%2F3914813049%2F</url>
      <content type="text"><![CDATA[最近需要去实现应用内跳转至微博的个人信息页面（用户个人主页），其本质就是打开并跳转至第三方App指定的页面。显然，我们可以通过调用 startActivity(intent) 来实现该功能，其关键就是 intent 中需要携带哪些信息。 反编译 AndroidManifest.xml将新浪微博的apk文件中的 AndroidManifest.xml 文件解压提取出来，然后使用 AXMLPrinter2.jar 对清单文件进行反编译： java -jar AXMLPrinter2.jar AndroidManifest.xml > weibo.xml 其中 weibo.xml 即反编译成功的清单文件。 获取微博个人页 Activity因为之前 weibo.xml 中的 Activity 过多，我们需要知道微博的用户个人信息页面对应的 Activity 全称。这里有两种方法： 使用辅助App来获取当前的 Activity ，例如 当前界面(当前Activity) ，具体用法这里就不介绍了。 使用 adb 命令获取当前 Activity： adb shell dumpsys activity activities | grep mFocusedActivity 当我们把新浪微博的个人信息页面切至前台时， adb 命令的结果为： mFocusedActivity: ActivityRecord{9063f6f u0 com.sina.weibo/.page.ProfileInfoActivity t1578} 也就是说，新浪微博的个人信息页对应的 Activity 为 com.sina.weibo.page.ProfileInfoActivity, 那我们看 weibo.xml 中与该 Activity 对应的 xml 节点： &lt;activity android:theme="@7F0B0011" android:name="com.sina.weibo.page.ProfileInfoActivity" android:exported="true" android:configChanges="0x000004A0" android:windowSoftInputMode="0x00000020"> &lt;intent-filter> &lt;action android:name="android.intent.action.VIEW">&lt;/action> &lt;category android:name="android.intent.category.DEFAULT">&lt;/category> &lt;category android:name="android.intent.category.BROWSABLE">&lt;/category> &lt;data android:scheme="sinaweibo" android:host="userinfo">&lt;/data> &lt;/intent-filter> &lt;intent-filter> &lt;action android:name="android.intent.action.VIEW">&lt;/action> &lt;category android:name="android.intent.category.DEFAULT">&lt;/category> &lt;category android:name="android.intent.category.BROWSABLE">&lt;/category> &lt;data android:scheme="http" android:host="weibo.cn" android:path="/qr/userinfo">&lt;/data> &lt;/intent-filter> &lt;intent-filter> &lt;action android:name="android.intent.action.VIEW">&lt;/action> &lt;category android:name="android.intent.category.DEFAULT">&lt;/category> &lt;data android:mimeType="vnd.android.cursor.item/vnd.com.sina.weibo.profile">&lt;/data> &lt;/intent-filter> &lt;/activity> 分析上面的 xml 节点中，可以看到 android:exported=&quot;true&quot;，也就是说 ProfileInfoActivity 可以被外部程序调用打开。有三个 intent-filter 节点，其中第三个 intent-filter 与 ContentProvider 有关，可以忽略第三个只考虑前两个。第一个 intent-filter 接受的 data 格式为 sinaweibo:userinfo， 第二个 intent-filter 接受的 data 格式为 http://weibo.cn/qr/userinfo。 我们通过 data 节点的数据可以判断除，第二个除了可以被新浪微博响应，也可以被浏览器之类的应用响应，但第一个只能被新浪微博响应，所以在使用第一个之前，需要判断新浪微博是否已经安装，否则会崩溃。 实现通过查阅相关文档，ProfileInfoActivity 可以接受的参数为 uid=xxx, 也就是 sinaweibo://userinfo?uid=xxx 和 http://weibo.cn/qr/userinfo?uid=xxx，所以最终代码实现： // 跳转至微博个人页 public void jumpToWeiboProfileInfo(Context context, String uid) { Intent intent = new Intent(Intent.ACTION_VIEW); intent.addCategory(Intent.CATEGORY_DEFAULT); intent.addCategory(Intent.CATEGORY_BROWSABLE); boolean weiboInstalled = PackageUtils.isSinaWeiboInstalled(context); if (weiboInstalled) { intent.setData(Uri.parse("sinaweibo://userinfo?uid=" + uid)); } else { intent.setData(Uri.parse("http://weibo.cn/qr/userinfo?uid=" + uid)); } context.startActivity(intent); } // PackageUtils.java public class PackageUtils { private PackageUtils(){} // 新浪微博是否安装 public static boolean isSinaWeiboInstalled(Context context) { return isPackageInstalled(context, "com.sina.weibo"); } // 包名对应的App是否安装 public static boolean isPackageInstalled(Context context, String packageName) { PackageManager packageManager = context.getPackageManager(); if (packageManager == null) return false; List&lt;PackageInfo> packageInfoList = packageManager.getInstalledPackages(0); for(PackageInfo info : packageInfoList) { if (info.packageName.equals(packageName)) return true; } return false; } } 参考调用新浪微博显示用户信息]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RecyclerView添加分割线]]></title>
      <url>post%2F1138009507%2F</url>
      <content type="text"><![CDATA[RecyclerView 并没有 divider 属性，但是我们可以通过 RecyclerView 的 addItemDecoration() 来添加分割线，该方法参数为 RecyclerView.ItemDecoration。 介绍当 RecyclerView 添加 ItemDecoration 后，RecyclerView 在绘制每个 item 的时候，会去绘制 decorator，也就是会调用 ItemDecoration 的 onDraw() 和 onDrawOver() 方法。 RecyclerView.ItemDecoration 是抽象类，主要提供三个方法： onDraw(Canvas c, RecyclerView parent, State state)： 在绘制item（drawChild） 前调用 onDrawOver(Canvas c, RecyclerView parent, State state): 在绘制item（drawChild） 后调用 getItemOffsets(Rect outRect, View view, RecyclerView parent, State state)：outRect设置 item 的偏移量，用于绘制 decorator（也就是divider） 关于 getItemOffsets 函数：RecyclerView 添加分割线，实际上就是 RecyclerView 的 item 之间添加了用作分割线的View，自然而然后续的 item 就会有偏移量，所以用 getItemOffsets 中的 outRect 来保存 item 的偏移量，从而便于绘制 decorator。 实现实际上在当前版本的 RecyclerView (25.3.1) 中已经有 ItemDecoration 关于分割线的默认实现类 DividerItemDecoration: package android.support.v7.widget; import android.annotation.SuppressLint; import android.content.Context; import android.content.res.TypedArray; import android.graphics.Canvas; import android.graphics.Rect; import android.graphics.drawable.Drawable; import android.support.annotation.NonNull; import android.support.v4.view.ViewCompat; import android.view.View; import android.widget.LinearLayout; public class DividerItemDecoration extends RecyclerView.ItemDecoration { public static final int HORIZONTAL = LinearLayout.HORIZONTAL; public static final int VERTICAL = LinearLayout.VERTICAL; // 如果不设置，则默认的分割线为 android.R.attr.listDivider 指定的 drawable private static final int[] ATTRS = new int[]{ android.R.attr.listDivider }; private Drawable mDivider; /** * Current orientation. Either {@link #HORIZONTAL} or {@link #VERTICAL}. */ private int mOrientation; private final Rect mBounds = new Rect(); /** * Creates a divider {@link RecyclerView.ItemDecoration} that can be used with a * {@link LinearLayoutManager}. * * @param context Current context, it will be used to access resources. * @param orientation Divider orientation. Should be {@link #HORIZONTAL} or {@link #VERTICAL}. */ public DividerItemDecoration(Context context, int orientation) { final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); a.recycle(); setOrientation(orientation); } /** * Sets the orientation for this divider. This should be called if * {@link RecyclerView.LayoutManager} changes orientation. * * @param orientation {@link #HORIZONTAL} or {@link #VERTICAL} */ public void setOrientation(int orientation) { if (orientation != HORIZONTAL &amp;&amp; orientation != VERTICAL) { throw new IllegalArgumentException( "Invalid orientation. It should be either HORIZONTAL or VERTICAL"); } mOrientation = orientation; } /** * Sets the {@link Drawable} for this divider. * * @param drawable Drawable that should be used as a divider. */ public void setDrawable(@NonNull Drawable drawable) { if (drawable == null) { throw new IllegalArgumentException("Drawable cannot be null."); } mDivider = drawable; } @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) { if (parent.getLayoutManager() == null) { return; } if (mOrientation == VERTICAL) { drawVertical(c, parent); } else { drawHorizontal(c, parent); } } // 绘制 RecyclerView 为垂直布局时的分割线，此时分割线为水平分割线 @SuppressLint("NewApi") private void drawVertical(Canvas canvas, RecyclerView parent) { canvas.save(); final int left; final int right; // 需要考虑clipToPadding的boolean值 if (parent.getClipToPadding()) { left = parent.getPaddingLeft(); right = parent.getWidth() - parent.getPaddingRight(); canvas.clipRect(left, parent.getPaddingTop(), right, parent.getHeight() - parent.getPaddingBottom()); } else { left = 0; right = parent.getWidth(); } final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); parent.getDecoratedBoundsWithMargins(child, mBounds); final int bottom = mBounds.bottom + Math.round(ViewCompat.getTranslationY(child)); final int top = bottom - mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(canvas); } canvas.restore(); } // 绘制 RecyclerView 为水平布局时的分割线，此时分割线为垂直分割线 @SuppressLint("NewApi") private void drawHorizontal(Canvas canvas, RecyclerView parent) { canvas.save(); final int top; final int bottom; // 需要考虑clipToPadding的boolean值 if (parent.getClipToPadding()) { top = parent.getPaddingTop(); bottom = parent.getHeight() - parent.getPaddingBottom(); canvas.clipRect(parent.getPaddingLeft(), top, parent.getWidth() - parent.getPaddingRight(), bottom); } else { top = 0; bottom = parent.getHeight(); } final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); parent.getLayoutManager().getDecoratedBoundsWithMargins(child, mBounds); final int right = mBounds.right + Math.round(ViewCompat.getTranslationX(child)); final int left = right - mDivider.getIntrinsicWidth(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(canvas); } canvas.restore(); } @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) { if (mOrientation == VERTICAL) { // 垂直方向的RecyclerView, item 的 bottom 偏移量 = 分割线高度 outRect.set(0, 0, 0, mDivider.getIntrinsicHeight()); } else { // 水平方向的RecyclerView， item 的 right 偏移量 = 分割线宽度 outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0); } } } 在代码中添加： recyclerView.addItemDecoration(new DividerItemDecoration(recyclerView.getContext(), mLayoutManager.getOrientation())); 就有了分割线。 默认的分割线效果是系统自带的 listDivider 的效果，我们也可以在主题配置文件中自定义全局的分割线，或者调用 setDivider 为每个 RecyclerView 设置单独的分割线。 网络流行代码存在的问题目前好多博客中关于 DividerItemDecoration 中 drawVertical() 和 drawHorizontal() 方法与官方的方法其实是有出入的： public void drawVertical(Canvas c, RecyclerView parent) { final int left = parent.getPaddingLeft(); final int right = parent.getWidth() - parent.getPaddingRight(); // 网上的方法最主要的问题是没有考虑 clipToPadding 这个参数，所以说这里缺少相应代码片段 final int childCount = parent.getChildCount(); // 下面这块没什么问题，和官方方案殊途同归 // 官方的getDecoratedBoundsWithMargins实际上也是通过 LayoutParams 来获取分割线边界的 for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int top = child.getBottom() + params.bottomMargin; final int bottom = top + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); } } public void drawHorizontal(Canvas c, RecyclerView parent) { final int top = parent.getPaddingTop(); final int bottom = parent.getHeight() - parent.getPaddingBottom(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int left = child.getRight() + params.rightMargin; final int right = left + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); } } 注释中说的比较明确了，网上好多方法主要的问题在于 没有考虑 clipToPadding 属性值 。 clipToPadding 表示控件的绘制区域是否在 padding 区域外面，其默认值为 true。比如，垂直方向的 RecyclerView，当 clipToPadding=false 时，其初始绘制区域与 padding 值有关，但向上滑动时，RecylerView 的 item 会滑到 padding 区域里面。 下面用示意图来进行解释，RecyclerView 的 paddingTop = 40dp, clipToPadding = false, 下图中白色区域为 paddingTop 区域：初始状态下向上滑动 小结总的来说，目前添加分割线只需要使用 recyclerview-v7 包下的 DividerItemDecoration 类即可，分割线可以通过 setDivider 来个性化指定，也可以通过配置主题中的 android:listDivider 来全局指定。 参考Android RecyclerView 使用完全解析 体验艺术般的控件RecyclerView系列之二：添加分隔线android:clipToPadding和android:clipChildren]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在Android Studio中使用Lambda表达式]]></title>
      <url>post%2F837474051%2F</url>
      <content type="text"><![CDATA[Lambda 表达式是 Java 8 的新特性之一，本文主要介绍如何让 Android 项目集成 Labmda 表达式功能。 已知的集成方式有两种： 使用官方的 Jack 工具链 启用Java 8 功能 使用第三方库 Retrolambda 启用 Java 8功能 在本人使用过程中发现，通过 Jack 集成的方式，存在一些问题（不仅仅是官方声明的问题），所以在这里 推荐使用 Retrolambda 来集成 Lambda 功能。 2017-06-05 更新： 通过在不同的SDK版本上测试发现，Android M (api 23)以下版本中，不论是 Jack 还是 Retrolambda 的集成方式均会偶现 NoClassDefFoundError，并都没有成型的解决方案，所以以下诸君看看便可，不太能付诸实际项目中~ :( 官方Jack集成在模块级别的 build.gradle 中配置： android { ... defaultConfig { ... jackOptions { // 开启 Jack enabled true } } compileOptions { // 使用 Java 8 进行编译 sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } } 当然你首先得有 JDK 8 的开发环境。 第三方Retrolambda集成因为 Android Studio 使用 Gradle 作为构建工具，所以我们需要在集成 gradle-retrolambda Gradle 插件： 下载安装 JDK 8 在项目级别（项目根目录）的 build.gradle 中加入： buildscript { repositories { ... mavenCentral() // 加入 mavenCentral } dependencies { ... classpath 'me.tatarka:gradle-retrolambda:3.6.1' // 将retrolambda加入classpath } } allProjects { repositories { ... mavenCentral() // 加入 mavenCentral } } 在模块级别的 build.gradle 中加入： apply plugin: 'com.android.application' apply plugin: 'me.tatarka.retrolambda' // 引入 retrolambda 插件 android { ... compileOptions { // 使用 Java 8 进行编译 sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } } 在混淆文件中加入 -dontwarn java.lang.invoke.* -dontwarn **$$Lambda$* 之后就可以愉快的使用 Lambda 表达式啦~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FloatingActionButton的滚动隐藏和显示]]></title>
      <url>post%2F4166466910%2F</url>
      <content type="text"><![CDATA[概述FloatingActionButton（FAB）其实就是遵循了 Material Design 设计规范的并拥有特定动作行为的 ImageButton，基本用法参照 ImageButton 即可。 比如说，可以在 RecyclerView 向下滚动的时候隐藏 FAB, 向上滚动的时候显示 FAB: FAB演示动画 那么，如何实现上面 FAB 的滚动隐藏和显示动画呢？ 实现我们需要通过导入 Design Support Library 才能使用 FAB, 所以，需要在 build.gradle 中加入 compile &#39;com.android.support:design:X.X.X&#39; 其中 X 代表 Support Library 的版本。 一般来说，我们需要把 FAB 放在 CoordinatorLayout 布局中， CoordinatorLayout 可以看做为 FrameLayout，其特殊之处在于可以协调子控件的交互，其中就包括FAB的滚动隐藏和显示的动画。 那么，演示动画中的布局为： &lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"> &lt;android.support.v7.widget.RecyclerView android:id="@+id/recycler_view" android:layout_width="match_parent" android:layout_height="match_parent"/> &lt;android.support.design.widget.FloatingActionButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="bottom|end" android:layout_margin="16dp" android:src="@drawable/ic_add_white" app:layout_behavior="com.tianma.recyclerviewsample.fab.FabScrollBehavior" app:elevation="4dp"/> &lt;/android.support.design.widget.CoordinatorLayout> app:elevation 属性表示 FloatingActionButton 悬浮的高度，高度越大，投影范围越大，投影效果越淡；高度越小，投影范围越小，投影效果越明显。 app:layout_behavior 属性表示 FloatingActionButton 所实现的 CoordinatorLayout Behavior, 这个属性指定的 Behavior 用于定义 FloatingActionButton 与在同一个 CoordinatorLayout 布局下的其他控件的交互方式。如果不指定自定义的 Behavior，那么FloatingActionButton 默认的 Behavior 是为 Snackbar 留出空间，详见 演示视频 显然， FAB 默认的 Behavior 不能满足我们的需要，那么就需要自定义 Behavior 来实现 FAB 的滚动显示和隐藏动画： package com.tianma.recyclerviewsample.fab; import android.content.Context; import android.support.design.widget.CoordinatorLayout; import android.support.design.widget.FloatingActionButton; import android.support.v4.view.ViewCompat; import android.util.AttributeSet; import android.view.View; import android.view.animation.LinearInterpolator; public class FabScrollBehavior extends FloatingActionButton.Behavior { // 因为需要在布局xml中引用，所以必须实现该构造方法 public FabScrollBehavior(Context context, AttributeSet attrs) { super(context, attrs); } @Override public boolean onStartNestedScroll(final CoordinatorLayout coordinatorLayout, final FloatingActionButton child, final View directTargetChild, final View target, final int nestedScrollAxes) { // 确保滚动方向为垂直方向 return nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL; } @Override public void onNestedScroll(final CoordinatorLayout coordinatorLayout, final FloatingActionButton child, final View target, final int dxConsumed, final int dyConsumed, final int dxUnconsumed, final int dyUnconsumed) { super.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed); if (dyConsumed > 0) { // 向下滑动 animateOut(child); } else if (dyConsumed &lt; 0) { // 向上滑动 animateIn(child); } } // FAB移出屏幕动画（隐藏动画） private void animateOut(FloatingActionButton fab) { CoordinatorLayout.LayoutParams layoutParams = (CoordinatorLayout.LayoutParams) fab.getLayoutParams(); int bottomMargin = layoutParams.bottomMargin; fab.animate().translationY(fab.getHeight() + bottomMargin).setInterpolator(new LinearInterpolator()).start(); } // FAB移入屏幕动画（显示动画） private void animateIn(FloatingActionButton fab) { fab.animate().translationY(0).setInterpolator(new LinearInterpolator()).start(); } } 上述代码的关键就是找到 “隐藏动画” 和 “显示动画” 触发的时机，然后利用 “属性动画” 来实现对应的动画效果即可。 参考链接：Floating Action Buttons Guides]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[监听RecyclerView是否滑动到底部]]></title>
      <url>post%2F188185634%2F</url>
      <content type="text"><![CDATA[最近想动手实现 RecyclerView 的“自动加载更多”功能，即当 RecyclerView 滑动到底部时，执行加载更多操作。这里的关键在于，需要监听RecyclerView是否滑动到底部。 分析RecyclerView 有 addOnScrollListener(OnScrollListener) 方法，可以为 RecyclerView 添加滚动监听，其中 OnScrollListener 有两个回调函数： onScrollStateChanges(RecyclerView recyclerView, int newState): 在 RecyclerView 的滚动状态发生改变时回调 onScrolled(RecyclerView recyclerView, int dx, int dy): 在 RecyclerView 滚动时回调 在 OnScrollListener 回调中，可以获取RecyclerView的滚动状态，我们只需要通过继承 OnScrollListener 并复写上面的两个回调函数，便可以实现对 RecyclerView 滑动到底部的监听。 实现我们先定义一个回调接口 BottomListener 用以监听控件是否滚动到底部： public interface BottomListener { /** * 滑动到底部时回调 */ void onScrollToBottom(); } 然后，我们继承 RecyclerView.OnScrollListener 和实现 BottomListener ： import android.support.v7.widget.GridLayoutManager; import android.support.v7.widget.LinearLayoutManager; import android.support.v7.widget.RecyclerView; import android.support.v7.widget.StaggeredGridLayoutManager; /** * 实现了RecyclerView滚动到底部监听的OnScrollListener */ public class RecyclerViewScrollListener extends RecyclerView.OnScrollListener implements BottomListener { // 最后几个完全可见项的位置（瀑布式布局会出现这种情况） private int[] lastCompletelyVisiblePositions; // 最后一个完全可见项的位置 private int lastCompletelyVisibleItemPosition; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager(); // 找到最后一个完全可见项的位置 if (layoutManager instanceof StaggeredGridLayoutManager) { StaggeredGridLayoutManager manager = (StaggeredGridLayoutManager) layoutManager; if (lastCompletelyVisiblePositions == null) { lastCompletelyVisiblePositions = new int[manager.getSpanCount()]; } manager.findLastCompletelyVisibleItemPositions(lastCompletelyVisiblePositions); lastCompletelyVisibleItemPosition = getMaxPosition(lastCompletelyVisiblePositions); } else if (layoutManager instanceof GridLayoutManager) { lastCompletelyVisibleItemPosition = ((GridLayoutManager) layoutManager).findLastCompletelyVisibleItemPosition(); } else if (layoutManager instanceof LinearLayoutManager) { lastCompletelyVisibleItemPosition = ((LinearLayoutManager) layoutManager).findLastCompletelyVisibleItemPosition(); } else { throw new RuntimeException("Unsupported LayoutManager."); } } private int getMaxPosition(int[] positions) { int max = positions[0]; for (int i = 1; i &lt; positions.length; i++) { if (positions[i] > max) { max = positions[i]; } } return max; } @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) { RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager(); // 通过比对 最后完全可见项位置 和 总条目数，来判断是否滑动到底部 int visibleItemCount = layoutManager.getChildCount(); int totalItemCount = layoutManager.getItemCount(); if (newState == RecyclerView.SCROLL_STATE_IDLE) { if (visibleItemCount > 0 &amp;&amp; lastCompletelyVisibleItemPosition >= totalItemCount - 1) { onScrollToBottom(); } } } @Override public void onScrollToBottom() { } } 上述大体思路就是： 找到 “最后完全可见项的位置(lastCompletelyVisibleItemPosition)”，通过比较 lastCompletelyVisibleItemPosition 是否是 RecyclerView 最后一项，来判断是否滑动到底部。 在 RecyclerView 上应用加载更多： recyclerView.addOnScrollListener(new RecyclerViewScrollListener() { @Override public void onScrollToBottom() { // 加载更多 doLoadMore(); } }); // ... private void doLoadMore() { // TODO load more } 参考链接：通过重写OnScrollListener来监听RecyclerView是否滑动到底部 特别注意个人认为上面的参考链接中给出的方案是有待商榷的，原博主计算的是 “最后一个可见项的位置（lastVisibleItemPosition）”，而本文中计算的是 “最后一个完全可见项的位置(lastCompletelyVisibleItemPosition)” , 很明显 RecyclerView 列表中最后一个元素可见的时候，RecyclerView 并不一定滑动到最底部了。当然了，具体采取哪种方案，需要根据实际需求来确定。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java反射修改final修饰的属性值]]></title>
      <url>post%2F463108745%2F</url>
      <content type="text"><![CDATA[之前在阅读其他源码的时候，想要修改其中被 final 修饰符修饰的字段的值，可行吗？&nbsp; 解决方案使用Java反射，通过 Field#setAccessible(true) 将 private 修饰的字段变为 accessible；再将 final 修饰符去掉；最后再设置新值即可。当然，如果涉及到 Java 内联优化，则会失效。具体见示例代码： package com.tianma.sample; import java.lang.reflect.Field; import java.lang.reflect.Modifier; public class ChangeStaticFinalFieldSample { static void changeStaticFinal(Field field, Object newValue) throws Exception { field.setAccessible(true); // 如果field为private,则需要使用该方法使其可被访问 Field modifersField = Field.class.getDeclaredField("modifiers"); modifersField.setAccessible(true); // 把指定的field中的final修饰符去掉 modifersField.setInt(field, field.getModifiers() &amp; ~Modifier.FINAL); field.set(null, newValue); // 为指定field设置新值 } public static void main(String[] args) throws Exception { Sample.print(); Field canChangeField = Sample.class.getDeclaredField("CAN_CHANGE"); Field cannotChangeField = Sample.class.getDeclaredField("CANNOT_CHANGE"); changeStaticFinal(canChangeField, 2); changeStaticFinal(cannotChangeField, 3); Sample.print(); } } class Sample { private static final int CAN_CHANGE = new Integer(1); // 未内联优化 private static final int CANNOT_CHANGE = 1; // 内联优化 public static void print() { System.out.println("CAN_CHANGE = " + CAN_CHANGE); System.out.println("CANNOT_CHANGE = " + CANNOT_CHANGE); System.out.println("------------------------"); } } 打印结果为： CAN_CHANGE = 1 CANNOT_CHANGE = 1 ------------------------ CAN_CHANGE = 2 CANNOT_CHANGE = 1 ------------------------ 通过以上输出结果可以看出， CAN_CHANGE 和 CANNOT_CHANGE 字段同属于 final 修饰符修饰的常量字段，但是由于 CANNOT_CHANGE 常量在 Java 编译过程中使用了内联优化，其值在编译阶段就被编译为常量值 1，故而使用内联优化的 final 字段更改其值是无效的； 而 CAN_CHANGE 字段未被内联优化，故而能通过 Java 反射对其值进行修改。 参考Change private static final field using Java reflection]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[处理PopupWindow在Android 7.x中兼容性问题]]></title>
      <url>post%2F1634332613%2F</url>
      <content type="text"><![CDATA[问题描述PopupWindow 中的 showAsDropDown(View anchor) 用于在指定锚点View下方显示 PopupWindow，在Android 7.0 (api&lt;=23) 以前是没什么问题的，但是在Android 7.x系统上，会在某些情况下出现兼容问题： 如果指定 PopupWindow 的高度为 MATCH_PARENT，调用 showAsDropDown(View anchor) 时，在 7.0 之前，会在锚点 anchor 下边缘到屏幕底部之间显示 PopupWindow；而在 7.0、7.1 系统上的 PopupWindow 会占据整个屏幕（除状态栏之外）。 如果指定 PopupWindow 的高度为 WRAP_CONTENT, 调用 showAsDropDown(View anchor) 时，便不会出现兼容性的问题。 如果指定 PopupWindow 的高度为自定义的值height，调用 showAsDropDown(View anchor)时， 如果 height &gt; 锚点 anchor 下边缘与屏幕底部的距离， 则还是会出现7.0、7.1上显示异常的问题；否则，不会出现该问题。可以看出，情况1和2是情况3的特例。 解决方案如果出现上述分析中的兼容性问题，可以使用 showAtLocation() 方法替代 showAsDropDown() , 示例代码如下，详情可参见 PopupWindowCompatSample if (Build.VERSION.SDK_INT >= 24) { // Android 7.x中,PopupWindow高度为match_parent时,会出现兼容性问题,需要处理兼容性 int[] location = new int[2]; // 记录anchor在屏幕中的位置 anchor.getLocationOnScreen(location); int offsetY = location[1] + anchor.getHeight(); if (Build.VERSION.SDK_INT == 25) { // Android 7.1中，PopupWindow高度为 match_parent 时，会占据整个屏幕 // 故而需要在 Android 7.1上再做特殊处理 int screenHeight = ScreenUtils.getScreenHeight(context); // 获取屏幕高度 popupWindow.setHeight(screenHeight - offsetY); // 重新设置 PopupWindow 的高度 } popupWindow.showAtLocation(anchor, Gravity.NO_GRAVITY, 0, offsetY); } else { popupWindow.showAsDropDown(anchor); }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[消除Android 5.0 ~ 7.1.1原生系统中感叹号或叉号]]></title>
      <url>post%2F2812053051%2F</url>
      <content type="text"><![CDATA[前言在使用Android5.0以上的原生系统过程中，大家会遇到明明自己网络是OK的，但是会在状态栏的移动信号或 WiFi 图标旁显示感叹号（5.0 ~ 7.0.0）或叉号（7.1.1），并且会提示“已连接，但不能接入互联网”的情况… 原因从Android 5.0开始，系统连接网络或切换网络时，系统模块 NetworkMonitor 会向一特定网址发送数据请求，根据响应的结果从而判断网络的连通性。在原生Android系统中，这一特定网址是Google的网址，不翻墙访问不了，故而会出现感叹号或叉号。 解决方案既然知晓了原理，那么解决方案也很明确了： 完全关闭网络检查服务（不可取）： adb shell settings put global captive_portal_detection_enabled 0 缺点：&nbsp; 完全屏蔽该系统功能带来明显的问题，当你使用公共 Wi-Fi 这种需要使用 portal 验证的网络时，因为网络检查被关闭，系统在访问 portal 验证页面时无法返回正确的值，最终导致无法完成验证和上网。 替换检查网络的网址（可取）： 通过ADB命令，将验证服务的网址替换为国内正常可以访问的网址 Android 5.x ~ 6.x 解决方案adb shell &quot;settings put global captive_portal_server www.v2ex.com&quot; adb shell reboot Android 7.0.0 ~ 7.1.0 解决方案adb shell &quot;settings put global captive_portal_server captive.v2ex.co&quot; adb shell reboot Android 7.1.1 解决方案adb shell &quot;settings put global captive_portal_https_url https://captive.v2ex.co/generate_204&quot; adb shell reboot 源码问题解决了，问题产生的根本源头在哪呢，在源码里面 :) Android 5.x ~ 6.x private int isCaptivePortal() { if (!mIsCaptivePortalCheckEnabled) return 204; HttpURLConnection urlConnection = null; int httpResponseCode = 599; try { URL url = new URL("http", mServer, "/generate_204"); if (DBG) { log("Checking " + url.toString() + " on " + mNetworkAgentInfo.networkInfo.getExtraInfo()); } } // ... } 原来的 mServer 是 clients3.google.com，我们最终将其换为 www.v2ex.com. Android 7.0 ~ 7.1.0private static String getCaptivePortalServerUrl(Context context, boolean isHttps) { String server = Settings.Global.getString(context.getContentResolver(), Settings.Global.CAPTIVE_PORTAL_SERVER); if (server == null) server = DEFAULT_SERVER; return (isHttps ? "https" : "http") + "://" + server + "/generate_204"; } Android 7.0 ~ 7.1.0 新增了https的验证请求，所以我们把 server 的值改为支持https的 captive.v2ex.co. Android 7.1.1private static String getCaptivePortalServerHttpsUrl(Context context) { return getSetting(context, Settings.Global.CAPTIVE_PORTAL_HTTPS_URL, DEFAULT_HTTPS_URL); } DEFAULT_HTTPS_URL 的值由原来的 https://www.google.com/generate_204 替换为 https://captive.v2ex.co/generate_204. 源码链接：5.x ~ 6.x7.0.0 ~ 7.1.07.1.1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[监听Android设备网络变化]]></title>
      <url>post%2F7e2408ee%2F</url>
      <content type="text"><![CDATA[目标在实际开发中，我们不可避免地需要对请求错误进行处理，通常情况下，我们会这样去处理错误请求： 没有网络的情况下，提示用户网络连接不可用，引导用户打开网络或重新刷新等 有网络的情况下，则是客户端或服务端的错误，给用户相应的提示 如果针对第一种情况,我们需要在网络恢复的时候重新刷新数据或进行其他操作,又应该如何实现呢？以下就是我们的目标： 监听Android设备网络状态 在网络状态发生改变时,做出相应操作 在示例中，我们在网络状态发生变化时，显示当前网络变化的类型。 思路在Android系统在网络变化的情况下，会发出 action 为 ConnectivityManager.CONNECTIVITY_ACTION 的系统广播，我们只需要注册 BroadcastReceiver 去监听该广播即可监听设备的网络变化情况。 那么，注册 BroadcastReceiver 是静态注册呢，还是动态注册呢？ 静态注册：通常来讲，退出应用后，该应用仍然能够接收到相应的广播 动态注册：随着所在Context或应用被销毁后，不会收到相应的广播 注意：针对静态注册，这里是用“通常来讲”来修饰的，也就是说，存在特殊情况，即：存在即使使用静态注册，也不会收到相应的广播的情况： Android3.1之后，系统为了加强了安全性控制，应用程序安装后或是(设置)应用管理中被强制关闭后处于stopped状态，在这种状态下接收不到任何广播，除非广播带有 FLAG_INCLUDE_STOPPED_PACKAGES 标志，而默认所有系统广播都是 FLAG_EXCLUDE_STOPPED_PACKAGES 的，所以就没法通过系统广播自启动了。 这其中就包括 ConnectivityManager.CONNECTIVITY_ACTION 。关于这一块的内容，不是本篇重点，欲了解详情，请移步Android应用为何开机自启动、自启动失败原因 另外，Android 7.0 移除了三个隐式广播(Android 7.0 行为变更)，其中就包括 ConnectivityManager.CONNECTIVITY_ACTION , 这意味着通过静态注册 BroadcastReceiver 来监听该广播的方式在 targetSdkVersion &gt;= 24 版本上不再生效，如何解决这一问题请移步 Android 7.0 网络变化监听。 所以，这里采取动态注册 BroadcastReceiver 的方式。那么，应该在哪里动态注册呢？这里有两种思路： 思路1： 定义 BroadcastReceiver 监听网络状态，并提供回调接口 NetStateChangeObserver 用以回调网络状态的变化 抽象出 BaseActivity ，提供注册/取消注册 BroadcastReceiver 的方法，并实现 NetStateChangeObserver 需要监听网络状态的 Activity 调用 BaseActivity 提供的方法即可 思路2： 定义 BroadcastReceiver 监听网络状态，并提供回调接口 NetStateChangeObserver 用以回调网络状态的变化，并在 BroadcastReceiver 中维护 NetStateChangeObserver 列表，当网络发生变化则通知这些 Observer ，实现回调。 在 Application 中注册/取消注册 BroadcastReceiver 抽象 BaseActivity ，提供注册/取消注册 NetStateChangeObserver 观察者的方法， 并实现 NetStateChangeObserver 需要监听网络状态的 Activity 调用 BaseActivity 提供的方法即可 上面的两种思路，比较重要的区别在于，第1中是在 Activity 中注册 BroadcastReceiver , 后者是在 Application 中注册 BroadcastReceiver。前者需要多次注册 BroadcastReceiver 而后者只注册一次，所以在这里选择第2中思路。 实现添加权限&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /> 定义网络类型public enum NetworkType { NETWORK_WIFI("WiFi"), NETWORK_4G("4G"), NETWORK_3G("3G"), NETWORK_2G("2G"), NETWORK_UNKNOWN("Unknown"), NETWORK_NO("No network"); private String desc; NetworkType(String desc) { this.desc = desc; } @Override public String toString() { return desc; } } 定义观察者/** * 网络状态变化观察者 */ public interface NetStateChangeObserver { void onNetDisconnected(); void onNetConnected(NetworkType networkType); } 实现 BroadcastReceiver/** * 监听网络状态变化的BroadcastReceiver */ public class NetStateChangeReceiver extends BroadcastReceiver { private static class InstanceHolder { private static final NetStateChangeReceiver INSTANCE = new NetStateChangeReceiver(); } private List&lt;NetStateChangeObserver> mObservers = new ArrayList&lt;>(); public NetStateChangeReceiver() { } @Override public void onReceive(Context context, Intent intent) { if (ConnectivityManager.CONNECTIVITY_ACTION.equals(intent.getAction())) { NetworkType networkType = NetworkUtils.getNetworkType(context); notifyObservers(networkType); } } /** * 注册网络监听 */ public static void registerReceiver(@NonNull Context context) { IntentFilter intentFilter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION); context.registerReceiver(InstanceHolder.INSTANCE, intentFilter); } /** * 取消网络监听 */ public static void unregisterReceiver(@NonNull Context context) { context.unregisterReceiver(InstanceHolder.INSTANCE); } /** * 注册网络变化Observer */ public static void registerObserver(NetStateChangeObserver observer) { if (observer == null) return; if (!InstanceHolder.INSTANCE.mObservers.contains(observer)) { InstanceHolder.INSTANCE.mObservers.add(observer); } } /** * 取消网络变化Observer的注册 */ public static void unregisterObserver(NetStateChangeObserver observer) { if (observer == null) return; if (InstanceHolder.INSTANCE.mObservers == null) return; InstanceHolder.INSTANCE.mObservers.remove(observer); } /** * 通知所有的Observer网络状态变化 */ private void notifyObservers(NetworkType networkType) { if (networkType == NetworkType.NETWORK_NO) { for(NetStateChangeObserver observer : mObservers) { observer.onNetDisconnected(); } } else { for(NetStateChangeObserver observer : mObservers) { observer.onNetConnected(networkType); } } } } Application 注册 BroadcastReceiverpublic class AppContext extends Application{ @Override public void onCreate() { super.onCreate(); // 注册BroadcastReceiver NetStateChangeReceiver.registerReceiver(this); } @Override public void onTerminate() { super.onTerminate(); // 取消BroadcastReceiver注册 NetStateChangeReceiver.unregisterReceiver(this); } } BaseActivity 抽取public class BaseActivity extends AppCompatActivity implements NetStateChangeObserver { @Override protected void onResume() { super.onResume(); if (needRegisterNetworkChangeObserver()) { NetStateChangeReceiver.registerObserver(this); } } @Override protected void onStop() { super.onStop(); if (needRegisterNetworkChangeObserver()) { NetStateChangeReceiver.unregisterObserver(this); } } /** * 是否需要注册网络变化的Observer,如果不需要监听网络变化,则返回false;否则返回true.默认返回false */ protected boolean needRegisterNetworkChangeObserver() { return false; } @Override public void onNetDisconnected() { } @Override public void onNetConnected(NetworkType networkType) { } } 需要实现网络监听的 Activity 只需要复写 needRegisterNetworkChangeObserver 并返回 true ，并复写相关回调函数即可。 github源码地址:NetDetector]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>post%2F4a17b156%2F</url>
      <content type="text"><![CDATA[Hello World&nbsp;&nbsp;:) Welcome to my blog, have a nice day!&nbsp; ^_^ public class HelloWorld { public static void main(String[] args) { System.out.println("Hello World."); } } Everthing will be okay in the end. If it’s not okay, it’s not the end. 有志者 事竟成 破釜沉舟 百二秦关终属楚苦心人 天不负 卧薪尝胆 三千越甲可吞吴]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[免费ShadowSocks账号]]></title>
      <url>post%2F402cab53%2F</url>
      <content type="text"><![CDATA[免费提供SS账号的网站在这里我列出几个免费提供SS账户的网站： 免费ShadowSocks账号 世界那么大，我想去看看 SS ISS 这里需要注意的是： 以上这些网站提供的ss账号都会不断更新的，所以如果你使用这些免费的服务的话，可能需要及时更新。当然了，如果你是Programmer，你当然可以写脚本去爬取了对吧 :) 如果这些网站访问不了，可能是换网址了 or 被墙了 or 其他不可抗力的原因… 搭建自己的梯子之前是自己在网上找的免费的SS账户，这些免费的SS账户虽然可以提供免费的科学上网服务，但是不是特别稳定。再者，如果你对网络安全性比较在意的话，可能你需要考虑自己搭梯子了。所以，我就自己自己搭建了梯子，我采取的方案是VPS+ShadowSocks，VPS需要自己购买，我用的是搬瓦工的VPS，这里给个链接Mass VPS hosting on Enterprise equipment - Bandwagon Host,按月付的话最便宜的是2.99刀，当然了如果年付的话就更便宜了。当然了，还有其他的VPS提供商供大家选择，由于我没有尝试其他的，就不在这里列出来了。具体搭梯子的教程网上有很多，在这里贴几个： 搭建自己的Shadowsocks服务器 在 Ubuntu 服务器上部署 shadowsocks 科学上网之 Shadowsocks 安装及优化加速 ss优化加速 - 需翻墙如果感觉以上链接不太适合你的话，利用搜索引擎，多找找吧 :) 免费SS账户在这里我把我搭的SS Server的账号提供出来，反正流量比较多，造福下大家咯。当然了，如果它不生效了，恕不通知哈。可能是没再续费了，也可能是换账号了，etc. 服务器地址服务器端口密码加密方式23.106.158.19055501zljw5501aes-256-cfb 2017-06-16 更新： 因为近期 SS 流量已耗至90+%，日耗流量达100+G，故上面的 SS 账号已停止使用，抱歉~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序-快速排序及其优化]]></title>
      <url>post%2F2917269393%2F</url>
      <content type="text"><![CDATA[概念快速排序是交换类排序，采用分治思想，其基本原理是：通过一趟排序，将待排序数组分割成独立的两部分，其中一部分的关键字均比另一部分小；然后再分别对这两部分序列递归进行快速排序，从而使整个序列有序。 具体算法步骤： 在待排序的记录序列中选取一个记录作为枢轴(pivot)； 通过一趟排序，将所有小于枢轴的记录都移到枢轴的左边，将所有大于枢轴的记录都移到枢轴的右边，其实就是将当前待排序序列分为两部分，左边部分的记录均小于右边部分的记录，这样的操作叫做partition(分割)，分割操作结束后，枢轴所处的位置就是最终排序后它所处的位置； 对枢轴左右两边的子序列重复步骤1和2，直至所有子记录序列只剩下一个记录为止。 以上步骤中，关键点是 1. 枢轴(pivot)的选取方式； 2. 对分割操作(partition)的细节处理。 未优化的快速排序 枢轴的选取：将待排序序列的第1个记录作为枢轴； 分割操作 ： 分割操作中使用到了交换； Java实现 // 定义接口 interface Sorter { /** * 将数组按升序排序 */ int[] sort(int[] arr); /** * 交换数组arr中的第i个位置和第j个位置的关键字 */ default void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } // 未优化的快速排序 class QuickSorter implements Sorter { @Override public int[] sort(int[] arr) { quickSort(arr, 0, arr.length - 1); return arr; } /** * 对数组arr[low...high]的子序列作快速排序，使之有序 */ protected void quickSort(int[] arr, int low, int high) { int pivotLoc; // 记录枢轴(pivot)所在位置 if (low &lt; high) { pivotLoc = partition(arr, low, high); // 将arr[low...high]一分为二,并返回枢轴位置 quickSort(arr, low, pivotLoc - 1);// 递归遍历arr[low...pivotLoc-1] quickSort(arr, pivotLoc + 1, high); // 递归遍历arr[pivotLoc+1...high] } } /** * 在arr[low...high]选定pivot=arr[low]作为枢轴（中间位置），将arr[low...high]分成两部分， * 前半部分的子序列的记录均小于pivot，后半部分的记录均大于pivot;最后返回pivot的位置 */ protected int partition(int[] arr, int low, int high) { int pivot; pivot = arr[low]; // 将arr[low]作为枢轴 while (low &lt; high) { // 从数组的两端向中间扫描 // A while (low &lt; high &amp;&amp; arr[high] >= pivot) { // B high--; } swap(arr, low, high); // 将比枢轴pivot小的元素交换到低位 // C while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) { //D low++; } swap(arr, low, high); // 将比枢轴pivot大的元素交换到高位 // E } return low; // 返回一趟下来后枢轴pivot所在的位置 } } 演示为了方便演示，我对上面代码中的分割操作partition方法的代码进行了标注（分别标注为 A,B,C,D,E）。对于待排序序列 {5, 1, 9, 3, 7, 4, 8, 6, 2}，我们来演示其第一趟排序过程： low = 0, high = 8, pivot = arr[low] = 5; A处，low = 0, high = 8, low&lt;high，进行A循环； B处，high的值不断递减，直至arr[high] = 2 小于pivot，跳出B循环：pivot ↓ 5 1 9 3 7 4 8 6 2 ↑ ↑ low high C处，执行low和high的元素交换： pivot ↓ 2 1 9 3 7 4 8 6 5 ↑ ↑ low high D处，low的值不断递增，直至arr[low] = 9 大于 pivot，跳出D循环: pivot ↓ 2 1 9 3 7 4 8 6 5 ↑ ↑ low high E处，执行low和high的元素交换： pivot ↓ 2 1 5 3 7 4 8 6 9 ↑ ↑ low high A处，low =2, high = 8, low &lt; high，继续循环A； B处，high的值不断递减，直至arr[high] = 4 小于pivot，跳出B循环： pivot ↓ 2 1 5 3 7 4 8 6 9 ↑ ↑ low high C处，执行low和high的元素交换： pivot ↓ 2 1 4 3 7 5 8 6 9 ↑ ↑ low high D处，low的值不断递增，直至arr[low] = 7 大于 pivot，跳出D循环： pivot ↓ 2 1 4 3 7 5 8 6 9 ↑ ↑ low high E处，执行low和high的元素交换： pivot ↓ 2 1 4 3 5 7 8 6 9 ↑ ↑ low high A处，low = 4， high = 5， low &lt; high， 继续循环A： B处，high不断递减，直至high=4 等于 low，不满足 low &lt; high，跳出B循环： pivot ↓ 2 1 4 3 5 7 8 6 9 ↑ low high 因为low和high已经重合，所以在接下来的C、D、E操作中序列均未发生变化 A处，low=4, high = 4, 不满足 low &lt; high, 跳出A循环，最后返回low=4，即为pivot所在位置； 所以第1趟排序下来之后，序列会变成 {2, 1, 4, 3, 5, 7, 8, 6, 9}；然后再对子序列{2, 1, 4, 3} 和 {7, 8, 6, 9} 做同样的操作即可完成整个排序。 对于partition方法中的low和high，可以这样理解：在low左边的记录都都小于等于枢轴pivot，在high右边的记录都大于等于枢轴pivot，那么当low和high重合时，则表示已经分割完毕，重合的位置（即low的值）就是枢轴pivot的位置。 快速排序的优化(1) 枢轴的选取方式的优化：枢轴的选取方式有：(1) 固定位置选取；(2) 随机位置选取； (3) 三值取中法 等 固定位置选取：选取当前序列的第一个元素或者最后一个元素作为枢轴，上面的算法的枢轴选取方式即为固定位置选取。该方法不是一个好的选取方案，因为当整个序列有序时，每次分割(partition)操作只会将待排序序列减1，此时为最坏情况，算法复杂度沦为O(n^2)。然而，在待排序的序列中局部有序是相当常见的，所以固定位置选取枢轴不是一种好的选择。 随机位置选取：随机选取当前待排序序列的任意记录作为枢轴。由于采取随机，所以时间性能要强于固定位置选取。 三值取中法： 待排序序列的前(第一个位置)、中(中间位置)、后(最后一个位置)三个记录中的中间值(按大小排序)作为枢轴，比如: 9 1 7 5 2 8 6 3 4 ↑ ↑ ↑ low mid high 前 中 后 由于 9 &gt; 4 &gt; 2； 因此将4作为此次分割(partition)操作的枢轴。三值取中操作后，整个序列变为： 4 1 7 5 2 8 6 3 9 ↑ ↑ ↑ low mid high 前 中 后 三值取中本质上就是随机位置选取，但是由于随机位置选取过程中需要用到随机种子来产生随机数，而三值取中不需要，所以三值取中要优于随机位置选取。 所以优化枢轴的选取方式时，我们选择三值取中的方式。 (2) 优化小数组时的排序方案：当局部排序数组长度较小时，采用插入排序，而非快速排序，因为长度分割到够小后，继续分割的效率要低于直接插入排序。 (3) 略去不必要的交换略去不必要的交换，将交换操作改为替换操作。因为交换操作需要进行3次赋值操作，而替换操作只需要进行1次赋值操作。 Java实现 // 优化的快速排序 class OptimizedQuickSorter extends QuickSorter { /** * 插入排序最大数组长度值 */ private static final int MAX_LENGTH_INSERT_SORT = 7; /** * 对数组arr[low...high]的子序列作快速排序，使之有序 */ @Override protected void quickSort(int[] arr, int low, int high) { int pivotLoc; // 记录枢轴(pivot)所在位置 if ((high - low + 1) > MAX_LENGTH_INSERT_SORT) { // 待排序数组长度大于临界值，则进行快速排序 pivotLoc = partition(arr, low, high); // 将arr[low...high]一分为二,并返回枢轴位置 quickSort(arr, low, pivotLoc - 1);// 递归遍历arr[low...pivotLoc-1] quickSort(arr, pivotLoc + 1, high); // 递归遍历arr[pivotLoc+1...high] } else { // 2. 优化小数组时的排序方案，将快速排序改为插入排序 insertSort(arr, low, high); // 对arr[low...high]子序列进行插入排序 } } /** * 在arr[low...high]中利用三值取中选取枢轴(pivot)，将arr[low...high]分成两部分， * 前半部分的子序列的记录均小于pivot，后半部分的记录均大于pivot;最后返回pivot的位置 */ @Override protected int partition(int[] arr, int low, int high) { int pivot; pivot = medianOfThree(arr, low, high); // 1. 优化排序基准，使用三值取中获取中值 while (low &lt; high) { // 从数组的两端向中间扫描 // A while (low &lt; high &amp;&amp; arr[high] >= pivot) { // B high--; } // swap(arr, low, high); // 将比枢轴pivot小的元素交换到低位 arr[low] = arr[high]; // 3. 优化不必要的交换，使用替换而不是交换 // C while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) { // D low++; } // swap(arr, low, high); // 将比枢轴pivot大的元素交换到高位 arr[high] = arr[low]; // 3. 优化不必要的交换，使用替换而不是交换 // E } arr[low] = pivot; // F return low; // 返回一趟下来后枢轴pivot所在的位置 } /** * 通过三值取中(从arr[low...high]子序列中)获取枢轴pivot的值，让arr[low]变成中值;并返回计算的枢轴(pivot) */ private int medianOfThree(int[] arr, int low, int high) { int mid = low + ((high - low) >> 1); // mid = low + (high-low)/2, 中间元素下标 // 使用三值取中得到枢轴 if (arr[low] > arr[high]) { // 目的：让arr[low] &lt;= arr[high] swap(arr, low, high); } if (arr[mid] > arr[high]) { // 目的：让arr[mid] &lt;= arr[high] swap(arr, mid, high); } if (arr[mid] > arr[low]) { // 目的： 让arr[low] >= arr[mid] swap(arr, low, mid); } // 经过上述变化，最终 arr[mid]&lt;=arr[low]&lt;=arr[high]，则arr[low]为中间值 return arr[low]; } /** * 对子序列arr[low...high]进行插入排序 */ private void insertSort(int[] arr, int low, int high) { int i, j; int tmp; for (i = low + 1; i &lt;= high; i++) { // 从下标low+1开始遍历,因为下标为low的已经排好序 if (arr[i] &lt; arr[i - 1]) { // 如果当前下标对应的记录小于前一位记录,则需要插入,否则不需要插入，直接将记录数增加1 tmp = arr[i]; // 记录下标i对应的元素 for (j = i - 1; j >= low &amp;&amp; arr[j] > tmp; j--) { arr[j + 1] = arr[j]; // 记录后移 } arr[j + 1] = tmp; // 插入正确位置 } } } } 演示为了方便演示，我对上面代码中的分割操作partition方法的代码仍然进行了标注（分别标注为 A,B,C,D,E,F）。对于待排序序列 {5, 1, 9, 3, 7, 4, 8, 6, 2}，我们来演示其第一趟排序过程： low = 0， high = 8， high-low+1=9 &gt; MAX_LENGTH_INSERT_SORT， 所以需要进行快速排序，接下来进行分割(partition)操作； 此时待排序序列：5 1 9 3 7 4 8 6 2 ↑ ↑ low high 三值取中前：5 1 9 3 7 4 8 6 2 ↑ ↑ ↑ low mid high 三值取中后：pivot ↓ 5 1 9 3 2 4 8 6 7 ↑ ↑ ↑ low mid high pivot = 5； A处，low = 0, high = 8, low &lt; high, 进行A循环； B处，high的值不断递减，直至arr[high] = 4 小于pivot，跳出B循环：5 1 9 3 2 4 8 6 7 ↑ ↑ low high C处，arr[low] = arr[high]，将低位的值替换成高位的值：4 1 9 3 2 4 8 6 7 ↑ ↑ low high D处，low的值不断递增，直至arr[low] = 9 大于 pivot，跳出D循环:4 1 9 3 2 4 8 6 7 ↑ ↑ low high E处，arr[high] = arr[low]， 将高位的值替换成低位的值：4 1 9 3 2 9 8 6 7 ↑ ↑ low high A处，low = 2, high = 5, low &lt; high, 进行A循环； B处，high的值不断递减，直至arr[high] = 2 小于pivot，跳出B循环：4 1 9 3 2 9 8 6 7 ↑ ↑ low high C处，arr[low] = arr[high]，将低位的值替换成高位的值：4 1 2 3 2 9 8 6 7 ↑ ↑ low high D处，low的值不断递增，直至low = 4, high = 4, low == high，不满足 low&lt;high，跳出D循环:4 1 2 3 2 9 8 6 7 ↑ low high 因为low和high已经重合，所以在接下来的E操作中序列未发生变化； A处，low=4, high = 4, 不满足 low &lt; high, 跳出A循环； F处， arr[low] = pivot:4 1 2 3 5 9 8 6 7 ↑ low high 最后返回low = 4，即为pivot所在的位置。 所以这趟排序下来之后，序列会变成 {4 1 2 3 5 9 8 6 7}；然后再对子序列{4, 1, 2, 3} 和 {9, 8, 6, 7} 做同样的操作即可完成整个排序。 复杂度时间复杂度：时间复杂度为O(nlogn)，在对快速排序进行各种细节性的优化后，快速排序的性能大大提高，在一般条件下超越了其它排序方法，故得此名。 空间复杂度：就空间复杂度来说，主要是递归造成的栈空间的使用，最好情况，递归的深度为log2n，其空间复杂度也就为O(logn)，最坏情况，需要进行n‐1递归调用，其空间复杂度为O(n)，平均情况，空间复杂度也为O(logn)。 参考链接：常见排序算法 - 快速排序 (Quick Sort)三种快速排序以及快速排序的优化]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序-归并排序]]></title>
      <url>post%2F3453824605%2F</url>
      <content type="text"><![CDATA[概念归并排序就是利用归并的思想实现的排序算法。归并排序的原理：假设初始序列含有n个记录，该序列可以看成n个有序的子序列，其中每个子序列的长度为1，然后两两归并，得到⌈n/2⌉（⌈x⌉表示不小于x的最小整数）个长度为2或者1的子序列，然后再两两归并，……，如此重复直到得到1个长度为n的有序序列为止。 递归式归并演示比如我们待排序的数组是 {9, 1, 5, 8, 3, 7, 4, 6, 2}，那么递归式的归并排序为流程为： [9, 1, 5, 8, 3, 7, 4, 6, 2] ↓ ↓ [9, 1, 5, 8, 3] [7, 4, 6, 2] ↓ ↓ ↓ ↓ [9, 1, 5] [8, 3] [7, 4] [6, 2] ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ [9, 1] [5] [8] [3] [7] [4] [6] [2] ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ [9] [1] [5] [8] [3] [7] [4] [6] [2] // 上面为拆分，下面为归并(合并) ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ [1, 9] [5] [8] [3] [7] [4] [6] [2] ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ [1, 5, 9] [3, 8] [4, 7] [2, 6] ↓ ↓ ↓ ↓ [1, 3, 5, 9, 8] [2, 4, 6, 7] ↓ ↓ [1, 2, 3, 4, 5, 6, 7, 8, 9] Java实现 // 定义接口 interface Sorter { /** * 将数组按升序排序 */ int[] sort(int[] arr); /** * 交换数组arr中的第i个位置和第j个位置的关键字 */ default void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } // 递归式归并排序 class MergeSorter implements Sorter { @Override public int[] sort(int[] arr) { int[] result = new int[arr.length]; mergeSort(arr, result, 0, arr.length - 1); return result; } /** * 将乱序的src[start...end]归并排序为有序的des[start...end] * * @param src * 归并前乱序数组 * @param des * 归并后的有序数组 * @param start * 归并的起始位置 * @param end * 归并的终止位置 */ private void mergeSort(int[] src, int[] des, int start, int end) { if (start == end) { des[start] = src[start]; return; } int[] tmp = new int[src.length]; // 将src[start...end]分为src[start...mid]和src[mid+1...end]两部分 int mid = (start + end) / 2; mergeSort(src, tmp, start, mid); // 递归，将src[start...mid]归并为有序的tmp[start...mid] mergeSort(src, tmp, mid + 1, end); // 递归，将src[mid+1...end]归并为有序的tmp[mid+1...end] // 将有序的tmp[start...mid]和tmp[mid+1...end]合并为des[start...end] merge(tmp, des, start, mid, end); } /** * 将有序的src[start, mid]和有序的src[mid+1, end]合并为有序的des[start,end]; * src可能为乱序数组,但是src[start, mid]和src[mid+1, end]是有序的。 * * @param src * 乱序的原数组 * @param des * 有序的目标数组 * @param start * 数组第一部分起始位置 * @param mid * 数组第一部分结束位置（两部分的分界点） * @param end * 数组第二部分结束位置 */ protected void merge(int[] src, int[] des, int start, int mid, int end) { int i; // src数组第一部分下标 int j; // src数组第二部分下标 int k; // des数组下标 // 将较小的数依次移动到目标数组中 for (i = start, k = start, j = mid + 1; i &lt;= mid &amp;&amp; j &lt;= end;) { if (src[i] &lt; src[j]) { des[k] = src[i++]; } else { des[k] = src[j++]; } k++; } // 将剩余的src[i...mid]复制到des数组中 for (; i &lt;= mid; i++) { des[k] = src[i]; k++; } // 将剩余的src[j...end]复制到des数组中 for (; j &lt;= end; j++) { des[k] = src[j]; k++; } } } 复杂度时间复杂度：因为归并的递归操作其实就是二叉树的结构，故而，最好情况 = 最坏情况 = 平均情况 = O(nlogn) 空间复杂度：因为递归式归并需要(1)与原始记录相同大小的空间来存放归并的结果以及(2)深度为logn的栈空间，所以空间复杂度为O(n+logn) 非递归式归并演示又比如我们待排序的数组是 {9, 1, 5, 8, 3, 7, 4, 6, 2}，那么非递归式的归并排序为流程为： [9] [1] [5] [8] [3] [7] [4] [6] [2] ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ [1, 9] [5, 8] [3, 7] [4, 6] [2] ↓ ↓ ↓ ↓ ↓ [1, 5, 8, 9] [3, 4, 6, 7] [2] ↓ ↓ ↓ [1, 3, 4, 5, 6, 7, 8, 9] [2] ↓ ↓ [1, 2, 3, 4, 5, 6, 7, 8, 9] Java实现 // 非递归式归并排序 class NonRecursiveMergeSorter extends MergeSorter { @Override public int[] sort(int[] arr) { mergeSort(arr); return arr; } private void mergeSort(int[] arr) { int len = arr.length; int result[] = new int[len]; int k = 1; while (k &lt; len) { mergePass(arr, result, k); // arr归并至result,此时间隔为k k = 2 * k; // 子序列长度加倍 mergePass(result, arr, k); // result归并至arr,此时间隔翻倍 k = 2 * k; // 子序列长度加倍 } } /** * 将数组src中相邻长度为interval的子序列两两归并到des数组中 * * @param src * 源数组 * @param des * 目标数组 * @param interval * 两两合并的子序列长度 */ private void mergePass(int[] src, int[] des, int interval) { int i = 0; int len = src.length; while (i + 2 * interval - 1 &lt; len) { // 两两合并 merge(src, des, i, i + interval - 1, i + 2 * interval - 1); i = i + 2 * interval; } if (i + interval - 1 &lt; len - 1) { // i+interval-1小于len-1，说明最后还剩余两个子序列，只不过最后的一个子序列长度不够interval // 那么将剩下的两个子序列进行合并 merge(src, des, i, i + interval - 1, len - 1); } else { // 否则，最后只剩下单个子序列，则直接将该子序列加入到des尾部 for (; i &lt; len; i++) { des[i] = src[i]; } } } } 复杂度时间复杂度：同递归式归并，最好情况 = 最坏情况 = 平均情况 = O(nlogn) 空间复杂度：非递归式归并不需要保存方法栈信息，所以空间复杂度为O(n) 所以非递归的递归算法性能要高于递归式归并算法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序-堆排序]]></title>
      <url>post%2F716497058%2F</url>
      <content type="text"><![CDATA[概念堆： 堆是具有下列性质的完全二叉树：每个节点的值都大于或等于其左右孩子（如果存在的话）的值，称为最大堆；或者每个节点的值都小于或等于其左右孩子（如果存在的话）的值，称为最小堆。 完全二叉树：complete binary tree 最大堆：max heap 最小堆：min heap图片来源: 常见排序算法 - 堆排序 (Heap Sort) 堆排序：利用堆（这里使用最大堆）进行排序的方法。其基本思想是：将待排序的序列构造成一个最大堆，此时待排序序列的最大值就是堆顶的根节点，将其移走（其实就是将其与待排序序列的最后一个元素进行交换，此时待排序序列最后一个元素就是最大值），然后将剩余的序列重新构造成一个堆，如此反复，直到待排序序列只有一个元素为止，则排序完成。 性质已知arr[0…n-1]是长度为n的最大堆数组，下标从0开始，那么对于下标为 i 的节点 I ，有：(1). 如果 I 的左孩子存在的话，那么I的左孩子节点的下标为 left(i) = 2*i+1；(2). 如果 I 的右孩子存在的话，那么I的右孩子节点的下标为 right(i) = 2*i+2;(3). 如果 I 双亲节点存在的话，那么I的双亲节点的下标为 parent(i) = (i-1)/2; (向下取整) 基本操作 构建最大堆 buildMaxHeap(int[] arr)：将待排序序列arr构建成最大堆； 调整最大堆 adjustHeap(int arr[], int begin, int end): 已知arr[begin]的左子树和右子树都满足最大堆，那么调节节点arr[begin]，将以arr[begin]为根节点的二叉树调整为最大堆。 对于堆排序，最重要的就是构建最大堆和调整最大堆，其实构造初始堆事实上也是调整堆的过程，只不过构造初始堆是对所有的非叶节点都进行调整。 Java实现// 定义接口 interface Sorter { /** * 将数组按升序排序 */ int[] sort(int[] arr); /** * 交换数组arr中的第i个位置和第j个位置的关键字 */ default void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } // 堆排序 class HeapSorter implements Sorter { @Override public int[] sort(int[] arr) { heapSort(arr); return arr; } private void heapSort(int[] arr) { buildMaxHeap(arr); // 构建最大堆 // 将最大堆堆顶元素与数组末尾元素交换，并将前n-1序列重新构造成最大堆,重复n-1次 for (int i = arr.length - 1; i >= 1; i--) { swap(arr, 0, i); // 将堆顶元素和当前未经排序的子序列的最后一个元素进行交换 adjustHeap(arr, 0, i - 1); // 将arr[0...i-1](前i个元素)重新调整为最大堆 } } /** * 将指定数组arr构建成最大堆 */ private void buildMaxHeap(int[] arr) { int len = arr.length; // 从最后一个非叶子节点往前遍历，将当前序列构成最大堆 for (int i = len / 2 - 1; i >= 0; i--) { adjustHeap(arr, i, len - 1); } } /** * 假定arr[begin]的左子树和右子树均满足最大堆，那么调节节点arr[begin]，将以arr[begin]为根节点的二叉树调整为最大堆。 */ private void adjustHeap(int[] arr, int begin, int end) { int tmp = arr[begin]; int j; for (j = 2 * begin + 1; j &lt;= end; j = 2 * j + 1) { // j=2*begin+1表示j对应二叉树节点的左孩子 if (j + 1 &lt;= end &amp;&amp; arr[j] &lt; arr[j + 1]) { // 如果当前节点的右孩子存在且左孩子的值小于右孩子 j++; // j为左右孩子较大记录的下标 } if (tmp >= arr[j]) // tmp的值已经大于arr[j]，则调整完毕，跳出循环 break; arr[begin] = arr[j]; // 当前根节点并未均大于左右节点(如果有的话)，重新给当前根节点赋值 begin = j; // begin指向新的可能需要进行最大堆调整的子树的根节点 } arr[begin] = tmp; } } 堆排序其实也是一种选择排序，是一种树形选择排序。在简单选择排序中，从arr[0…n-1]中选择最小（或最大）记录，需要比较n-1次，然后再从剩下arr[1…n-1]的n-1个元素中选择最小（或最大）记录，需要比较n-2次。然而事实上这n-2次比较中，有许多已经在前一趟n-1次的比较中做过了；而树形选择排序恰好利用树形的特点保存了部分前面的比较结果，因此可以减少比较次数，提高算法效率。 复杂度时间复杂度：对于n个关键字序列，每个节点需比较log2(n)次，因此其时间复杂度为O(nlogn)。由于堆排序对原始记录的排序状态并不敏感，所以它的最好、最坏、平均时间复杂度均为O(nlogn)由于初始构建堆所需要的比较次数较多，所以堆排序不适合待排序序列个数少的情况。 空间复杂度：最好情况=平均情况=最坏情况=O(1) 参考链接推排序常见排序算法 - 堆排序 (Heap Sort)堆排序(Heap Sort)算法学习]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序-希尔排序]]></title>
      <url>post%2F3263168730%2F</url>
      <content type="text"><![CDATA[概念希尔排序是插入类排序算法，它的本质就是分组插入排序，它采取分割策略：将相距某个“增量”的记录组成一个子序列，保证在每个子序列内部分别进行插入排序后得到的结果是基本有序。 该方法的基本思想是：先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。 因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比插入排序有大幅度提高。 Java实现// 定义接口 interface Sorter { /** * 将数组按升序排序 */ int[] sort(int[] arr); /** * 交换数组arr中的第i个位置和第j个位置的关键字 */ default void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } //希尔排序 public class ShellSorter implements Sorter { @Override public int[] sort(int[] arr) { shellSort(arr); return arr; } // Shell排序的关键就是增量序列的选取： // 增量序列原则： 增量序列的最后一个增量必须等于1 private void shellSort(int[] arr) { int len = arr.length; int increment = len; for (; increment != 1;) {// 循环直至increment=1 increment = increment / 3 + 1; // 计算增量序列(将整个序列分成increment组,在组内进行插入排序) for (int i = increment; i &lt; len; i++) { if (arr[i] &lt; arr[i - increment]) { int tmp = arr[i]; // 暂存arr[i]的值 int j; for (j = i - increment; j >= 0 &amp;&amp; tmp &lt; arr[j]; j -= increment) { // 组内记录后移,查找插入位置 arr[j + increment] = arr[j]; } // 找到插入位置 arr[j + increment] = tmp; } } } } } 演示比如我们待排序的数组是 {9, 1, 5, 8, 3, 7, 4, 6, 2}初始时increment=arr.length=9，increment != 1，执行第1次循环：increment = 9/3+1 = 4，将整个序列分成4组，组内进行插入排序： 第 1 组： 9 3 2 -----------&gt; 2 3 9 第 2 组： 1 7 -----------&gt; 1 7 第 3 组： 5 4 -----------&gt; 4 5 第 4 组： 8 6 -----------&gt; 6 8 此时序列为 2 1 4 6 3 7 5 8 9 increment=4，increment != 1，执行第2次循环：increment = 4/3+1 = 2，将整个序列分成2组，组内进行插入排序： 第 1 组： 2 4 3 5 9 -----------&gt; 2 3 4 5 9 第 2 组： 1 6 7 8 -----------&gt; 1 6 7 8 此时序列为 2 1 3 6 4 7 5 8 9 increment=2，increment != 1，执行第3次循环：increment = 2/3+1 = 1，将整个序列分成1组，组内进行插入排序（演变为直接插入排序）： 第 1 组 ： 2 1 3 6 4 7 5 8 9 -----------&gt; 1 2 3 4 5 6 7 8 9 increment=1，结束循环，排序完毕。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序-插入排序]]></title>
      <url>post%2F1309789713%2F</url>
      <content type="text"><![CDATA[概念插入排序是插入类的排序算法，基本原理：将一个记录插入到已经排好序的有序表中，从而得到一个新的记录数增加1的有序表。 具体算法：整个序列分为两部分，左边部分为已排序的子序列，右边部分为未排序的子序列，取出第1个未排序元素存放在临时变量tmp中，在已经排序的元素序列中从后往前遍历，逐一比较，如果遍历到的元素大于tmp，则将该元素替换下一个位置的元素，直至遍历到的元素小于或等于tmp为止。相当于将未排序的第一个元素插入到已排序的数组中，故以插入排序为名。 演示比如我们待排序的数组是 {0, 5, 3, 4, 6, 2}第1趟排序，5大于0，无需插入： 0 5 3 4 6 2第2趟排序，3小于5，需要插入： 0 3 5 4 6 2第3趟排序，4小于5，需要插入： 0 3 4 5 6 2第4趟排序，6大于5，无需插入： 0 3 4 5 6 2第5趟排序，2小于6，需要插入： 0 2 3 4 5 6 Java实现// 定义接口 interface Sorter { /** * 将数组按升序排序 */ int[] sort(int[] arr); /** * 交换数组arr中的第i个位置和第j个位置的关键字 */ default void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } //插入排序 class InsertSorter implements Sorter { @Override public int[] sort(int[] arr) { insertSort(arr); return arr; } private void insertSort(int[] arr) { int len = arr.length; int i, j; int tmp; for (i = 1; i &lt; len; i++) { // 从下标1开始遍历,因为下标0的已经排好序 if (arr[i] &lt; arr[i - 1]) { // 如果当前下标对应的记录小于前一位记录,则需要插入,否则不需要插入，直接将记录数增加1 tmp = arr[i]; // 记录下标i对应的元素 for (j = i - 1; j >= 0 &amp;&amp; arr[j] > tmp; j--) { arr[j + 1] = arr[j]; // 记录后移 } arr[j + 1] = tmp; // 插入正确位置 } } } } 复杂度时间复杂度：最好情况：当待排序的序列为顺序表时，会进行n-1次比较，0次替换，复杂度为O(n)；最坏情况：当待排序的序列为逆序表时，会进行2+3+…+n=(n+2)*(n-1)/2次比较，2+3+…+n = (n+2)*(n-1)/2次替换，复杂度为O(n^2)；平均情况：平均比较次数约为n^2/2, 平均移动次数为n^2/2，复杂度为O(n^2)。 空间复杂度：最好情况=最坏情况=平均情况=O(1)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序-选择排序]]></title>
      <url>post%2F2610207546%2F</url>
      <content type="text"><![CDATA[概念简单选择排序是选择类的排序，算法原理：第i次排序（1≤ i ≤n-1），从待排序的n-i+1个记录中， 进行n-i次关键字比较，从n-i+1个记录中选出最小的，并和第i-1个记录进行交换。 演示比如我们待排序的数组是 {9, 1, 5, 8, 3, 7, 4, 6, 2}第1趟排序，1最小，与第0个位置9进行交换： 1 9 5 8 3 7 4 6 2第2趟排序，2最小，与第1个位置9进行交换： 1 2 5 8 3 7 4 6 9第3趟排序，3最小，与第2个位置5进行交换： 1 2 3 8 5 7 4 6 9第4趟排序，4最小，与第3个位置8进行交换： 1 2 3 4 5 7 8 6 9第5趟排序，5最小，第4个位置是5无须交换： 1 2 3 4 5 7 8 6 9第6趟排序，6最小，与第5个位置7进行交换： 1 2 3 4 5 6 8 7 9第7趟排序，7最小，与第6个位置8进行交换： 1 2 3 4 5 6 7 8 9第8趟排序，8最小，第7个位置是8无须交换： 1 2 3 4 5 6 7 8 9 其实就是每一趟排序将当前未排序序列中的最小的记录与未排序序列的最前端的位置进行交换。 Java实现// 定义接口 interface Sorter { /** * 将数组按升序排序 */ int[] sort(int[] arr); /** * 交换数组arr中的第i个位置和第j个位置的关键字 */ default void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } //选择排序 class SelectionSorter implements Sorter { @Override public int[] sort(int[] arr) { selectSort(arr); return arr; } private void selectSort(int[] arr) { int i, j, min; int len = arr.length; for (i = 0; i &lt; len - 1; i++) { min = i; // min记录最小值的下标 for (j = i + 1; j &lt; len; j++) { // 循环i之后的数据 if (arr[j] &lt; arr[min]) // 发现有小于当前最小值的关键字 min = j; // 将该下标赋值给min } if (i != min) // 如果i和min不等，在i之后的数据中找到了最小值，则需要arr[i]于arr[min]进行交换 swap(arr, i, min); } } } 复杂度时间复杂度：对于比较次数而言，无论最好最差情况，其比较次数都是一样的：第i趟排序需要进行n-i次比较，此时比较次数=(n-1)+(n-2)+…+1 = n*(n-1)/2；对于交换次数而言，其最好情况为顺序表，交换次数为0次；最差情况为逆序表，交换次数为n-1次，那么平均情况则为(n-1)/2次交换；由于时间复杂度取决于比较次数和交换次数总和，故而交换排序的时间复杂度为O(n^2)。因为相较于冒泡排序，选择排序的交换次数要少，所以选择排序的性能要优于冒泡排序。 空间复杂度：最好情况=最坏情况=平均情况=O(1)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java-IPv4地址和int类型数字的互相转换]]></title>
      <url>post%2F1779625018%2F</url>
      <content type="text"><![CDATA[问题分析对于ipv4的地址来说，如果用字符串的形式存储的话，其占用字节就比较大，比如对于IPv4地址0.0.0.0的字符串，就需要7个字节，IPv4为255.255.255.255 的字符串，需要15个字节，也就是说存储一个ip需要占用7~15个字节。 那么有没有更节省空间的存储方式呢？答案是有。 方案1： 直接把字符串中的’.’去掉，不就变成一个数字了嘛，比如 “255.255.255.255” 变成 255255255255，然而我们知道int所能表示的最大值 = Integer.MAX_VALUE = 2^31-1 = 2147483647， 255255255255 &gt; 2^31-1，所以需要用长整形long来表示，长整形占用8个字节，也就是说我们将7~15个字节转换为8字节，在绝大多数情况下是节省空间了的。 方案2： 因为考虑到IPv4的地址本质上就是32位的二进制串，而一个int类型的数字刚好为4个字节32个bit位，所以刚好可以用一个int类型的数字转表示IPv4地址。所以，我们可以用4个字节的int数字表示一个ip地址，这样可以大大节省空间。 这里只讨论方案2 :) 演示对于ipv4地址： 192.168.1.3：每段都用二进制表示： 192(10) = 11000000(2) ; 168(10) = 10101000(2) ; 1(10) = 00000001(2) ; 3(10) = 00000011(2) 。所以连在一起就是：11000000101010000000000100000011，对应的int数字就是-1062731775 。 具体算法分析：192左移24位： 11000000 00000000 00000000 00000000168左移16位： 00000000 10101000 00000000 00000000001左移08位： 00000000 00000000 00000001 00000000003左移00位： 00000000 00000000 00000000 00000011按位或的结果： 11000000 10101000 00000001 00000011即 -1062731775 将int类型的数字转换成ip地址，其实就是上述过程的逆过程，这里就不再赘述。 Java实现/** * IPv4地址和int数字的互相转换 * * @author Tianma * */ public class IPv4IntTransformer { /** * IPv4地址转换为int类型数字 * */ public static int ip2Integer(String ipv4Addr) { // 判断是否是ip格式的 if (!isIPv4Address(ipv4Addr)) throw new RuntimeException("Invalid ip address"); // 匹配数字 Pattern pattern = Pattern.compile("\\d+"); Matcher matcher = pattern.matcher(ipv4Addr); int result = 0; int counter = 0; while (matcher.find()) { int value = Integer.parseInt(matcher.group()); result = (value &lt;&lt; 8 * (3 - counter++)) | result; } return result; } /** * 判断是否为ipv4地址 * */ private static boolean isIPv4Address(String ipv4Addr) { String lower = "(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])"; // 0-255的数字 String regex = lower + "(\\." + lower + "){3}"; Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(ipv4Addr); return matcher.matches(); } /** * 将int数字转换成ipv4地址 * */ public static String integer2Ip(int ip) { StringBuilder sb = new StringBuilder(); int num = 0; boolean needPoint = false; // 是否需要加入'.' for (int i = 0; i &lt; 4; i++) { if (needPoint) { sb.append('.'); } needPoint = true; int offset = 8 * (3 - i); num = (ip >> offset) &amp; 0xff; sb.append(num); } return sb.toString(); } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序-冒泡排序及其优化]]></title>
      <url>post%2F42083511%2F</url>
      <content type="text"><![CDATA[概念冒泡排序是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直至没有反序的记录为止。因为按照该算法，每次比较会将当前未排序的记录序列中最小的关键字移至未排序的记录序列最前（或者将当前未排序的记录序列中最大的关键字移至未排序的记录序列最后），就像冒泡一样，故以此为名。 演示比如我们待排序的数组是 {9, 1, 5, 8, 3, 7, 4, 6, 2}第1趟排序：第1次比较，2和6比较，2小于6，反序，进行交换： 9 1 5 8 3 7 4 2 6第2次比较，2和4比较，2小于4，反序，进行交换： 9 1 5 8 3 7 2 4 6第3次比较，2和7比较，2小于7，反序，进行交换： 9 1 5 8 3 2 7 4 6第4次比较，2和3比较，2小于3，反序，进行交换： 9 1 5 8 2 3 7 4 6第5次比较，2和8比较，2小于8，反序，进行交换： 9 1 5 2 8 3 7 4 6第6次比较，2和5比较，2小于5，反序，进行交换： 9 1 2 5 8 3 7 4 6第7次比较，2和1比较，2大于1，正序，不用交换： 9 1 2 5 8 3 7 4 6第8次比较，1和9比较，1小于1，反序，进行交换： 1 9 2 5 8 3 7 4 6可以看出，第一趟排序将当前序列最小值移动至未排序的序列最前面的位置。 第2趟排序： 因为第一趟已经排好1的位置，所以只需要对剩下的{9, 2, 5, 8, 3, 7, 4, 6}再进行冒泡排序… 重复以上操作，直至排序完毕 Java实现// 定义接口 interface Sorter { /** * 将数组按升序排序 */ int[] sort(int[] arr); /** * 交换数组arr中的第i个位置和第j个位置的关键字 */ default void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } } // 冒泡排序 class BubbleSorter implements Sorter { @Override public int[] sort(int[] arr) { bubbleSort(arr); return arr; } private void bubbleSort(int[] arr) { int i, j; int len = arr.length; for (i = 0; i &lt; len - 1; i++) { for (j = len - 1; j > i; j--) { if (arr[j - 1] > arr[j]) { swap(arr, j - 1, j); } } } } } 优化当待排序数组为{1, 3, 4, 5, 6, 7, 8, 9, 2}时：第1趟排序的结果为： 1 2 3 4 5 6 7 8 9此时其实序列已经完成，但是根据上述代码仍得继续遍历，直至第9趟排序。这显然是不合理的，如果我们能在代码中加入一个flag标记上一趟排序中是否进行过交换，如果进行过未进行交换，说明当前数组以及有序。优化代码： // 优化的冒泡排序 class OptimizedBubbleSorter extends BubbleSorter { @Override protected void bubbleSort(int[] arr) { int i, j; int len = arr.length; boolean swapped = true; // 标记：上一趟循环是否进行过交换 for (i = 0; i &lt; len - 1 &amp;&amp; swapped; i++) { swapped = false; // 在某一趟遍历中,如果没有可交换的,那么swapped = false,跳出外层循环; // 如果一旦进行了交换,则swapped = true,需要进行下一趟遍历 for (j = len - 1; j > i; j--) { if (arr[j - 1] > arr[j]) { swap(arr, j - 1, j); swapped = true; } } } } } 复杂度时间复杂度：最好情况： 排序表本身是顺序的，根据优化后的代码，则只需要进行n-1次比较，故时间复杂度为O(n)；最差情况： 排序表本身是逆序的，则比较次数为 1+2+…+(n-1) = n*(n-1)/2 , 并作等数量级的移动操作；平均情况： 时间复杂度为 O(n^2) 空间复杂度：最好情况=最坏情况=平均情况=O(1)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[查找-二叉搜索树（Java实现）]]></title>
      <url>post%2F1367710076%2F</url>
      <content type="text"><![CDATA[前言如果查找的数据集是有序的线性表，并且是顺序存储的，查找可以用折半查找、插值查找、斐波那契查找算法（详细算法见：有序表查找（折半、插值、斐波那契查找））等实现。但是正是因为他们是顺序的，所以在插入和删除操作中需要耗费大量时间，也就是说这些算法适合静态查找（只有查找操作），不适合动态查找（不仅有查找操作还有插入删除等操作）。而二叉搜索树正适合动态查找。 定义二叉搜索树又称为二叉排序树，它或者是空树，或者是具有下列性质的二叉树： 如果它的左子树不为空，那么左子树的所有节点都小于根节点的值； 如果它的右子树不为空，那么右子树的所有节点都大于根节点的； 它的左、右子树也分别是二叉搜索树. 二叉树是递归定义的数据结构，其中序遍历是递增的有序序列。 操作1. 插入插入节点的过程是：若原二叉查找树为空，则直接插入；否则，若关键字 k 小于根节点关键字，则插入到左子树中，若关键字 k 大于根节点关键字，则插入到右子树中。注意每次插入的节点必是叶节点。 2. 删除二叉查找树的删除操作是相对复杂一点，它要按 3 种情况来处理： 若被删除节点 t 是叶子节点，则直接删除，不会破坏二叉排序树的性质； 若节点 t 只有左子树或只有右子树，则让 t 的子树成为 t 父节点的子树，替代 t 的位置； 若节点 t 既有左子树，又有右子树，则用 t 的直接前驱或者直接后继代替 t，然后从二叉查找树中删除这个后继，这样就转换成了第一或第二种情况。 3. 查找查找是从根节点开始，若二叉树非空，将给定值与根节点的关键字比较，若相等，则查找成功；若不等，则当给定值小于根节点关键字时，在根节点的左子树中查找，否则在根节点的右子树中查找。其查找平均时间复杂度为O(logn)，但是最差情况为插入的节点是有序的，则该二叉搜索树会变成左斜树(或者右斜树或者可以理解为“链表”)，即最差时间复杂度为O(n)，故而查找性能不是严格意义上的O(logn)，不稳定。 Java实现public class SortedBinaryTree&lt;E> { private Node&lt;E> root; // 根节点 private int size; // 二叉树元素个数 /** * 二叉树节点 */ private static class Node&lt;E> { E element; // 节点元素 Node&lt;E> lChild; // 左孩子 Node&lt;E> rChild; // 右孩子 public Node(E element) { this(element, null, null); } public Node(E element, Node&lt;E> lChild, Node&lt;E> rChild) { this.element = element; this.lChild = lChild; this.rChild = rChild; } } public SortedBinaryTree(List&lt;E> elements) { for (E e : elements) { add(e); } } public SortedBinaryTree(E[] elements) { for (E e : elements) { add(e); } } public SortedBinaryTree() { } /** * 判断当前元素是否存在于树中 * * @param element * @return */ public boolean contains(E element) { return search(root, element); } /** * 递归搜索,查找当前以curRoot为根节点的树中element存在与否 * * @param curRoot * @param element * @return */ @SuppressWarnings("unchecked") private boolean search(Node&lt;E> curRoot, E element) { if (curRoot == null) return false; Comparable&lt;? super E> e = (Comparable&lt;? super E>) element; int cmp = e.compareTo(curRoot.element); if (cmp > 0) { // 查找的元素大于当前根节点对应的元素,向右走 return search(curRoot.rChild, element); } else if (cmp &lt; 0) { // 查找的元素小于当前根节点对应的元素,向左走 return search(curRoot.lChild, element); } else { // 查找的元素等于当前根节点对应的元素,返回true return true; } } /** * 非递归搜索,查找当前以curRoot为根节点的树中的element是否存在 * * @param curRoot * 二叉排序树的根节点 * @param element * 被搜索的元素 * @param target * target[0]指向查找路径上最后一个节点: 如果当前查找的元素存在,则target[0]指向该节点 * @return */ @SuppressWarnings("unchecked") private boolean find(Node&lt;E> curRoot, E element, Node&lt;E>[] target) { if (curRoot == null) return false; Node&lt;E> tmp = curRoot; Comparable&lt;? super E> e = (Comparable&lt;? super E>) element; while (tmp != null) { int cmp = e.compareTo(tmp.element); target[0] = tmp; if (cmp > 0) { // 查找的元素大于当前节点对应的元素,向右走 tmp = tmp.rChild; } else if (cmp &lt; 0) { // 查找的元素小于当前节点对应的元素,向左走 tmp = tmp.lChild; } else { // 查找的元素等于当前根节点对应的元素,返回true return true; } } return false; } /** * 向二叉排序树中添加元素,如果当前元素已经存在,则添加失败,返回false,如果当前元素不存在,则添加成功,返回true * */ @SuppressWarnings("unchecked") public boolean add(E element) { if (root == null) { root = new Node&lt;E>(element); size++; return true; } Node&lt;E>[] target = new Node[1]; if (!find(root, element, target)) { // 当前元素不存在,插入元素 // 此时target节点即为需要插入的节点的父节点 Comparable&lt;? super E> e = (Comparable&lt;? super E>) element; int cmp = e.compareTo(target[0].element); Node&lt;E> newNode = new Node&lt;E>(element); if (cmp > 0) { // 插入的元素大于target指向的节点元素 target[0].rChild = newNode; } else { // 插入的元素小于target指向的节点元素 target[0].lChild = newNode; } size++; return true; } return false; } /** * 删除二叉排序树中的元素,如果当前元素不存在,则删除失败,返回false;如果当前元素存在,则删除该元素,重构二叉树,返回true * * @param element * @return */ @SuppressWarnings("unchecked") public boolean remove(E element) { Node&lt;E>[] target = new Node[1]; if (find(root, element, target)) { // 被删除的元素存在,则继续执行删除操作 remove(target[0]); return true; } return false; } /** * 释放当前节点 * * @param node */ private void free(Node&lt;E> node) { node.element = null; node.lChild = null; node.rChild = null; node = null; } /** * 删除二叉排序树中指定的节点 * * @param node */ private void remove(Node&lt;E> node) { Node&lt;E> tmp; if (node.lChild == null &amp;&amp; node.rChild == null) { // 当前node为叶子节点,删除当前节点,则node = null; node = null; } else if (node.lChild == null &amp;&amp; node.rChild != null) { // 如果被删除的节点左子树为空,则只需要重新连接其右子树 tmp = node; node = node.rChild; free(tmp); } else if (node.lChild != null &amp;&amp; node.rChild == null) { // 如果被删除的节点右子树为空,则只需要重新连接其左子树 tmp = node; node = node.lChild; free(tmp); } else { // 当前被删除的节点左右子树均存在,不为空 // 找到离当前node节点对应元素且最近的节点target(左子树的最右边节点 或者 右子树最左边节点) // 将node节点元素替换成target节点的元素,将target节点删除 tmp = node; // tmp是target的父节点 Node&lt;E> target = node.lChild; // 找到左子树最大子树 while (target.rChild != null) { // 在左子树中进行右拐 tmp = target; target = target.rChild; } node.element = target.element; // node.element元素替换为target.element if (tmp == node) { // tmp == node 说明没有在左子树中进行右拐,也就是node节点的左孩子没有右孩子, // 需要重新连接tmp节点左孩子 tmp.lChild = target.lChild; } else { // tmp != node, 进行了右拐,那么将重新连接tmp的右子树,将target.lChild赋值给tmp.rChild tmp.rChild = target.lChild; } // 释放节点 free(target); } // 删除成功,size--; size--; } public int size() { return size; } public boolean isEmpty() { return size() == 0; } public List&lt;E> preOrderTraverse() { List&lt;E> list = new ArrayList&lt;E>(); preOrderTraverse(root, list); return list; } private void preOrderTraverse(Node&lt;E> curRoot, List&lt;E> list) { if (curRoot == null) return; E e = curRoot.element; list.add(e); preOrderTraverse(curRoot.lChild, list); preOrderTraverse(curRoot.rChild, list); } public List&lt;E> inOrderTraverse() { List&lt;E> list = new ArrayList&lt;E>(); inOrderTraverse(root, list); return list; } private void inOrderTraverse(Node&lt;E> curRoot, List&lt;E> list) { if (curRoot == null) return; inOrderTraverse(curRoot.lChild, list); list.add(curRoot.element); inOrderTraverse(curRoot.rChild, list); } public List&lt;E> postOrderTraverse() { List&lt;E> list = new ArrayList&lt;E>(); postOrderTraverse(root, list); return list; } private void postOrderTraverse(Node&lt;E> curRoot, List&lt;E> list) { if (curRoot == null) return; inOrderTraverse(curRoot.lChild, list); inOrderTraverse(curRoot.rChild, list); list.add(curRoot.element); } /** * 返回中序遍历结果 */ @Override public String toString() { return inOrderTraverse().toString(); } public static void main(String[] args) { Integer[] elements = new Integer[] { 62, 88, 58, 47, 73, 99, 35, 51, 93, 29, 37, 49, 56, 36, 48, 50 }; SortedBinaryTree&lt;Integer> tree = new SortedBinaryTree&lt;Integer>(elements); System.out.println(tree); System.out.println(tree.contains(93)); System.out.println(tree.size()); System.out.println(tree.remove(47)); System.out.println(tree.preOrderTraverse()); System.out.println(tree.size()); } } Github地址SortedBinaryTree]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[查找-有序表查找(折半查找，插值查找，斐波拉契查找)]]></title>
      <url>post%2F243331195%2F</url>
      <content type="text"><![CDATA[引言如果待查找的数组是有序的，那么此时的查找就是有序表查找，这对于查找的帮助是很大的。属于有序表查找的有：折半查找（二分查找）、插值查找以及斐波那契查找。 1. 折半查找折半查找又称为二分查找，是一种效率较高的查找算法。折半查找的先决条件是查找表中的数据元素排列必须是有序的。折半查找先以有序数列的中点位置为比较对象，如果要找的元素值小于中点位置元素，则将待查序列缩小为左半部分，否则为右半部分。通过一次比较，可以将查找的区间缩小一半，每次比较，都可以将当前查找范围缩小至一般，可以明显的减少比较的次数，提高查找效率。时间复杂度：O(logn)算法实现： // 定义接口 interface Searcher { /** * 从数组array中查找关键字key,如果存在则返回该关键字在数组中任意出现的位置(不局限于首次或者末次之类的),否则返回-1 */ int search(int[] array, int key); } /** * 二分法查找,时间复杂度O(logn) */ class BinarySearcher implements Searcher { // 二分法查找前提,查找表array是顺序(这里要求递增)排列的 @Override public int search(int[] array, int key) { int low, high, mid; low = 0; // 定义最低下标为array首位 high = array.length - 1; // 定义最高下标为array末位 while (low &lt;= high) { mid = (low + high) / 2; // 折半 if (array[mid] > key) { // 中值比key大,则high=mid-1 high = mid - 1; } else if (array[mid] &lt; key) { // 中值比key小,则low=mid+1 low = mid + 1; } else { // 相等说明mid即为key在array中所在位置 return mid; } } return -1; } } 2. 插值查找插值查找是二分查找演化而来，相比于二分查找(折半),该算法考虑的是每次折的时候折多少,即不一定是1/2;如在一本字典中找”abstract”这个单词,我们自己来操作肯定是先翻到字典开始的那一小部分,而不是从字典的中间开始进行折半查找。 在二分查找中mid=(low+high)/2=low+1/2*(high-low),插值查找就是对1/2(系数,或者说比例)进行改变，它将1/2变成 (key - array[low])/(array[high] - array[low]),其实就是计算线性比例。 时间复杂度：O(logn)因为插值查找是依赖线性比例的，如果当前数组分布不是均匀的，那么该算法就不合适。 算法实现： class InterpolateSearcher implements Searcher { @Override public int search(int[] array, int key) { int low, high, mid; low = 0; // 定义最低下标为array首位 high = array.length - 1; // 定义最高下标为array末位 while (low &lt;= high) { // 相比二分法查找的更改处 mid = low + (int) (1.0 * (key - array[low]) / (array[high] - array[low]) * (high - low)); if (array[mid] > key) { // 中值比key大,则high=mid-1 high = mid - 1; } else if (array[mid] &lt; key) { // 中值比key小,则low=mid+1 low = mid + 1; } else { // 相等说明mid即为key在array中所在位置 return mid; } } return -1; } } 3. 斐波那契查找根据前面二分查找以及插值查找来看，有序表上的查找的关键就是如何分割当前查找的区域（二分查找对半分割，差值查找按线性比例分割），说到分割，还有一个著名的分割方式就是黄金分割。 斐波那契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、····，在数学上，斐波那契被递归方法如下定义：F(1)=1，F(2)=1，F(n)=f(n-1)+F(n-2) （n&gt;=2）。该数列越往后相邻的两个数的比值越趋向于黄金比例值（0.618） 所以我们可以根据斐波那契数列对当前区域进行分割 :) 查找算法：在斐波那契数列找一个等于略大于查找表中元素个数的数F(n)，将原查找表扩展为长度为F(n)(如果要补充元素，则补充重复最后一个元素，直到满足数组元素个数为F(n)个元素)，完成后进行斐波那契分割，即F(n)个元素分割为前半部分F(n-1)个元素，后半部分F(n-2)个元素，找出要查找的元素在那一部分并递归，直到找到。时间复杂度：O(logn)，平均性能优于二分查找。算法实现： class FibonacciSearcher implements Searcher { private static final int MAX_ARRAY_SIZE = 30; /** * 得到长度为len的斐波那契数列 * * @return */ private int[] fibonacci(int len) { if (len &lt; 0) throw new IllegalArgumentException("length must bigger than 0"); int[] fibonacci = new int[len]; fibonacci[0] = 1; fibonacci[1] = 1; for (int i = 2; i &lt; len; i++) { fibonacci[i] = fibonacci[i - 1] + fibonacci[i - 2]; } return fibonacci; } @Override public int search(int[] array, int key) { int low = 0; // 低位 int len = array.length; int high = len - 1; // 高位 int mid; // 中间位 int k = 0; // 斐波那契数列下标(用于进行分割) // 获取斐波那契数列 int[] fib = fibonacci(MAX_ARRAY_SIZE); // 获取斐波那契数列分割点位置 while (len > fib[k] - 1) { k++; } // 创建临时数组(数组长度为fib[k] - 1) int[] tmp = new int[fib[k] - 1]; // 拷贝原数组到tmp数组中 System.arraycopy(array, 0, tmp, 0, len); // 填充tmp数组中剩余的位置,补充的元素值为最后一个元素值 for (int i = len; i &lt; fib[k] - 1; i++) { tmp[i] = array[high]; } // 开始进行类似于二分查找的查找 while (low &lt;= high) { // 对于tmp数组,整个数组的长度为fib[k]-1 // 而 fib[k]-1 = (fib[k-1]-1) + 1 + (fib[k-2]-1); // 所以可以这样理解： mid下标对应元素可以将整个数组拆分为两部分,第1部分有fib[k-1]-1个元素,第2部分有fib[k-2]-1个元素 // mid=low+fib[k-1]-1; 正是将 数组的[low, max(high,tmp.length-1)] // 部分按照斐波那契规则分为两部分 mid = low + fib[k - 1] - 1; if (tmp[mid] > key) { // 需要查找第1部分 high = mid - 1; // fib[k] = fib[k-1] + fib[k-2] // 第一部分有fib[k-1]个元素,所以将k-1赋值为k k = k - 1; } else if (tmp[mid] &lt; key) { // 需要查找第2部分 low = mid + 1; // fib[k] = fib[k-1] + fib[k-2] // 第二部分有fib[k-2]个元素,所以将k-2赋值给k k = k - 2; } else { // 查找成功 // 以下代码其实就是返回 min(mid, high); // return Math.min(mid, high); if (mid &lt;= high) return mid; else return high; // 因为mid可能大于high,即查找到了补充的元素,那么还是应该返回high } } return -1; } } 结束语以上三种查找算法中，都依赖于顺序表，三者的区别本质上就是分割点选的不同。在分割点的选择中，折半查找 mid=(low+high)/2是加法与除法运算；插值查找mid = low+(key-array[low])/(array[high]-array[low])*(high-low)是复杂的四则运算；斐波那契查找mid=low+fib[k-1]-1是简单的加减运算。在海量数据查找过程中细微的差别会影响最终的效率。 三种查找算法，各有优劣，实际开发可以根据数据的特点综合考虑再做出选择。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[查找-顺序查找]]></title>
      <url>post%2F235983682%2F</url>
      <content type="text"><![CDATA[定义顺序查找又称为线性查找，其算法思路是从数组中的第一个（或最后一个）记录开始，将数组中元素逐个与需要查找的关键字进行比对，若发现有相等的，则查找成功；若始终未能相等，则查找失败。 Java实现// 定义接口 interface Searcher { /** * 从数组array中查找关键字key,如果存在则返回该关键字在数组中任意出现的位置(不局限于首次或者末次之类的),否则返回-1 */ int search(int[] array, int key); } /** * 顺序表查找,时间复杂度为O(n) */ class LinearSearcher implements Searcher { @Override public int search(int[] array, int key) { int len = array.length; for (int i = 0; i &lt; len; i++) { if (array[i] == key) return i; } return -1; } } LinearSearcher是标准的线性查找，这里有缺陷：在循环中每个循环实际上需要判断两次(一次是否相等,一次是否越界)，如何改进呢？其实就是设置“哨兵”： /** * 优化的顺序表查找,时间复杂度O(n),但是比普通顺序表查找效率高 */ class OptimizedLinearSearcher implements Searcher { // 相比单纯的线性查找每次for循环需要判断两次,这里设置关键字值(即哨兵)，可以让每次for循环只判断一次 // 当数据量比较大时,如果单纯从线性查找角度看,优化后的线性搜索优势明显 @Override public int search(int[] array, int key) { int len = array.length; if (len == 0) // array为空,返回-1 return -1; if (array[0] == key) return 0; array[0] = key; // array[0]不是key,那么将key赋值给array[0],将array[0]作为哨兵 // 这里"哨兵"也可以放在数组尾部 int i = len - 1; while (array[i] != key) { // 每次循环少判断一个 i--; } if (i == 0) // 从数组尾部一直查找到array[0]才找到,说明不存在 return -1; return i; } } 不论是线性查找还是改进后的线性查找，其时间复杂度都为O(n)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[栈的应用之中缀表达式和后缀表达式]]></title>
      <url>post%2F1484310523%2F</url>
      <content type="text"><![CDATA[中缀表达式： 是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于的中间（例：3 + 4），中缀表达式是人们常用的算术表示方法，但是不易被计算机所解析。 后缀表达式：是一个通用的算术或逻辑公式表示方法， 操作符是后缀形式处于操作数的后面（例：3 4 +），后缀表达式虽然不是人们所习惯的运算表示方法，但是易被计算机解析。例如：对于中缀表达式 9+(3-1)*2+10/2 , 其后缀表达式是 9 3 1 - 3 * + 10 2 / + , 那么为了方便计算机解析计算，我们需要将中缀表达式转换成后缀表达式，然后再对后缀表达式进行解析。 1. 中缀表达式转后缀表达式： 当读到一个操作数时，立即将它放到输出中。读到的是操作符则需要接着判断是否该入栈。读到的是左圆括号则入栈。 在读到操作符时，如果栈为空或者栈顶操作符为（，则入栈。如果栈顶操作符不为（，且此操作符优先级小于或等于此时栈顶操作符，则将栈中元素弹出直至 ①遇到左括号 或者 ②栈顶元素为更低优先级 或者 ③栈为空为止，并将当前操作符入栈；否则当前操作符继续入栈。操作符中，+-优先级低，*/优先级高。 如果遇到一个右括号，那么就将栈中元素弹出并输出直至遇到左括号为止。但是这个左括号只被弹出，并不输出。 如果读到输入的末尾，若栈不为空则将栈元素弹出直到该栈变成空栈，并将弹出的符号写到输出中。 “9+(3-1)*2+10/2” 转换过程： 操作过程 栈中元素 输出 读入 9，输出 9 读入 +，栈为空，规则2，入栈 + 9 读入 ( ，左括号，规则1，入栈 + ( 9 读入 3，输出 + ( 9 3 读入 -，栈顶为（，规则2，入栈 + ( - 9 3 读入 1，输出 + ( - 9 3 1 读入 ) ，右括号，规则3，出栈并输出 + 9 3 1 - 读入 *，*优先级高于栈顶+，规则,2，入栈 + * 9 3 1 - 读入 3，输出 + * 9 3 1 - 3 读入 +，+优先级低于栈顶*，规则2，栈中元素出栈，当前操作符入栈 + 9 3 1 - 3 * + 读入 10， 输出 + 9 3 1 - 3 * + 10 读入 / ， /优先级高于+，入栈 + / 9 3 1 - 3 * + 10 读入 2， 输出 + / 9 3 1 - 3 * + 10 读至末尾，规则4，栈不为空，栈中元素出栈并输出 9 3 1 - 3 * + 10 / + 2. 后缀表达式计算最终结果： 从左到右遍历表达式的每个数字和符号,遇到是数字则进栈,遇到是运算符则将栈顶两个元素出栈,进行运算并将运算结果进栈； 遍历完后缀表达式,此时栈中剩余的数字就是运算结果。 “9 3 1 - 3 * + 10 2 / +” 计算过程： 操作过程 栈中元素 读入 9，入栈 9 读入 3，入栈 9 3 读入 1，入栈 9 3 1 读入 -，运算并将结果入栈 9 2 读入 3，入栈 9 2 3 读入 *，运算并将结果入栈 9 6 读入 +，运算并将结果入栈 15 读入 10，入栈 15 10 读入 2，入栈 15 10 2 读入 /，运算并将结果入栈 15 5 读入 +，运算并将结果入栈 20 读入完毕，栈中元素即为结果 20 简单中缀表达式计算的java实现： public class SimpleCalcutor { private class Item { private String value; private Integer number; public Item(String value) { this.value = value; try { number = Integer.parseInt(value); } catch (Exception ignore) { } } public boolean isNumber() { return number != null; } public int getNumber() { if (isNumber()) return number; throw new NumberFormatException(); } public boolean isAdd() { return "+".equals(value); } public boolean isSub() { return "-".equals(value); } public boolean isMul() { return "*".equals(value); } public boolean isDiv() { return "/".equals(value); } public boolean isLeftBracket() { return "(".equals(value); } public boolean isRightBracket() { return ")".equals(value); } public int getPriority() { if (isAdd() || isSub()) return 0; if (isMul() || isDiv()) return 1; throw new RuntimeException("This is not +, -, *, /"); } @Override public String toString() { return value != null ? value.toString() : null; } } /** * 计算结果 * * @param calStr * @return */ public int calculate(String calStr) { List&lt;Item> infixes = parse(calStr); List&lt;Item> postfixes = infix2postfix(infixes); return calculateByPostfix(postfixes); } /** * 利用正则表达式将待计算的字符串转化为List&lt;Item>形式 ,如 10/2 -> [10, /, 2] * * @param calStr * @return */ private List&lt;Item> parse(String calStr) { Pattern pattern = Pattern.compile("\\D|\\d+"); Matcher m = pattern.matcher(calStr); List&lt;Item> items = new ArrayList&lt;Item>(); while (m.find()) { items.add(new Item(m.group(0))); } return items; } /** * 中缀表达式转换为后缀表达式 * &lt;p> * 1.当读到一个操作数时，立即将它放到输出中。读到的是操作符则需要接着判断是否该入栈。读到的是左圆括号则入栈。&lt;br> * 2.如果遇到一个右括号，那么就将栈中元素弹出并输出直至遇到左括号为止。但是这个左括号只被弹出，并不输出。&lt;br> * 3.在读到操作符时，如果此操作符优先级小于或等于此时栈顶操作符，则将栈中元素弹出直至(1)遇到左括号或者(2)栈顶元素为更低优先级或者(3) * 栈为空为止。操作符中，'+''-'优先级最低，'('')'优先级最高。 &lt;br> * 4.如果读到输入的末尾，将栈元素弹出直到该栈变成空栈，将符号写到输出中。 * * @return */ private List&lt;Item> infix2postfix(List&lt;Item> infixes) { List&lt;Item> postfixes = new ArrayList&lt;Item>(); Stack&lt;Item> stack = new Stack&lt;Item>(); for (Item item : infixes) { if (item.isNumber()) { postfixes.add(item); } else if (item.isRightBracket()) { // ) 右括号,将栈中元素弹出直至左括号,且左括号和右括号不加入到后缀表达式中 while (true) { Item tmp = stack.pop(); if (tmp.isLeftBracket()) break; postfixes.add(tmp); } } else if (item.isLeftBracket()) { // ( 左括号,将左括号入栈 stack.push(item); } else { // 当前操作符为 +, -, *, /, if (stack.isEmpty()) { // 操作符栈为空,则将当前操作符压入栈 stack.push(item); continue; } Item top = stack.peek(); if (top.isLeftBracket()) { // 操作符栈顶为左括号(,则将当前操作符压入栈 stack.push(item); continue; } if (item.getPriority() &lt;= top.getPriority()) { // 如果此操作符(+,-,*,/)优先级小于或等于此时栈顶操作符 // 则将栈中元素弹出直至(1)遇到左括号或者(2)栈顶元素为更低优先级或者(3)栈为空为止 // 并将弹出的元素加入后缀表达式中,将当前操作符压入栈中 while (true) { Item tmp = stack.peek(); if (tmp.isLeftBracket() || tmp.getPriority() &lt; item.getPriority()) { break; } postfixes.add(tmp); stack.pop(); if (stack.isEmpty()) break; } stack.push(item); } else { // 如果当前操作符(+,-,*,/)优先级大于此时栈顶操作符,则将当前操作符压入栈 stack.push(item); } } } // 如果栈中元素不为空,则将栈中元素全部弹出,加入后缀表达式中 while (!stack.isEmpty()) { postfixes.add(stack.pop()); } return postfixes; } /** * 通过后缀表达式计算数值 * &lt;p> * 1. 从左到右遍历表达式的每个数字和符号,遇到是数字则进栈,遇到是运算符则将栈顶两个元素出栈,进行运算并将运算结果进栈&lt;br> * 2. 遍历完后缀表达式,此时栈中剩余的数字就是运算结果 * * @param postfixes * @return */ private int calculateByPostfix(List&lt;Item> postfixes) { Stack&lt;Integer> stack = new Stack&lt;Integer>(); for (Item item : postfixes) { if (item.isNumber()) { stack.push(item.getNumber()); } else { // 运算符 int num1 = stack.pop(); int num2 = stack.pop(); int result; if (item.isAdd()) { result = num2 + num1; } else if (item.isSub()) { result = num2 - num1; } else if (item.isMul()) { result = num2 * num1; } else if (item.isDiv()) { result = num2 / num1; } else { throw new IllegalArgumentException("Operator invalid : " + item.value); } stack.push(result); } } return stack.pop(); } public static void main(String[] args) { SimpleCalcutor calcutor = new SimpleCalcutor(); String calStr = "9+(3-1)*3+10/2"; int result = calcutor.calculate(calStr); System.out.println(result); } } 源码github地址：SimpleCalculator 参考链接：利用栈将中缀表达式转换成后缀表达式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[KMP字符串模式匹配算法Java实现]]></title>
      <url>post%2F3825161135%2F</url>
      <content type="text"><![CDATA[本文灵感来自于July的博客从头到尾彻底理解KMP，并着重于Java实现 :)。 现有字符串匹配算法有不少，如简单暴力的朴素算法(暴力匹配算法)、KMP算法、BM算法以及Sunday算法等，在这里仅介绍前两种算法。 1. 朴素算法朴素算法即暴力匹配算法，对于长度为n的文本串S和长度为m模式串P，在文本串S中是否存在一个有效偏移i，其中 0≤ i &lt; n - m + 1，使得 S[i… i+m - 1] = P[0 … m-1]（注：下标从0开始），如果存在则匹配成功，否则匹配失败。由于在匹配过程中一旦不匹配，就要让模式串P相对于文本串S右移1，即i需要进行回溯，其时间复杂度为O(n*m)。Java实现： // 定义接口 interface StringMatcher { /** * 从原字符串中查找模式字符串的位置,如果模式字符串存在,则返回模式字符串第一次出现的位置,否则返回-1 * * @param source * 原字符串 * @param pattern * 模式字符串 * @return if substring exists, return the first occurrence of pattern * substring, return -1 if not. */ int indexOf(String source, String pattern); } /** * 暴力匹配 * &lt;p> * 时间复杂度: O(m*n), m = pattern.length, n = source.length */ class ViolentStringMatcher implements StringMatcher { @Override public int indexOf(String source, String pattern) { int i = 0, j = 0; int sLen = source.length(), pLen = pattern.length(); char[] src = source.toCharArray(); char[] ptn = pattern.toCharArray(); while (i &lt; sLen &amp;&amp; j &lt; pLen) { if (src[i] == ptn[j]) { // 如果当前字符匹配成功,则将两者各自增1,继续比较后面的字符 i++; j++; } else { // 如果当前字符匹配不成功,则i回溯到此次匹配最开始的位置+1处,也就是i = i - j + 1 // (因为i,j是同步增长的), j = 0; i = i - j + 1; j = 0; } } // 匹配成功,则返回模式字符串在原字符串中首次出现的位置;否则返回-1 if (j == pLen) return i - j; else return -1; } } 2. KMP算法与朴素算法不同，朴素算法是当遇到不匹配字符时，向后移动一位继续匹配，而KMP算法是当遇到不匹配字符时，不是简单的向后移一位字符，而是根据前面已匹配的字符数和模式串前缀和后缀的最大相同字符串长度数组next的元素来确定向后移动的位数，所以KMP算法的时间复杂度比朴素算法的要少，并且是线性时间复杂度，即预处理时间复杂度是O(m)，匹配时间复杂度是O(n)。 next数组含义：代表在模式串P中，当前下标对应的字符之前的字符串中，有多大长度的相同前缀后缀。例如如果next [j] = k，代表在模式串P中，下标为j的字符之前的字符串中有最大长度为k 的相同前缀后缀。 KMP算法的核心就是求next数组，在字符串匹配的过程中，一旦某个字符匹配不成功，next数组就会指导模式串P到底该相对于S右移多少位再进行下一次匹配，从而避免无效的匹配。 next数组求解方法： next[0] = -1。 如果已知next[j] = k,如何求出next[j+1]呢?具体算法如下: 如果p[j] = p[k], 则next[j+1] = next[k] + 1; 如果p[j] != p[k], 则令k=next[k],如果此时p[j]==p[k],则next[j+1]=k+1,如果不相等,则继续递归前缀索引,令 k=next[k],继续判断,直至k=-1(即k=next[0])或者p[j]=p[k]为止 详细的介绍及分析还请移步从头到尾彻底理解KMP，在下语拙 :(Java实现： /** * KMP模式匹配 * @author Tianma * */ class KMPStringMatcher implements StringMatcher { /** * 获取KMP算法中pattern字符串对应的next数组 * * @param p * 模式字符串对应的字符数组 * @return */ protected int[] getNext(char[] p) { // 已知next[j] = k,利用递归的思想求出next[j+1]的值 // 如果已知next[j] = k,如何求出next[j+1]呢?具体算法如下: // 1. 如果p[j] = p[k], 则next[j+1] = next[k] + 1; // 2. 如果p[j] != p[k], 则令k=next[k],如果此时p[j]==p[k],则next[j+1]=k+1, // 如果不相等,则继续递归前缀索引,令 k=next[k],继续判断,直至k=-1(即k=next[0])或者p[j]=p[k]为止 int pLen = p.length; int[] next = new int[pLen]; int k = -1; int j = 0; next[0] = -1; // next数组中next[0]为-1 while (j &lt; pLen - 1) { if (k == -1 || p[j] == p[k]) { k++; j++; next[j] = k; } else { k = next[k]; } } return next; } @Override public int indexOf(String source, String pattern) { int i = 0, j = 0; char[] src = source.toCharArray(); char[] ptn = pattern.toCharArray(); int sLen = src.length; int pLen = ptn.length; int[] next = getNext(ptn); while (i &lt; sLen &amp;&amp; j &lt; pLen) { // 如果j = -1,或者当前字符匹配成功(src[i] = ptn[j]),都让i++,j++ if (j == -1 || src[i] == ptn[j]) { i++; j++; } else { // 如果j!=-1且当前字符匹配失败,则令i不变,j=next[j],即让pattern模式串右移j-next[j]个单位 j = next[j]; } } if (j == pLen) return i - j; return -1; } } 3. 优化的KMP算法（改进next数组）具体过程移步从头到尾彻底理解KMP的3.3.8 Next 数组的优化在这里给出Java实现： /** * 优化的KMP算法(对next数组的获取进行优化) * * @author Tianma * */ class OptimizedKMPStringMatcher extends KMPStringMatcher { @Override protected int[] getNext(char[] p) { // 已知next[j] = k,利用递归的思想求出next[j+1]的值 // 如果已知next[j] = k,如何求出next[j+1]呢?具体算法如下: // 1. 如果p[j] = p[k], 则next[j+1] = next[k] + 1; // 2. 如果p[j] != p[k], 则令k=next[k],如果此时p[j]==p[k],则next[j+1]=k+1, // 如果不相等,则继续递归前缀索引,令 k=next[k],继续判断,直至k=-1(即k=next[0])或者p[j]=p[k]为止 int pLen = p.length; int[] next = new int[pLen]; int k = -1; int j = 0; next[0] = -1; // next数组中next[0]为-1 while (j &lt; pLen - 1) { if (k == -1 || p[j] == p[k]) { k++; j++; // 修改next数组求法 if (p[j] != p[k]) { next[j] = k;// KMPStringMatcher中只有这一行 } else { // 不能出现p[j] = p[next[j]],所以如果出现这种情况则继续递归,如 k = next[k], // k = next[[next[k]] next[j] = next[k]; } } else { k = next[k]; } } return next; } } 4. 花絮提到字符串匹配，或者说字符串查找，我们会想到Java中的String类就有一个String.indexOf(String str);方法，那它使用的是什么算法呢？在这里截取JavaSE-1.8的源码： // String.indexOf(String str); 最终会调用该方法 /** * Code shared by String and StringBuffer to do searches. The * source is the character array being searched, and the target * is the string being searched for. * * @param source the characters being searched.(源字符数组) * @param sourceOffset offset of the source string.(源字符数组偏移量) * @param sourceCount count of the source string.(源字符数组长度) * @param target the characters being searched for.(待搜索的模式字符数组) * @param targetOffset offset of the target string.(模式字符数组偏移量) * @param targetCount count of the target string.(模式数组长度) * @param fromIndex the index to begin searching from.(从原字符数组的哪个下标开始查询) */ static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) { if (fromIndex >= sourceCount) { return (targetCount == 0 ? sourceCount : -1); } if (fromIndex &lt; 0) { fromIndex = 0; } if (targetCount == 0) { return fromIndex; } char first = target[targetOffset]; int max = sourceOffset + (sourceCount - targetCount); for (int i = sourceOffset + fromIndex; i &lt;= max; i++) { /* Look for first character. */ // 找到第一个匹配的字符的位置 if (source[i] != first) { while (++i &lt;= max &amp;&amp; source[i] != first); } /* Found first character, now look at the rest of v2 * if (i &lt;= max) { // 找到了第一个匹配的字符，看余下的是否完全匹配 int j = i + 1; int end = j + targetCount - 1; for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++); if (j == end) { /* Found whole string. */ return i - sourceOffset; } // 如果不完全匹配，因为外层for循环中有i++，即i+1继续匹配 // 故而该方法本质上就是字符串匹配的朴素算法 } } return -1; } 通过对代码片段的注释和分析可以看出，Java源码中的String.indexOf(String str); 内部所使用的算法其实就是字符串匹配的朴素算法… 源码github地址:StringMatchSample 重要参考:从头到尾彻底理解KMP]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android根据图片Uri获取图片绝对路径]]></title>
      <url>post%2F3401996021%2F</url>
      <content type="text"><![CDATA[当我们需要选择并获取图片将其展示出来时，一般会这样处理： // 进入选择图片的界面 private void selectImage(){ Intent intent = new Intent(Intent.ACTION_GET_CONTENT); intent.setType("image/*"); startActivityForResult(intent, YOUR_CHOOSE_IMAGE_REQUEST_CODE); } // 在onActivityResult()回调方法中进行数据获取 protected void onActivityResult(int requestCode, int resultCode, Intent data) { // ... 进行一些判断处理 Uri uri = data.getData(); // ... 接下来进行图片显示 } 以上可以看出我们获取的是Uri类型的数据，要显示图片可以先根据Uri获取图片的位置，然后再显示在界面上，那么如何根据Uri来获取图片的绝对路径呢？ 这涉及到Android版本适配问题，因为Android Api版本不同，获取Uri对应的图片绝对路径也不一样，那么需要对不同的Api进行适配： 2017-7-14 更新：感谢朋友们的反馈，之前的写法因为没有考虑全面，会在 api&gt;=19 时出现空指针异常，这里将代码更新。如遇问题，烦请留言反馈。 /** * 根据Uri获取图片的绝对路径 * * @param context 上下文对象 * @param uri 图片的Uri * @return 如果Uri对应的图片存在, 那么返回该图片的绝对路径, 否则返回null */ public static String getRealPathFromUri(Context context, Uri uri) { int sdkVersion = Build.VERSION.SDK_INT; if (sdkVersion >= 19) { // api >= 19 return getRealPathFromUriAboveApi19(context, uri); } else { // api &lt; 19 return getRealPathFromUriBelowAPI19(context, uri); } } /** * 适配api19以下(不包括api19),根据uri获取图片的绝对路径 * * @param context 上下文对象 * @param uri 图片的Uri * @return 如果Uri对应的图片存在, 那么返回该图片的绝对路径, 否则返回null */ private static String getRealPathFromUriBelowAPI19(Context context, Uri uri) { return getDataColumn(context, uri, null, null); } /** * 适配api19及以上,根据uri获取图片的绝对路径 * * @param context 上下文对象 * @param uri 图片的Uri * @return 如果Uri对应的图片存在, 那么返回该图片的绝对路径, 否则返回null */ @SuppressLint("NewApi") private static String getRealPathFromUriAboveApi19(Context context, Uri uri) { String filePath = null; if (DocumentsContract.isDocumentUri(context, uri)) { // 如果是document类型的 uri, 则通过document id来进行处理 String documentId = DocumentsContract.getDocumentId(uri); if (isMediaDocument(uri)) { // MediaProvider // 使用':'分割 String id = documentId.split(":")[1]; String selection = MediaStore.Images.Media._ID + "=?"; String[] selectionArgs = {id}; filePath = getDataColumn(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection, selectionArgs); } else if (isDownloadsDocument(uri)) { // DownloadsProvider Uri contentUri = ContentUris.withAppendedId(Uri.parse("content://downloads/public_downloads"), Long.valueOf(documentId)); filePath = getDataColumn(context, contentUri, null, null); } } else if ("content".equalsIgnoreCase(uri.getScheme())){ // 如果是 content 类型的 Uri filePath = getDataColumn(context, uri, null, null); } else if ("file".equals(uri.getScheme())) { // 如果是 file 类型的 Uri,直接获取图片对应的路径 filePath = uri.getPath(); } return filePath; } /** * 获取数据库表中的 _data 列，即返回Uri对应的文件路径 * @return */ private static String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) { String path = null; String[] projection = new String[]{MediaStore.Images.Media.DATA}; Cursor cursor = null; try { cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs, null); if (cursor != null &amp;&amp; cursor.moveToFirst()) { int columnIndex = cursor.getColumnIndexOrThrow(projection[0]); path = cursor.getString(columnIndex); } } catch (Exception e) { if (cursor != null) { cursor.close(); } } return path; } /** * @param uri the Uri to check * @return Whether the Uri authority is MediaProvider */ private static boolean isMediaDocument(Uri uri) { return "com.android.providers.media.documents".equals(uri.getAuthority()); } /** * @param uri the Uri to check * @return Whether the Uri authority is DownloadsProvider */ private static boolean isDownloadsDocument(Uri uri) { return "com.android.providers.downloads.documents".equals(uri.getAuthority()); } 以上便可以获取Uri对应的图片的绝对路径，然后就可以愉快的做我们想做的事情咯~ 最后，附上一个小demo，可以戳 这里 参考链接:Android Gallery on KitKat returns different Uri for Intent.ACTION_GET_CONTENT]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android获取图片压缩后的Bitmap避免OOM]]></title>
      <url>post%2F3401996020%2F</url>
      <content type="text"><![CDATA[OOM即Out Of Memory的简称，Android平台避免OOM异常的发生是非常有必要的。而在Android中加载大量大图便可能会导致OOM异常的出现，解决的办法之一就是加载图片之前对图片进行压缩然后再获取图片对应的Bitmap对象，那么应该如何操作呢？ 如下： /** * 通过图片的绝对路径来获取对应的压缩后的Bitmap对象 */ public static Bitmap getCompressedBitmap(String filePath, int requireWidth, int requireHeight) { // 第一次解析将inJustDecodeBounds设置为true,用以获取图片大小,并且不需要将Bitmap对象加载到内存中 BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeFile(filePath, options); // 第一次解析 // 计算inSampleSize的值,并且赋值给Options.inSampleSize options.inSampleSize = calculateInSampleSize(options, requireWidth, requireHeight); // 使用获取到的inSampleSize再次解析图片 options.inJustDecodeBounds = false; return BitmapFactory.decodeFile(filePath, options); } /** * 通过图片资源id获取图片对应的压缩后的Bitmap对象 */ public static Bitmap getCompressedBitmap(Resources res, int resId, int requiredWidth, int requiredHeight) { BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeResource(res, resId, options);// 第一次解析 options.inSampleSize = calculateInSampleSize(options, requiredWidth, requiredHeight); options.inJustDecodeBounds = false; return BitmapFactory.decodeResource(res, resId, options);// 第一次解析 } /** * 计算压缩的inSampleSize的值,该值会在宽高上都进行压缩(也就是压缩前后比例是inSampleSize的平方倍) */ private static int calculateInSampleSize(BitmapFactory.Options options, int requireWidth, int requireHeight) { // 获取源图片的实际的宽度和高度 int realWidth = options.outWidth; int realHeight = options.outHeight; int inSampleSize = 1; if (realWidth > requireWidth || realHeight > requireHeight) { // 计算出实际的宽高与目标宽高的比例 int widthRatio = Math.round((float) realWidth / (float) requireWidth); int heightRatio = Math.round((float) realHeight / (float) requireHeight); // 选择宽高比例最小的值赋值给inSampleSize,这样可以保证最终图片的宽高一定会大于或等于目标的宽高 inSampleSize = widthRatio &lt; heightRatio ? widthRatio : heightRatio; } return inSampleSize; } 以上代码中，有一点值得商榷：到底是要让图片显示完全还是让图片宽高和需要的宽高一致呢？如果需要让图片宽高和需要的宽高一致的话，就选择比率小的: inSampleSize = widthRatio &lt; heightRatio ? widthRatio : heightRatio; 如果需要让图片显示完全的话，就选择比率大的： inSampleSize = widthRatio > heightRatio ? widthRatio : heightRatio; 如果两者都要兼顾的话，就让方法多设置参数，让调用者决定去吧！ :) 参考链接：Displaying Bitmaps EfficientlyAndroid高效加载大图、多图解决方案，有效避免程序OOM]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android获取Bitmap在其ImageView中的偏移量]]></title>
      <url>post%2F4080066433%2F</url>
      <content type="text"><![CDATA[在ImageView中设置不同的scaleType(包括center, centerInside, centerCrop, fitXY, fitCenter, fitStart, fitEnd, matrix)属性时，ImageView中实际的图片(也就是Bitmap)会根据不同的scaleType属性来确定自己相对于ImageView的位置。 例如： fitCenter: fitStart:图片中的天蓝色是我给ImageView设置的backgroud属性，可以看出Bitmap相对于ImageView的位置与scaleType属性是相关的。那么，如何获取Bitmap在其ImageView中的偏移量（也就是在x和y方向上的像素偏移量）呢？代码片段如下： /** * 获取Bitmap在ImageView中的偏移量数组,其中第0个值表示在水平方向上的偏移值,第1个值表示在垂直方向上的偏移值 * * @param imageView * @param includeLayout 在计算偏移的时候是否要考虑到布局的因素,如果要考虑该因素则为true,否则为false * @return the offsets of the bitmap inside the imageview, offset[0] means horizontal offset, offset[1] means vertical offset */ private int[] getBitmapOffset(ImageView imageView, boolean includeLayout) { int[] offset = new int[2]; float[] values = new float[9]; Matrix matrix = imageView.getImageMatrix(); matrix.getValues(values); // x方向上的偏移量(单位px) offset[0] = (int) values[2]; // y方向上的偏移量(单位px) offset[1] = (int) values[5]; if (includeLayout) { ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams) imageView.getLayoutParams(); int paddingTop = imageView.getPaddingTop(); int paddingLeft = imageView.getPaddingLeft(); offset[0] += paddingLeft + params.leftMargin; offset[1] += paddingTop + params.topMargin; } return offset; } 上面的代码中Matrix类实际上是一个3*3的矩阵，看Android源码： public class Matrix { public static final int MSCALE_X = 0; public static final int MSKEW_X = 1; public static final int MTRANS_X = 2; public static final int MSKEW_Y = 3; public static final int MSCALE_Y = 4; public static final int MTRANS_Y = 5; public static final int MPERSP_0 = 6; public static final int MPERSP_1 = 7; public static final int MPERSP_2 = 8; ... } 其中MTRANS_X，MTRANS_Y字段分别表示x和y方向上的平移量。所以在代码片段中会出现： offset[0] = (int) values[2]; offset[1] = (int) values[5]; 参考链接：android - how to get the image edge x/y position inside imageviewAndroid中图像变换Matrix的原理、代码验证和应用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python3.4在内存中生成zip压缩文件]]></title>
      <url>post%2F4080066432%2F</url>
      <content type="text"><![CDATA[最近使用Django1.8.5搭建了一个Web项目，用来生成Android客户端的皮肤apk，相当于一个在线的皮肤apk生成工具，于是就理所当然的需要进行在线的下载apk的操作。由于Android项目比较大，一种主题皮肤对应的apk不止一个，一次性下载多个文件的话，于是选择打包下载。 本文在使用Python在内存中生成zip文件的基础上也进行了小的修改。主要是原文的生产环境是Python2.x，而我使用的是Python3.4，在语法上有些小的变动。 # !user/bin/env python3 # -*-coding : utf-8 -*- import zipfile from io import BytesIO import os u''' Create zip file in memory. ''' class InMemoryZIP(object): def __init__(self): # create the in-memory file-like object self.in_memory_zip = BytesIO() def append(self, filename_in_zip, file_contents): """ Appends a file with name filename_in_zip \ and contents of file_contents to the in-memory zip. """ # create a handle to the in-memory zip in append mode zf = zipfile.ZipFile(self.in_memory_zip, 'a', zipfile.ZIP_DEFLATED, False) # write the file to the in-memory zip zf.writestr(filename_in_zip, file_contents) # mark the files as having been created on Windows # so that Unix permissions are not inferred as 0000 for zfile in zf.filelist: zfile.create_system = 0 return self def appendfile(self, file_path, file_name=None): """ Read a file with path file_path \ and append to in-memory zip with name file_name. """ if file_name is None: file_name = os.path.split(file_path)[1] f = open(file_path, 'rb') file_contents = f.read() self.append(file_name, file_contents) f.close() return self def read(self): """ Returns a string with the contents of the in-memory zip. """ self.in_memory_zip.seek(0) return self.in_memory_zip.read() def writetofile(self, filename): """ Write the in-memory zip to a file """ f = open(filename, 'wb') f.write(self.read()) f.close() if __name__ == '__main__': imz = InMemoryZIP() imz.appendfile('a.txt').append('test.txt', 'This is content in test.txt') imz.writetofile('test.zip') 与原链接中的博文相比主要改动如下： 将原文的 import StringIO 改成了 from io import BytesIO，主要就是 Python2.x 和 Python3.x 的格式区别。其实也可以将 import StringIO 改成 from io import BytesIO as StringIO ，这样的话在代码中就不需要进行替换，但是可能会误导其他读这段代码的人。 在Django中简单的使用方法为: #... def downloadFiles(request): fns = ["/apk/foo1.apk", "/apk/foo2.apk", "/apk/foo3.apk",] imz = InMemoryZip() for fn in fns: imz.appendfile(fn) data = img.read() response = HttpResponse(content_type="application/octet-stream") response["Content-Disposition"] = "attachment; %s" % "foo.zip" response["Content-Length"] = len(data) response.write(data) return response 与原链接的博文相比改动就是 HttpResponse 中的参数要使用 content_type 而不是 mimetype最后引用原文的一段话: 这个方法虽然很方便，不过很耗资源，我试着用它在 Django 里压缩一个 1.4G 的文本文件，差不多用了 8 分钟，期间 CPU 使用率一直是 100%，所以，如果要压缩的是大文件，或者压缩任务比较频繁，可能需要认真处理一下性能问题。 也就是说这个方法适合下载小文件，要是下载的文件较大的话，建议阅读以下文章: Django 大文件下载 Django 实现下载文件功能]]></content>
    </entry>

    
  
  
</search>
